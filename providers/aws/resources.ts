/** Automatically @generated by gen-providers.ts, DO NOT EDIT */

import * as _ from "lodash";
import * as AT from "./types";
import * as TF from "../../core/core";

/**
 *  Provides attachment of a autoscaling group to a ALB load balancer
 *
 *  see https://www.terraform.io/docs/providers/aws/r/autoscaling_attachment.html
 */
export function createAutoscalingAttachment(tfgen: TF.Generator, rname: string, params: AutoscalingAttachmentParams): AutoscalingAttachment {
  const fields = fieldsFromAutoscalingAttachmentParams(params);
  const resource = tfgen.createTypedResource('AutoscalingAttachment', 'aws_autoscaling_attachment', rname, fields);

  return {
    ...resource,
  };
}

export interface AutoscalingAttachment extends TF.ResourceT<'AutoscalingAttachment'> {
}

type AutoscalingAttachmentId = {type:'AutoscalingAttachmentId',value:string};

/**
 *  Provides aws_autoscaling_group
 *
 *  see https://www.terraform.io/docs/providers/aws/r/autoscaling_group.html
 */
export function createAutoscalingGroup(tfgen: TF.Generator, rname: string, params: AutoscalingGroupParams): AutoscalingGroup {
  const fields = fieldsFromAutoscalingGroupParams(params);
  const resource = tfgen.createTypedResource('AutoscalingGroup', 'aws_autoscaling_group', rname, fields);
  const id: AutoscalingGroupId =  {type: 'AutoscalingGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: AutoscalingGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'AutoscalingGroup');

  return {
    ...resource,
    id,
    name,
    arn,
  };
}

export interface AutoscalingGroup extends TF.ResourceT<'AutoscalingGroup'> {
  id: AutoscalingGroupId;
  name: string;
  arn: AutoscalingGroupArn;
}

type AutoscalingGroupId = {type:'AutoscalingGroupId',value:string};
export type AutoscalingGroupArn = AT.ArnT<"AutoscalingGroup">;

/**
 *  Provides an EC2 instance resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/instance.html
 */
export function createInstance(tfgen: TF.Generator, rname: string, params: InstanceParams): Instance {
  const fields = fieldsFromInstanceParams(params);
  const resource = tfgen.createTypedResource('Instance', 'aws_instance', rname, fields);
  const id: InstanceId =  {type: 'InstanceId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};
  const availability_zone: AT.AvailabilityZone =  {type: 'AvailabilityZone', value: '${' + TF.resourceName(resource) + '.availability_zone}'};

  return {
    ...resource,
    id,
    arn,
    availability_zone,
  };
}

export interface Instance extends TF.ResourceT<'Instance'> {
  id: InstanceId;
  arn: AT.Arn;
  availability_zone: AT.AvailabilityZone;
}

type InstanceId = {type:'InstanceId',value:string};

/**
 *  Provides an RDS instance resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/db_instance.html
 */
export function createDbInstance(tfgen: TF.Generator, rname: string, params: DbInstanceParams): DbInstance {
  const fields = fieldsFromDbInstanceParams(params);
  const resource = tfgen.createTypedResource('DbInstance', 'aws_db_instance', rname, fields);
  const id: DbInstanceId =  {type: 'DbInstanceId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const username: string =  '${' + TF.resourceName(resource) + '.username}';
  const address: string =  '${' + TF.resourceName(resource) + '.address}';
  const port: string =  '${' + TF.resourceName(resource) + '.port}';
  const engine_version: string =  '${' + TF.resourceName(resource) + '.engine_version}';
  const arn: DbInstanceArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'DbInstance');

  return {
    ...resource,
    id,
    name,
    username,
    address,
    port,
    engine_version,
    arn,
  };
}

export interface DbInstance extends TF.ResourceT<'DbInstance'> {
  id: DbInstanceId;
  name: string;
  username: string;
  address: string;
  port: string;
  engine_version: string;
  arn: DbInstanceArn;
}

type DbInstanceId = {type:'DbInstanceId',value:string};
export type DbInstanceArn = AT.ArnT<"DbInstance">;

/**
 *  Provides an Elastic IP Address.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/eip.html
 */
export function createEip(tfgen: TF.Generator, rname: string, params: EipParams): Eip {
  const fields = fieldsFromEipParams(params);
  const resource = tfgen.createTypedResource('Eip', 'aws_eip', rname, fields);
  const id: EipId =  {type: 'EipId', value: '${' + TF.resourceName(resource) + '.id}'};
  const public_ip: AT.IpAddress =  {type: 'IpAddress', value: '${' + TF.resourceName(resource) + '.public_ip}'};
  const private_ip: AT.IpAddress =  {type: 'IpAddress', value: '${' + TF.resourceName(resource) + '.private_ip}'};

  return {
    ...resource,
    id,
    public_ip,
    private_ip,
  };
}

export interface Eip extends TF.ResourceT<'Eip'> {
  id: EipId;
  public_ip: AT.IpAddress;
  private_ip: AT.IpAddress;
}

type EipId = {type:'EipId',value:string};

/**
 *  Provides a VPC.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/vpc.html
 */
export function createVpc(tfgen: TF.Generator, rname: string, params: VpcParams): Vpc {
  const fields = fieldsFromVpcParams(params);
  const resource = tfgen.createTypedResource('Vpc', 'aws_vpc', rname, fields);
  const id: VpcId =  {type: 'VpcId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface Vpc extends TF.ResourceT<'Vpc'> {
  id: VpcId;
}

type VpcId = {type:'VpcId',value:string};

/**
 *  Provides a VPC Subnet.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/subnet.html
 */
export function createSubnet(tfgen: TF.Generator, rname: string, params: SubnetParams): Subnet {
  const fields = fieldsFromSubnetParams(params);
  const resource = tfgen.createTypedResource('Subnet', 'aws_subnet', rname, fields);
  const id: SubnetId =  {type: 'SubnetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface Subnet extends TF.ResourceT<'Subnet'> {
  id: SubnetId;
}

type SubnetId = {type:'SubnetId',value:string};

/**
 *  Provides a security group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/security_group.html
 */
export function createSecurityGroup(tfgen: TF.Generator, rname: string, params: SecurityGroupParams): SecurityGroup {
  const fields = fieldsFromSecurityGroupParams(params);
  const resource = tfgen.createTypedResource('SecurityGroup', 'aws_security_group', rname, fields);
  const id: SecurityGroupId =  {type: 'SecurityGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const owner_id: string =  '${' + TF.resourceName(resource) + '.owner_id}';

  return {
    ...resource,
    id,
    owner_id,
  };
}

export interface SecurityGroup extends TF.ResourceT<'SecurityGroup'> {
  id: SecurityGroupId;
  owner_id: string;
}

type SecurityGroupId = {type:'SecurityGroupId',value:string};

/**
 *  Provides a resource to create a VPC Internet Gateway.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/internet_gateway.html
 */
export function createInternetGateway(tfgen: TF.Generator, rname: string, params: InternetGatewayParams): InternetGateway {
  const fields = fieldsFromInternetGatewayParams(params);
  const resource = tfgen.createTypedResource('InternetGateway', 'aws_internet_gateway', rname, fields);
  const id: InternetGatewayId =  {type: 'InternetGatewayId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface InternetGateway extends TF.ResourceT<'InternetGateway'> {
  id: InternetGatewayId;
}

type InternetGatewayId = {type:'InternetGatewayId',value:string};

/**
 *  Provides a resource to create a VPC NAT Gateway.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/nat_gateway.html
 */
export function createNatGateway(tfgen: TF.Generator, rname: string, params: NatGatewayParams): NatGateway {
  const fields = fieldsFromNatGatewayParams(params);
  const resource = tfgen.createTypedResource('NatGateway', 'aws_nat_gateway', rname, fields);
  const id: NatGatewayId =  {type: 'NatGatewayId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface NatGateway extends TF.ResourceT<'NatGateway'> {
  id: NatGatewayId;
}

type NatGatewayId = {type:'NatGatewayId',value:string};

/**
 *  Provides a resource to create a VPC routing table.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route_table.html
 */
export function createRouteTable(tfgen: TF.Generator, rname: string, params: RouteTableParams): RouteTable {
  const fields = fieldsFromRouteTableParams(params);
  const resource = tfgen.createTypedResource('RouteTable', 'aws_route_table', rname, fields);
  const id: RouteTableId =  {type: 'RouteTableId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface RouteTable extends TF.ResourceT<'RouteTable'> {
  id: RouteTableId;
}

type RouteTableId = {type:'RouteTableId',value:string};

/**
 *  Provides a resource to create a routing table entry (a route) in a VPC routing table.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route.html
 */
export function createRoute(tfgen: TF.Generator, rname: string, params: RouteParams): Route {
  const fields = fieldsFromRouteParams(params);
  const resource = tfgen.createTypedResource('Route', 'aws_route', rname, fields);

  return {
    ...resource,
  };
}

export interface Route extends TF.ResourceT<'Route'> {
}

type RouteId = {type:'RouteId',value:string};

/**
 *  Provides a resource to create an association between a subnet and routing table.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route_table_association.html
 */
export function createRouteTableAssociation(tfgen: TF.Generator, rname: string, params: RouteTableAssociationParams): RouteTableAssociation {
  const fields = fieldsFromRouteTableAssociationParams(params);
  const resource = tfgen.createTypedResource('RouteTableAssociation', 'aws_route_table_association', rname, fields);
  const id: RouteTableAssociationId =  {type: 'RouteTableAssociationId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface RouteTableAssociation extends TF.ResourceT<'RouteTableAssociation'> {
  id: RouteTableAssociationId;
}

type RouteTableAssociationId = {type:'RouteTableAssociationId',value:string};

/**
 *  Provides a Route53 Hosted Zone resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route53_zone.html
 */
export function createRoute53Zone(tfgen: TF.Generator, rname: string, params: Route53ZoneParams): Route53Zone {
  const fields = fieldsFromRoute53ZoneParams(params);
  const resource = tfgen.createTypedResource('Route53Zone', 'aws_route53_zone', rname, fields);
  const zone_id: AT.HostedZoneId =  {type: 'HostedZoneId', value: '${' + TF.resourceName(resource) + '.zone_id}'};

  return {
    ...resource,
    zone_id,
  };
}

export interface Route53Zone extends TF.ResourceT<'Route53Zone'> {
  zone_id: AT.HostedZoneId;
}

type Route53ZoneId = {type:'Route53ZoneId',value:string};

/**
 *  Provides a Route53 record resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route53_record.htm
 */
export function createRoute53Record(tfgen: TF.Generator, rname: string, params: Route53RecordParams): Route53Record {
  const fields = fieldsFromRoute53RecordParams(params);
  const resource = tfgen.createTypedResource('Route53Record', 'aws_route53_record', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const fqdn: string =  '${' + TF.resourceName(resource) + '.fqdn}';

  return {
    ...resource,
    name,
    fqdn,
  };
}

export interface Route53Record extends TF.ResourceT<'Route53Record'> {
  name: string;
  fqdn: string;
}

type Route53RecordId = {type:'Route53RecordId',value:string};

/**
 *  Provides a S3 bucket resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/s3_bucket.html
 */
export function createS3Bucket(tfgen: TF.Generator, rname: string, params: S3BucketParams): S3Bucket {
  const fields = fieldsFromS3BucketParams(params);
  const resource = tfgen.createTypedResource('S3Bucket', 'aws_s3_bucket', rname, fields);
  const id: string =  '${' + TF.resourceName(resource) + '.id}';
  const arn: S3BucketArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'S3Bucket');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface S3Bucket extends TF.ResourceT<'S3Bucket'> {
  id: string;
  arn: S3BucketArn;
}

type S3BucketId = {type:'S3BucketId',value:string};
export type S3BucketArn = AT.ArnT<"S3Bucket">;

/**
 *  Provides a S3 bucket object resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/s3_bucket_object.html
 */
export function createS3BucketObject(tfgen: TF.Generator, rname: string, params: S3BucketObjectParams): S3BucketObject {
  const fields = fieldsFromS3BucketObjectParams(params);
  const resource = tfgen.createTypedResource('S3BucketObject', 'aws_s3_bucket_object', rname, fields);
  const id: string =  '${' + TF.resourceName(resource) + '.id}';
  const etag: string =  '${' + TF.resourceName(resource) + '.etag}';
  const version_id: string =  '${' + TF.resourceName(resource) + '.version_id}';

  return {
    ...resource,
    id,
    etag,
    version_id,
  };
}

export interface S3BucketObject extends TF.ResourceT<'S3BucketObject'> {
  id: string;
  etag: string;
  version_id: string;
}

type S3BucketObjectId = {type:'S3BucketObjectId',value:string};

/**
 *  Provides an SNS topic resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/sns_topic.html
 */
export function createSnsTopic(tfgen: TF.Generator, rname: string, params: SnsTopicParams): SnsTopic {
  const fields = fieldsFromSnsTopicParams(params);
  const resource = tfgen.createTypedResource('SnsTopic', 'aws_sns_topic', rname, fields);
  const id: SnsTopicId =  {type: 'SnsTopicId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: SnsTopicArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'SnsTopic');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface SnsTopic extends TF.ResourceT<'SnsTopic'> {
  id: SnsTopicId;
  arn: SnsTopicArn;
}

type SnsTopicId = {type:'SnsTopicId',value:string};
export type SnsTopicArn = AT.ArnT<"SnsTopic">;

/**
 *  Provides an IAM user.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_user.html
 */
export function createIamUser(tfgen: TF.Generator, rname: string, params: IamUserParams): IamUser {
  const fields = fieldsFromIamUserParams(params);
  const resource = tfgen.createTypedResource('IamUser', 'aws_iam_user', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const unique_id: string =  '${' + TF.resourceName(resource) + '.unique_id}';
  const arn: IamUserArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamUser');

  return {
    ...resource,
    name,
    unique_id,
    arn,
  };
}

export interface IamUser extends TF.ResourceT<'IamUser'> {
  name: string;
  unique_id: string;
  arn: IamUserArn;
}

type IamUserId = {type:'IamUserId',value:string};
export type IamUserArn = AT.ArnT<"IamUser">;

/**
 *  Provides an IAM policy attached to a user.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_user_policy.html
 */
export function createIamUserPolicy(tfgen: TF.Generator, rname: string, params: IamUserPolicyParams): IamUserPolicy {
  const fields = fieldsFromIamUserPolicyParams(params);
  const resource = tfgen.createTypedResource('IamUserPolicy', 'aws_iam_user_policy', rname, fields);

  return {
    ...resource,
  };
}

export interface IamUserPolicy extends TF.ResourceT<'IamUserPolicy'> {
}

type IamUserPolicyId = {type:'IamUserPolicyId',value:string};

/**
 *  Attaches a Managed IAM Policy to an IAM user
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_user_policy_attachment.html
 */
export function createIamUserPolicyAttachment(tfgen: TF.Generator, rname: string, params: IamUserPolicyAttachmentParams): IamUserPolicyAttachment {
  const fields = fieldsFromIamUserPolicyAttachmentParams(params);
  const resource = tfgen.createTypedResource('IamUserPolicyAttachment', 'aws_iam_user_policy_attachment', rname, fields);

  return {
    ...resource,
  };
}

export interface IamUserPolicyAttachment extends TF.ResourceT<'IamUserPolicyAttachment'> {
}

type IamUserPolicyAttachmentId = {type:'IamUserPolicyAttachmentId',value:string};

/**
 *  Provides an EC2 Container Registry Repository
 *
 *  see https://www.terraform.io/docs/providers/aws/r/ecr_repository.html
 */
export function createEcrRepository(tfgen: TF.Generator, rname: string, params: EcrRepositoryParams): EcrRepository {
  const fields = fieldsFromEcrRepositoryParams(params);
  const resource = tfgen.createTypedResource('EcrRepository', 'aws_ecr_repository', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const registry_id: string =  '${' + TF.resourceName(resource) + '.registry_id}';
  const repository_url: string =  '${' + TF.resourceName(resource) + '.repository_url}';
  const arn: EcrRepositoryArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'EcrRepository');

  return {
    ...resource,
    name,
    registry_id,
    repository_url,
    arn,
  };
}

export interface EcrRepository extends TF.ResourceT<'EcrRepository'> {
  name: string;
  registry_id: string;
  repository_url: string;
  arn: EcrRepositoryArn;
}

type EcrRepositoryId = {type:'EcrRepositoryId',value:string};
export type EcrRepositoryArn = AT.ArnT<"EcrRepository">;

/**
 *  Provides an RDS DB subnet group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/db_subnet_group.html
 */
export function createDbSubnetGroup(tfgen: TF.Generator, rname: string, params: DbSubnetGroupParams): DbSubnetGroup {
  const fields = fieldsFromDbSubnetGroupParams(params);
  const resource = tfgen.createTypedResource('DbSubnetGroup', 'aws_db_subnet_group', rname, fields);
  const id: DbSubnetGroupId =  {type: 'DbSubnetGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: DbSubnetGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'DbSubnetGroup');

  return {
    ...resource,
    id,
    name,
    arn,
  };
}

export interface DbSubnetGroup extends TF.ResourceT<'DbSubnetGroup'> {
  id: DbSubnetGroupId;
  name: string;
  arn: DbSubnetGroupArn;
}

type DbSubnetGroupId = {type:'DbSubnetGroupId',value:string};
export type DbSubnetGroupArn = AT.ArnT<"DbSubnetGroup">;

/**
 *  Provides a CloudWatch Metric Alarm resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudwatch_metric_alarm.html
 */
export function createCloudwatchMetricAlarm(tfgen: TF.Generator, rname: string, params: CloudwatchMetricAlarmParams): CloudwatchMetricAlarm {
  const fields = fieldsFromCloudwatchMetricAlarmParams(params);
  const resource = tfgen.createTypedResource('CloudwatchMetricAlarm', 'aws_cloudwatch_metric_alarm', rname, fields);
  const id: CloudwatchMetricAlarmId =  {type: 'CloudwatchMetricAlarmId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface CloudwatchMetricAlarm extends TF.ResourceT<'CloudwatchMetricAlarm'> {
  id: CloudwatchMetricAlarmId;
}

type CloudwatchMetricAlarmId = {type:'CloudwatchMetricAlarmId',value:string};

/**
 *  Provides an IAM role.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_role.html
 */
export function createIamRole(tfgen: TF.Generator, rname: string, params: IamRoleParams): IamRole {
  const fields = fieldsFromIamRoleParams(params);
  const resource = tfgen.createTypedResource('IamRole', 'aws_iam_role', rname, fields);
  const id: IamRoleId =  {type: 'IamRoleId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const create_date: string =  '${' + TF.resourceName(resource) + '.create_date}';
  const unique_id: string =  '${' + TF.resourceName(resource) + '.unique_id}';
  const description: string =  '${' + TF.resourceName(resource) + '.description}';
  const arn: IamRoleArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamRole');

  return {
    ...resource,
    id,
    name,
    create_date,
    unique_id,
    description,
    arn,
  };
}

export interface IamRole extends TF.ResourceT<'IamRole'> {
  id: IamRoleId;
  name: string;
  create_date: string;
  unique_id: string;
  description: string;
  arn: IamRoleArn;
}

type IamRoleId = {type:'IamRoleId',value:string};
export type IamRoleArn = AT.ArnT<"IamRole">;

/**
 *  Provides an IAM role policy
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_role_policy.html
 */
export function createIamRolePolicy(tfgen: TF.Generator, rname: string, params: IamRolePolicyParams): IamRolePolicy {
  const fields = fieldsFromIamRolePolicyParams(params);
  const resource = tfgen.createTypedResource('IamRolePolicy', 'aws_iam_role_policy', rname, fields);
  const id: string =  '${' + TF.resourceName(resource) + '.id}';
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const policy: string =  '${' + TF.resourceName(resource) + '.policy}';
  const role: string =  '${' + TF.resourceName(resource) + '.role}';

  return {
    ...resource,
    id,
    name,
    policy,
    role,
  };
}

export interface IamRolePolicy extends TF.ResourceT<'IamRolePolicy'> {
  id: string;
  name: string;
  policy: string;
  role: string;
}

type IamRolePolicyId = {type:'IamRolePolicyId',value:string};

/**
 *  Provides an IAM instance profile.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_instance_profile.html
 */
export function createIamInstanceProfile(tfgen: TF.Generator, rname: string, params: IamInstanceProfileParams): IamInstanceProfile {
  const fields = fieldsFromIamInstanceProfileParams(params);
  const resource = tfgen.createTypedResource('IamInstanceProfile', 'aws_iam_instance_profile', rname, fields);
  const id: IamInstanceProfileId =  {type: 'IamInstanceProfileId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const create_date: string =  '${' + TF.resourceName(resource) + '.create_date}';
  const unique_id: string =  '${' + TF.resourceName(resource) + '.unique_id}';
  const arn: IamInstanceProfileArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamInstanceProfile');

  return {
    ...resource,
    id,
    name,
    create_date,
    unique_id,
    arn,
  };
}

export interface IamInstanceProfile extends TF.ResourceT<'IamInstanceProfile'> {
  id: IamInstanceProfileId;
  name: string;
  create_date: string;
  unique_id: string;
  arn: IamInstanceProfileArn;
}

type IamInstanceProfileId = {type:'IamInstanceProfileId',value:string};
export type IamInstanceProfileArn = AT.ArnT<"IamInstanceProfile">;

/**
 *  Provides an SQS queue.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/sqs_queue.html
 */
export function createSqsQueue(tfgen: TF.Generator, rname: string, params: SqsQueueParams): SqsQueue {
  const fields = fieldsFromSqsQueueParams(params);
  const resource = tfgen.createTypedResource('SqsQueue', 'aws_sqs_queue', rname, fields);
  const id: SqsQueueId =  {type: 'SqsQueueId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: SqsQueueArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'SqsQueue');

  return {
    ...resource,
    id,
    name,
    arn,
  };
}

export interface SqsQueue extends TF.ResourceT<'SqsQueue'> {
  id: SqsQueueId;
  name: string;
  arn: SqsQueueArn;
}

type SqsQueueId = {type:'SqsQueueId',value:string};
export type SqsQueueArn = AT.ArnT<"SqsQueue">;

/**
 *  Allows you to set a policy of an SQS Queue while referencing ARN of the queue within the policy.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/sqs_queue_policy.html
 */
export function createSqsQueuePolicy(tfgen: TF.Generator, rname: string, params: SqsQueuePolicyParams): SqsQueuePolicy {
  const fields = fieldsFromSqsQueuePolicyParams(params);
  const resource = tfgen.createTypedResource('SqsQueuePolicy', 'aws_sqs_queue_policy', rname, fields);

  return {
    ...resource,
  };
}

export interface SqsQueuePolicy extends TF.ResourceT<'SqsQueuePolicy'> {
}

type SqsQueuePolicyId = {type:'SqsQueuePolicyId',value:string};

/**
 *  Provides a Load Balancer resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb.html
 */
export function createLb(tfgen: TF.Generator, rname: string, params: LbParams): Lb {
  const fields = fieldsFromLbParams(params);
  const resource = tfgen.createTypedResource('Lb', 'aws_lb', rname, fields);
  const id: LbId =  {type: 'LbId', value: '${' + TF.resourceName(resource) + '.id}'};
  const dns_name: string =  '${' + TF.resourceName(resource) + '.dns_name}';
  const zone_id: AT.HostedZoneId =  {type: 'HostedZoneId', value: '${' + TF.resourceName(resource) + '.zone_id}'};
  const arn: LbArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'Lb');

  return {
    ...resource,
    id,
    dns_name,
    zone_id,
    arn,
  };
}

export interface Lb extends TF.ResourceT<'Lb'> {
  id: LbId;
  dns_name: string;
  zone_id: AT.HostedZoneId;
  arn: LbArn;
}

type LbId = {type:'LbId',value:string};
export type LbArn = AT.ArnT<"Lb">;

/**
 *  Provides a Load Balancer Listener resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_listener.html
 */
export function createLbListener(tfgen: TF.Generator, rname: string, params: LbListenerParams): LbListener {
  const fields = fieldsFromLbListenerParams(params);
  const resource = tfgen.createTypedResource('LbListener', 'aws_lb_listener', rname, fields);
  const id: LbListenerId =  {type: 'LbListenerId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: LbListenerArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LbListener');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface LbListener extends TF.ResourceT<'LbListener'> {
  id: LbListenerId;
  arn: LbListenerArn;
}

type LbListenerId = {type:'LbListenerId',value:string};
export type LbListenerArn = AT.ArnT<"LbListener">;

/**
 *  The ACM certificate resource allows requesting and management of certificates from the Amazon Certificate Manager.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/acm_certificate.html
 */
export function createAcmCertificate(tfgen: TF.Generator, rname: string, params: AcmCertificateParams): AcmCertificate {
  const fields = fieldsFromAcmCertificateParams(params);
  const resource = tfgen.createTypedResource('AcmCertificate', 'aws_acm_certificate', rname, fields);
  const id: AcmCertificateId =  {type: 'AcmCertificateId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: AcmCertificateArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'AcmCertificate');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface AcmCertificate extends TF.ResourceT<'AcmCertificate'> {
  id: AcmCertificateId;
  arn: AcmCertificateArn;
}

type AcmCertificateId = {type:'AcmCertificateId',value:string};
export type AcmCertificateArn = AT.ArnT<"AcmCertificate">;

/**
 *  This resource represents a successful validation of an ACM certificate in concert with other resources.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/acm_certificate.html
 */
export function createAcmCertificateValidation(tfgen: TF.Generator, rname: string, params: AcmCertificateValidationParams): AcmCertificateValidation {
  const fields = fieldsFromAcmCertificateValidationParams(params);
  const resource = tfgen.createTypedResource('AcmCertificateValidation', 'aws_acm_certificate_validation', rname, fields);

  return {
    ...resource,
  };
}

export interface AcmCertificateValidation extends TF.ResourceT<'AcmCertificateValidation'> {
}

type AcmCertificateValidationId = {type:'AcmCertificateValidationId',value:string};

/**
 *  Provides a Load Balancer Listener Certificate resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_listener_certificate.html
 */
export function createLbListenerCertificate(tfgen: TF.Generator, rname: string, params: LbListenerCertificateParams): LbListenerCertificate {
  const fields = fieldsFromLbListenerCertificateParams(params);
  const resource = tfgen.createTypedResource('LbListenerCertificate', 'aws_lb_listener_certificate', rname, fields);
  const id: LbListenerCertificateId =  {type: 'LbListenerCertificateId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: LbListenerCertificateArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LbListenerCertificate');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface LbListenerCertificate extends TF.ResourceT<'LbListenerCertificate'> {
  id: LbListenerCertificateId;
  arn: LbListenerCertificateArn;
}

type LbListenerCertificateId = {type:'LbListenerCertificateId',value:string};
export type LbListenerCertificateArn = AT.ArnT<"LbListenerCertificate">;

/**
 *  Provides a Target Group resource for use with Load Balancer resources.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_target_group.html
 */
export function createLbTargetGroup(tfgen: TF.Generator, rname: string, params: LbTargetGroupParams): LbTargetGroup {
  const fields = fieldsFromLbTargetGroupParams(params);
  const resource = tfgen.createTypedResource('LbTargetGroup', 'aws_lb_target_group', rname, fields);
  const id: LbTargetGroupId =  {type: 'LbTargetGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn_suffix: string =  '${' + TF.resourceName(resource) + '.arn_suffix}';
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: LbTargetGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LbTargetGroup');

  return {
    ...resource,
    id,
    arn_suffix,
    name,
    arn,
  };
}

export interface LbTargetGroup extends TF.ResourceT<'LbTargetGroup'> {
  id: LbTargetGroupId;
  arn_suffix: string;
  name: string;
  arn: LbTargetGroupArn;
}

type LbTargetGroupId = {type:'LbTargetGroupId',value:string};
export type LbTargetGroupArn = AT.ArnT<"LbTargetGroup">;

/**
 *  Provides the ability to register instances and containers with an Application Load Balancer (ALB) or Network Load Balancer (NLB) target group. 
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_target_group_attachment.html
 */
export function createLbTargetGroupAttachment(tfgen: TF.Generator, rname: string, params: LbTargetGroupAttachmentParams): LbTargetGroupAttachment {
  const fields = fieldsFromLbTargetGroupAttachmentParams(params);
  const resource = tfgen.createTypedResource('LbTargetGroupAttachment', 'aws_lb_target_group_attachment', rname, fields);
  const id: LbTargetGroupAttachmentId =  {type: 'LbTargetGroupAttachmentId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface LbTargetGroupAttachment extends TF.ResourceT<'LbTargetGroupAttachment'> {
  id: LbTargetGroupAttachmentId;
}

type LbTargetGroupAttachmentId = {type:'LbTargetGroupAttachmentId',value:string};

/**
 *  Provides a Load Balancer Listener Rule resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_listener_rule.html
 */
export function createLbListenerRule(tfgen: TF.Generator, rname: string, params: LbListenerRuleParams): LbListenerRule {
  const fields = fieldsFromLbListenerRuleParams(params);
  const resource = tfgen.createTypedResource('LbListenerRule', 'aws_lb_listener_rule', rname, fields);
  const id: LbListenerRuleId =  {type: 'LbListenerRuleId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};

  return {
    ...resource,
    id,
    arn,
  };
}

export interface LbListenerRule extends TF.ResourceT<'LbListenerRule'> {
  id: LbListenerRuleId;
  arn: AT.Arn;
}

type LbListenerRuleId = {type:'LbListenerRuleId',value:string};

/**
 *  Provides an elasticsearch cluster
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticsearch_domain.html
 */
export function createElasticsearchDomain(tfgen: TF.Generator, rname: string, params: ElasticsearchDomainParams): ElasticsearchDomain {
  const fields = fieldsFromElasticsearchDomainParams(params);
  const resource = tfgen.createTypedResource('ElasticsearchDomain', 'aws_elasticsearch_domain', rname, fields);
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};
  const domain_id: string =  '${' + TF.resourceName(resource) + '.domain_id}';
  const domain_name: string =  '${' + TF.resourceName(resource) + '.domain_name}';
  const endpoint: string =  '${' + TF.resourceName(resource) + '.endpoint}';

  return {
    ...resource,
    arn,
    domain_id,
    domain_name,
    endpoint,
  };
}

export interface ElasticsearchDomain extends TF.ResourceT<'ElasticsearchDomain'> {
  arn: AT.Arn;
  domain_id: string;
  domain_name: string;
  endpoint: string;
}

type ElasticsearchDomainId = {type:'ElasticsearchDomainId',value:string};

/**
 *  Allows setting policy to an Elasticsearch domain while referencing domain attributes (e.g. ARN)
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticsearch_domain_policy.html
 */
export function createElasticsearchDomainPolicy(tfgen: TF.Generator, rname: string, params: ElasticsearchDomainPolicyParams): ElasticsearchDomainPolicy {
  const fields = fieldsFromElasticsearchDomainPolicyParams(params);
  const resource = tfgen.createTypedResource('ElasticsearchDomainPolicy', 'aws_elasticsearch_domain_policy', rname, fields);
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};

  return {
    ...resource,
    arn,
  };
}

export interface ElasticsearchDomainPolicy extends TF.ResourceT<'ElasticsearchDomainPolicy'> {
  arn: AT.Arn;
}

type ElasticsearchDomainPolicyId = {type:'ElasticsearchDomainPolicyId',value:string};

/**
 *  Provides a CloudWatch Log Group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudwatch_log_group.html
 */
export function createCloudwatchLogGroup(tfgen: TF.Generator, rname: string, params: CloudwatchLogGroupParams): CloudwatchLogGroup {
  const fields = fieldsFromCloudwatchLogGroupParams(params);
  const resource = tfgen.createTypedResource('CloudwatchLogGroup', 'aws_cloudwatch_log_group', rname, fields);
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};

  return {
    ...resource,
    arn,
  };
}

export interface CloudwatchLogGroup extends TF.ResourceT<'CloudwatchLogGroup'> {
  arn: AT.Arn;
}

type CloudwatchLogGroupId = {type:'CloudwatchLogGroupId',value:string};

/**
 *  Provides aws_launch_configuration
 *
 *  see https://www.terraform.io/docs/providers/aws/r/launch_configuration.html
 */
export function createLaunchConfiguration(tfgen: TF.Generator, rname: string, params: LaunchConfigurationParams): LaunchConfiguration {
  const fields = fieldsFromLaunchConfigurationParams(params);
  const resource = tfgen.createTypedResource('LaunchConfiguration', 'aws_launch_configuration', rname, fields);
  const id: LaunchConfigurationId =  {type: 'LaunchConfigurationId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';

  return {
    ...resource,
    id,
    name,
  };
}

export interface LaunchConfiguration extends TF.ResourceT<'LaunchConfiguration'> {
  id: LaunchConfigurationId;
  name: string;
}

type LaunchConfigurationId = {type:'LaunchConfigurationId',value:string};

/**
 *  Provides a Kinesis Firehose Delivery Stream resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/kinesis_firehose_delivery_stream.html
 */
export function createKinesisFirehoseDeliveryStream(tfgen: TF.Generator, rname: string, params: KinesisFirehoseDeliveryStreamParams): KinesisFirehoseDeliveryStream {
  const fields = fieldsFromKinesisFirehoseDeliveryStreamParams(params);
  const resource = tfgen.createTypedResource('KinesisFirehoseDeliveryStream', 'aws_kinesis_firehose_delivery_stream', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: KinesisFirehoseDeliveryStreamArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'KinesisFirehoseDeliveryStream');

  return {
    ...resource,
    name,
    arn,
  };
}

export interface KinesisFirehoseDeliveryStream extends TF.ResourceT<'KinesisFirehoseDeliveryStream'> {
  name: string;
  arn: KinesisFirehoseDeliveryStreamArn;
}

type KinesisFirehoseDeliveryStreamId = {type:'KinesisFirehoseDeliveryStreamId',value:string};
export type KinesisFirehoseDeliveryStreamArn = AT.ArnT<"KinesisFirehoseDeliveryStream">;

/**
 *  Provides a S3 bucket metrics configuration resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/s3_bucket_metric.html
 */
export function createS3BucketMetric(tfgen: TF.Generator, rname: string, params: S3BucketMetricParams): S3BucketMetric {
  const fields = fieldsFromS3BucketMetricParams(params);
  const resource = tfgen.createTypedResource('S3BucketMetric', 'aws_s3_bucket_metric', rname, fields);

  return {
    ...resource,
  };
}

export interface S3BucketMetric extends TF.ResourceT<'S3BucketMetric'> {
}

type S3BucketMetricId = {type:'S3BucketMetricId',value:string};

/**
 *  Provides an ElastiCache parameter group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticache_parameter_group.html
 */
export function createElasticacheParameterGroup(tfgen: TF.Generator, rname: string, params: ElasticacheParameterGroupParams): ElasticacheParameterGroup {
  const fields = fieldsFromElasticacheParameterGroupParams(params);
  const resource = tfgen.createTypedResource('ElasticacheParameterGroup', 'aws_elasticache_parameter_group', rname, fields);
  const name: AT.ElasticacheParameterGroupName =  {type: 'ElasticacheParameterGroupName', value: '${' + TF.resourceName(resource) + '.name}'};
  const family: AT.ElasticacheParameterGroupFamily =  {type: 'ElasticacheParameterGroupFamily', value: '${' + TF.resourceName(resource) + '.family}'};
  const description: string =  '${' + TF.resourceName(resource) + '.description}';
  const arn: ElasticacheParameterGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'ElasticacheParameterGroup');

  return {
    ...resource,
    name,
    family,
    description,
    arn,
  };
}

export interface ElasticacheParameterGroup extends TF.ResourceT<'ElasticacheParameterGroup'> {
  name: AT.ElasticacheParameterGroupName;
  family: AT.ElasticacheParameterGroupFamily;
  description: string;
  arn: ElasticacheParameterGroupArn;
}

type ElasticacheParameterGroupId = {type:'ElasticacheParameterGroupId',value:string};
export type ElasticacheParameterGroupArn = AT.ArnT<"ElasticacheParameterGroup">;

/**
 *  Provides an ElastiCache Subnet Group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticache_subnet_group.html
 */
export function createElasticacheSubnetGroup(tfgen: TF.Generator, rname: string, params: ElasticacheSubnetGroupParams): ElasticacheSubnetGroup {
  const fields = fieldsFromElasticacheSubnetGroupParams(params);
  const resource = tfgen.createTypedResource('ElasticacheSubnetGroup', 'aws_elasticache_subnet_group', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';

  return {
    ...resource,
    name,
  };
}

export interface ElasticacheSubnetGroup extends TF.ResourceT<'ElasticacheSubnetGroup'> {
  name: string;
}

type ElasticacheSubnetGroupId = {type:'ElasticacheSubnetGroupId',value:string};

/**
 *  Provides an elasticache cluster resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticache_cluster.html
 */
export function createElasticacheCluster(tfgen: TF.Generator, rname: string, params: ElasticacheClusterParams): ElasticacheCluster {
  const fields = fieldsFromElasticacheClusterParams(params);
  const resource = tfgen.createTypedResource('ElasticacheCluster', 'aws_elasticache_cluster', rname, fields);
  const cluster_id: string =  '${' + TF.resourceName(resource) + '.cluster_id}';
  const engine: string =  '${' + TF.resourceName(resource) + '.engine}';
  const node_type: string =  '${' + TF.resourceName(resource) + '.node_type}';
  const parameter_group_name: AT.ElasticacheParameterGroupName =  {type: 'ElasticacheParameterGroupName', value: '${' + TF.resourceName(resource) + '.parameter_group_name}'};
  const configuration_endpoint: string =  '${' + TF.resourceName(resource) + '.configuration_endpoint}';
  const cluster_address: string =  '${' + TF.resourceName(resource) + '.cluster_address}';
  const arn: ElasticacheClusterArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'ElasticacheCluster');

  return {
    ...resource,
    cluster_id,
    engine,
    node_type,
    parameter_group_name,
    configuration_endpoint,
    cluster_address,
    arn,
  };
}

export interface ElasticacheCluster extends TF.ResourceT<'ElasticacheCluster'> {
  cluster_id: string;
  engine: string;
  node_type: string;
  parameter_group_name: AT.ElasticacheParameterGroupName;
  configuration_endpoint: string;
  cluster_address: string;
  arn: ElasticacheClusterArn;
}

type ElasticacheClusterId = {type:'ElasticacheClusterId',value:string};
export type ElasticacheClusterArn = AT.ArnT<"ElasticacheCluster">;

/**
 *  Provides information about a Lambda Function.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/lambda_function.html
 */
export function createLambdaFunction(tfgen: TF.Generator, rname: string, params: LambdaFunctionParams): LambdaFunction {
  const fields = fieldsFromLambdaFunctionParams(params);
  const resource = tfgen.createTypedResource('LambdaFunction', 'aws_lambda_function', rname, fields);
  const function_name: string =  '${' + TF.resourceName(resource) + '.function_name}';
  const role: IamRoleId =  {type: 'IamRoleId', value: '${' + TF.resourceName(resource) + '.role}'};
  const arn: LambdaFunctionArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LambdaFunction');

  return {
    ...resource,
    function_name,
    role,
    arn,
  };
}

export interface LambdaFunction extends TF.ResourceT<'LambdaFunction'> {
  function_name: string;
  role: IamRoleId;
  arn: LambdaFunctionArn;
}

type LambdaFunctionId = {type:'LambdaFunctionId',value:string};
export type LambdaFunctionArn = AT.ArnT<"LambdaFunction">;

/**
 *  Creates a Lambda permission to allow external sources invoking the Lambda function
    (e.g. CloudWatch Event Rule, SNS or S3).
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lambda_permission.html
 */
export function createLambdaPermission(tfgen: TF.Generator, rname: string, params: LambdaPermissionParams): LambdaPermission {
  const fields = fieldsFromLambdaPermissionParams(params);
  const resource = tfgen.createTypedResource('LambdaPermission', 'aws_lambda_permission', rname, fields);
  const action: AT.LambdaPermissionAction =  {type: 'LambdaPermissionAction', value: '${' + TF.resourceName(resource) + '.action}'};
  const function_name: string =  '${' + TF.resourceName(resource) + '.function_name}';
  const principal: string =  '${' + TF.resourceName(resource) + '.principal}';
  const arn: LambdaPermissionArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LambdaPermission');

  return {
    ...resource,
    action,
    function_name,
    principal,
    arn,
  };
}

export interface LambdaPermission extends TF.ResourceT<'LambdaPermission'> {
  action: AT.LambdaPermissionAction;
  function_name: string;
  principal: string;
  arn: LambdaPermissionArn;
}

type LambdaPermissionId = {type:'LambdaPermissionId',value:string};
export type LambdaPermissionArn = AT.ArnT<"LambdaPermission">;

/**
 *  Provides a CloudWatch Event Rule resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudwatch_event_rule.html
 */
export function createCloudwatchEventRule(tfgen: TF.Generator, rname: string, params: CloudwatchEventRuleParams): CloudwatchEventRule {
  const fields = fieldsFromCloudwatchEventRuleParams(params);
  const resource = tfgen.createTypedResource('CloudwatchEventRule', 'aws_cloudwatch_event_rule', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const schedule_expression: string =  '${' + TF.resourceName(resource) + '.schedule_expression}';
  const description: string =  '${' + TF.resourceName(resource) + '.description}';
  const arn: CloudwatchEventRuleArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'CloudwatchEventRule');

  return {
    ...resource,
    name,
    schedule_expression,
    description,
    arn,
  };
}

export interface CloudwatchEventRule extends TF.ResourceT<'CloudwatchEventRule'> {
  name: string;
  schedule_expression: string;
  description: string;
  arn: CloudwatchEventRuleArn;
}

type CloudwatchEventRuleId = {type:'CloudwatchEventRuleId',value:string};
export type CloudwatchEventRuleArn = AT.ArnT<"CloudwatchEventRule">;

/**
 *  Provides a CloudWatch Event Target resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudwatch_event_target.html
 */
export function createCloudwatchEventTarget(tfgen: TF.Generator, rname: string, params: CloudwatchEventTargetParams): CloudwatchEventTarget {
  const fields = fieldsFromCloudwatchEventTargetParams(params);
  const resource = tfgen.createTypedResource('CloudwatchEventTarget', 'aws_cloudwatch_event_target', rname, fields);
  const arn: CloudwatchEventTargetArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'CloudwatchEventTarget');

  return {
    ...resource,
    arn,
  };
}

export interface CloudwatchEventTarget extends TF.ResourceT<'CloudwatchEventTarget'> {
  arn: CloudwatchEventTargetArn;
}

type CloudwatchEventTargetId = {type:'CloudwatchEventTargetId',value:string};
export type CloudwatchEventTargetArn = AT.ArnT<"CloudwatchEventTarget">;

/**
 *  Provides a WAF Byte Match Set Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/waf_byte_match_set.html
 */
export function createWafByteMatchSet(tfgen: TF.Generator, rname: string, params: WafByteMatchSetParams): WafByteMatchSet {
  const fields = fieldsFromWafByteMatchSetParams(params);
  const resource = tfgen.createTypedResource('WafByteMatchSet', 'aws_waf_byte_match_set', rname, fields);
  const id: WafByteMatchSetId =  {type: 'WafByteMatchSetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafByteMatchSet extends TF.ResourceT<'WafByteMatchSet'> {
  id: WafByteMatchSetId;
}

type WafByteMatchSetId = {type:'WafByteMatchSetId',value:string};

/**
 *  Provides a WAF IPSet Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/waf_ipset.html
 */
export function createWafIpset(tfgen: TF.Generator, rname: string, params: WafIpsetParams): WafIpset {
  const fields = fieldsFromWafIpsetParams(params);
  const resource = tfgen.createTypedResource('WafIpset', 'aws_waf_ipset', rname, fields);
  const id: WafIpsetId =  {type: 'WafIpsetId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: WafIpsetArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'WafIpset');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface WafIpset extends TF.ResourceT<'WafIpset'> {
  id: WafIpsetId;
  arn: WafIpsetArn;
}

type WafIpsetId = {type:'WafIpsetId',value:string};
export type WafIpsetArn = AT.ArnT<"WafIpset">;

/**
 *  Provides a WAF Regional Regex Match Set Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_regex_match_set.html
 */
export function createWafregionalRegexMatchSet(tfgen: TF.Generator, rname: string, params: WafregionalRegexMatchSetParams): WafregionalRegexMatchSet {
  const fields = fieldsFromWafregionalRegexMatchSetParams(params);
  const resource = tfgen.createTypedResource('WafregionalRegexMatchSet', 'aws_wafregional_regex_match_set', rname, fields);
  const id: WafregionalRegexMatchSetId =  {type: 'WafregionalRegexMatchSetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalRegexMatchSet extends TF.ResourceT<'WafregionalRegexMatchSet'> {
  id: WafregionalRegexMatchSetId;
}

type WafregionalRegexMatchSetId = {type:'WafregionalRegexMatchSetId',value:string};

/**
 *  Provides a WAF Regional Regex Pattern Set Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_regex_pattern_set.html
 */
export function createWafregionalRegexPatternSet(tfgen: TF.Generator, rname: string, params: WafregionalRegexPatternSetParams): WafregionalRegexPatternSet {
  const fields = fieldsFromWafregionalRegexPatternSetParams(params);
  const resource = tfgen.createTypedResource('WafregionalRegexPatternSet', 'aws_wafregional_regex_pattern_set', rname, fields);
  const id: WafregionalRegexPatternSetId =  {type: 'WafregionalRegexPatternSetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalRegexPatternSet extends TF.ResourceT<'WafregionalRegexPatternSet'> {
  id: WafregionalRegexPatternSetId;
}

type WafregionalRegexPatternSetId = {type:'WafregionalRegexPatternSetId',value:string};

/**
 *  Provides a WAF Regional IPSet Resource for use with Application Load Balancer.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_ipset.html
 */
export function createWafregionalIpset(tfgen: TF.Generator, rname: string, params: WafregionalIpsetParams): WafregionalIpset {
  const fields = fieldsFromWafregionalIpsetParams(params);
  const resource = tfgen.createTypedResource('WafregionalIpset', 'aws_wafregional_ipset', rname, fields);
  const id: WafregionalIpsetId =  {type: 'WafregionalIpsetId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: WafregionalIpsetArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'WafregionalIpset');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface WafregionalIpset extends TF.ResourceT<'WafregionalIpset'> {
  id: WafregionalIpsetId;
  arn: WafregionalIpsetArn;
}

type WafregionalIpsetId = {type:'WafregionalIpsetId',value:string};
export type WafregionalIpsetArn = AT.ArnT<"WafregionalIpset">;

/**
 *  Provides an WAF Regional Rule Resource for use with Application Load Balancer.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_rule.html
 */
export function createWafregionalRule(tfgen: TF.Generator, rname: string, params: WafregionalRuleParams): WafregionalRule {
  const fields = fieldsFromWafregionalRuleParams(params);
  const resource = tfgen.createTypedResource('WafregionalRule', 'aws_wafregional_rule', rname, fields);
  const id: WafregionalRuleId =  {type: 'WafregionalRuleId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalRule extends TF.ResourceT<'WafregionalRule'> {
  id: WafregionalRuleId;
}

type WafregionalRuleId = {type:'WafregionalRuleId',value:string};

/**
 *  Provides a WAF Regional Web ACL Resource for use with Application Load Balancer.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_web_acl.html
 */
export function createWafregionalWebAcl(tfgen: TF.Generator, rname: string, params: WafregionalWebAclParams): WafregionalWebAcl {
  const fields = fieldsFromWafregionalWebAclParams(params);
  const resource = tfgen.createTypedResource('WafregionalWebAcl', 'aws_wafregional_web_acl', rname, fields);
  const id: WafregionalWebAclId =  {type: 'WafregionalWebAclId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalWebAcl extends TF.ResourceT<'WafregionalWebAcl'> {
  id: WafregionalWebAclId;
}

type WafregionalWebAclId = {type:'WafregionalWebAclId',value:string};

/**
 *  Provides a resource to create an association between a WAF Regional WebACL and Application Load Balancer.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_web_acl_association.html
 */
export function createWafregionalWebAclAssociation(tfgen: TF.Generator, rname: string, params: WafregionalWebAclAssociationParams): WafregionalWebAclAssociation {
  const fields = fieldsFromWafregionalWebAclAssociationParams(params);
  const resource = tfgen.createTypedResource('WafregionalWebAclAssociation', 'aws_wafregional_web_acl_association', rname, fields);
  const id: WafregionalWebAclAssociationId =  {type: 'WafregionalWebAclAssociationId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalWebAclAssociation extends TF.ResourceT<'WafregionalWebAclAssociation'> {
  id: WafregionalWebAclAssociationId;
}

type WafregionalWebAclAssociationId = {type:'WafregionalWebAclAssociationId',value:string};

/**
 *  Provides a resource to manage AWS Secrets Manager secret metadata.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/secretsmanager_secret.html
 */
export function createSecretsmanagerSecret(tfgen: TF.Generator, rname: string, params: SecretsmanagerSecretParams): SecretsmanagerSecret {
  const fields = fieldsFromSecretsmanagerSecretParams(params);
  const resource = tfgen.createTypedResource('SecretsmanagerSecret', 'aws_secretsmanager_secret', rname, fields);
  const id: SecretsmanagerSecretId =  {type: 'SecretsmanagerSecretId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: SecretsmanagerSecretArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'SecretsmanagerSecret');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface SecretsmanagerSecret extends TF.ResourceT<'SecretsmanagerSecret'> {
  id: SecretsmanagerSecretId;
  arn: SecretsmanagerSecretArn;
}

type SecretsmanagerSecretId = {type:'SecretsmanagerSecretId',value:string};
export type SecretsmanagerSecretArn = AT.ArnT<"SecretsmanagerSecret">;

/**
 *  Provides a resource to manage AWS Secrets Manager secret version including its secret value.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/secretsmanager_secret_version.html
 */
export function createSecretsmanagerSecretVersion(tfgen: TF.Generator, rname: string, params: SecretsmanagerSecretVersionParams): SecretsmanagerSecretVersion {
  const fields = fieldsFromSecretsmanagerSecretVersionParams(params);
  const resource = tfgen.createTypedResource('SecretsmanagerSecretVersion', 'aws_secretsmanager_secret_version', rname, fields);
  const id: SecretsmanagerSecretId =  {type: 'SecretsmanagerSecretId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: SecretsmanagerSecretVersionArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'SecretsmanagerSecretVersion');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface SecretsmanagerSecretVersion extends TF.ResourceT<'SecretsmanagerSecretVersion'> {
  id: SecretsmanagerSecretId;
  arn: SecretsmanagerSecretVersionArn;
}

type SecretsmanagerSecretVersionId = {type:'SecretsmanagerSecretVersionId',value:string};
export type SecretsmanagerSecretVersionArn = AT.ArnT<"SecretsmanagerSecretVersion">;

/**
 *  Creates an Amazon CloudFront web distribution.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudfront_distribution.html
 */
export function createCloudfrontDistribution(tfgen: TF.Generator, rname: string, params: CloudfrontDistributionParams): CloudfrontDistribution {
  const fields = fieldsFromCloudfrontDistributionParams(params);
  const resource = tfgen.createTypedResource('CloudfrontDistribution', 'aws_cloudfront_distribution', rname, fields);
  const id: CloudfrontDistributionId =  {type: 'CloudfrontDistributionId', value: '${' + TF.resourceName(resource) + '.id}'};
  const domain_name: string =  '${' + TF.resourceName(resource) + '.domain_name}';
  const hosted_zone_id: AT.HostedZoneId =  {type: 'HostedZoneId', value: '${' + TF.resourceName(resource) + '.hosted_zone_id}'};
  const arn: CloudfrontDistributionArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'CloudfrontDistribution');

  return {
    ...resource,
    id,
    domain_name,
    hosted_zone_id,
    arn,
  };
}

export interface CloudfrontDistribution extends TF.ResourceT<'CloudfrontDistribution'> {
  id: CloudfrontDistributionId;
  domain_name: string;
  hosted_zone_id: AT.HostedZoneId;
  arn: CloudfrontDistributionArn;
}

type CloudfrontDistributionId = {type:'CloudfrontDistributionId',value:string};
export type CloudfrontDistributionArn = AT.ArnT<"CloudfrontDistribution">;

/**
 *  Provides an API Gateway REST API.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_rest_api.html
 */
export function createApiGatewayRestApi(tfgen: TF.Generator, rname: string, params: ApiGatewayRestApiParams): ApiGatewayRestApi {
  const fields = fieldsFromApiGatewayRestApiParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayRestApi', 'aws_api_gateway_rest_api', rname, fields);
  const id: ApiGatewayRestApiId =  {type: 'ApiGatewayRestApiId', value: '${' + TF.resourceName(resource) + '.id}'};
  const root_resource_id: ApiGatewayRestApiId =  {type: 'ApiGatewayRestApiId', value: '${' + TF.resourceName(resource) + '.root_resource_id}'};

  return {
    ...resource,
    id,
    root_resource_id,
  };
}

export interface ApiGatewayRestApi extends TF.ResourceT<'ApiGatewayRestApi'> {
  id: ApiGatewayRestApiId;
  root_resource_id: ApiGatewayRestApiId;
}

type ApiGatewayRestApiId = {type:'ApiGatewayRestApiId',value:string};

/**
 *  Provides an API Gateway Resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_resource.html
 */
export function createApiGatewayResource(tfgen: TF.Generator, rname: string, params: ApiGatewayResourceParams): ApiGatewayResource {
  const fields = fieldsFromApiGatewayResourceParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayResource', 'aws_api_gateway_resource', rname, fields);
  const id: ApiGatewayResourceId =  {type: 'ApiGatewayResourceId', value: '${' + TF.resourceName(resource) + '.id}'};
  const path: string =  '${' + TF.resourceName(resource) + '.path}';

  return {
    ...resource,
    id,
    path,
  };
}

export interface ApiGatewayResource extends TF.ResourceT<'ApiGatewayResource'> {
  id: ApiGatewayResourceId;
  path: string;
}

type ApiGatewayResourceId = {type:'ApiGatewayResourceId',value:string};

/**
 *  Provides a HTTP Method for an API Gateway Resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_method.html
 */
export function createApiGatewayMethod(tfgen: TF.Generator, rname: string, params: ApiGatewayMethodParams): ApiGatewayMethod {
  const fields = fieldsFromApiGatewayMethodParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayMethod', 'aws_api_gateway_method', rname, fields);

  return {
    ...resource,
  };
}

export interface ApiGatewayMethod extends TF.ResourceT<'ApiGatewayMethod'> {
}

type ApiGatewayMethodId = {type:'ApiGatewayMethodId',value:string};

/**
 *  Provides an HTTP Method Response for an API Gateway Resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_method_response.html
 */
export function createApiGatewayMethodResponse(tfgen: TF.Generator, rname: string, params: ApiGatewayMethodResponseParams): ApiGatewayMethodResponse {
  const fields = fieldsFromApiGatewayMethodResponseParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayMethodResponse', 'aws_api_gateway_method_response', rname, fields);

  return {
    ...resource,
  };
}

export interface ApiGatewayMethodResponse extends TF.ResourceT<'ApiGatewayMethodResponse'> {
}

type ApiGatewayMethodResponseId = {type:'ApiGatewayMethodResponseId',value:string};

/**
 *  Provides an HTTP Method Integration for an API Gateway Integration.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_integration.html
 */
export function createApiGatewayIntegration(tfgen: TF.Generator, rname: string, params: ApiGatewayIntegrationParams): ApiGatewayIntegration {
  const fields = fieldsFromApiGatewayIntegrationParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayIntegration', 'aws_api_gateway_integration', rname, fields);

  return {
    ...resource,
  };
}

export interface ApiGatewayIntegration extends TF.ResourceT<'ApiGatewayIntegration'> {
}

type ApiGatewayIntegrationId = {type:'ApiGatewayIntegrationId',value:string};

/**
 *  Provides an HTTP Method Integration Response for an API Gateway Resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_integration_response.html
 */
export function createApiGatewayIntegrationResponse(tfgen: TF.Generator, rname: string, params: ApiGatewayIntegrationResponseParams): ApiGatewayIntegrationResponse {
  const fields = fieldsFromApiGatewayIntegrationResponseParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayIntegrationResponse', 'aws_api_gateway_integration_response', rname, fields);

  return {
    ...resource,
  };
}

export interface ApiGatewayIntegrationResponse extends TF.ResourceT<'ApiGatewayIntegrationResponse'> {
}

type ApiGatewayIntegrationResponseId = {type:'ApiGatewayIntegrationResponseId',value:string};

/**
 *  Provides an API Gateway Deployment.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_deployment.html
 */
export function createApiGatewayDeployment(tfgen: TF.Generator, rname: string, params: ApiGatewayDeploymentParams): ApiGatewayDeployment {
  const fields = fieldsFromApiGatewayDeploymentParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayDeployment', 'aws_api_gateway_deployment', rname, fields);
  const id: ApiGatewayDeploymentId =  {type: 'ApiGatewayDeploymentId', value: '${' + TF.resourceName(resource) + '.id}'};
  const invoke_url: string =  '${' + TF.resourceName(resource) + '.invoke_url}';
  const execution_arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.execution_arn}'};

  return {
    ...resource,
    id,
    invoke_url,
    execution_arn,
  };
}

export interface ApiGatewayDeployment extends TF.ResourceT<'ApiGatewayDeployment'> {
  id: ApiGatewayDeploymentId;
  invoke_url: string;
  execution_arn: AT.Arn;
}

type ApiGatewayDeploymentId = {type:'ApiGatewayDeploymentId',value:string};

/**
 *  Registers a custom domain name for use with AWS API Gateway.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_domain_name.html
 */
export function createApiGatewayDomainName(tfgen: TF.Generator, rname: string, params: ApiGatewayDomainNameParams): ApiGatewayDomainName {
  const fields = fieldsFromApiGatewayDomainNameParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayDomainName', 'aws_api_gateway_domain_name', rname, fields);
  const id: ApiGatewayDomainNameId =  {type: 'ApiGatewayDomainNameId', value: '${' + TF.resourceName(resource) + '.id}'};
  const cloudfront_domain_name: string =  '${' + TF.resourceName(resource) + '.cloudfront_domain_name}';
  const cloudfront_zone_id: AT.HostedZoneId =  {type: 'HostedZoneId', value: '${' + TF.resourceName(resource) + '.cloudfront_zone_id}'};

  return {
    ...resource,
    id,
    cloudfront_domain_name,
    cloudfront_zone_id,
  };
}

export interface ApiGatewayDomainName extends TF.ResourceT<'ApiGatewayDomainName'> {
  id: ApiGatewayDomainNameId;
  cloudfront_domain_name: string;
  cloudfront_zone_id: AT.HostedZoneId;
}

type ApiGatewayDomainNameId = {type:'ApiGatewayDomainNameId',value:string};

/**
 *  Connects a custom domain name registered via aws_api_gateway_domain_name with a deployed API
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_base_path_mapping.html
 */
export function createApiGatewayBasePathMapping(tfgen: TF.Generator, rname: string, params: ApiGatewayBasePathMappingParams): ApiGatewayBasePathMapping {
  const fields = fieldsFromApiGatewayBasePathMappingParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayBasePathMapping', 'aws_api_gateway_base_path_mapping', rname, fields);

  return {
    ...resource,
  };
}

export interface ApiGatewayBasePathMapping extends TF.ResourceT<'ApiGatewayBasePathMapping'> {
}

type ApiGatewayBasePathMappingId = {type:'ApiGatewayBasePathMappingId',value:string};

export interface AutoscalingGroupTagParams {
  key: string;
  value: string;
  propagate_at_launch: boolean;
}

export function fieldsFromAutoscalingGroupTagParams(params: AutoscalingGroupTagParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "key", params.key, TF.stringValue);
  TF.addField(fields, "value", params.value, TF.stringValue);
  TF.addField(fields, "propagate_at_launch", params.propagate_at_launch, TF.booleanValue);
  return fields;
}

export interface AutoscalingGroupParams {
  name?: string;
  name_prefix?: string;
  min_size: number;
  max_size: number;
  vpc_zone_identifier?: (SubnetId)[];
  launch_configuration: string;
  load_balancers?: (string)[];
  tags?: (AutoscalingGroupTagParams)[];
}

export function fieldsFromAutoscalingGroupParams(params: AutoscalingGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "min_size", params.min_size, TF.numberValue);
  TF.addField(fields, "max_size", params.max_size, TF.numberValue);
  TF.addOptionalField(fields, "vpc_zone_identifier", params.vpc_zone_identifier, TF.listValue(TF.resourceIdValue));
  TF.addField(fields, "launch_configuration", params.launch_configuration, TF.stringValue);
  TF.addOptionalField(fields, "load_balancers", params.load_balancers, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.listValue((v) => TF.mapValue(fieldsFromAutoscalingGroupTagParams(v))));
  return fields;
}

export interface AutoscalingAttachmentParams {
  autoscaling_group_name: AutoscalingGroupId;
  alb_target_group_arn: AT.ArnT<"LbTargetGroup">;
}

export function fieldsFromAutoscalingAttachmentParams(params: AutoscalingAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "autoscaling_group_name", params.autoscaling_group_name, TF.resourceIdValue);
  TF.addField(fields, "alb_target_group_arn", params.alb_target_group_arn, TF.resourceArnValue);
  return fields;
}

export interface InstanceRootBlockDeviceParams {
  volume_type?: 'standard' | 'gp2' | 'io1';
  volume_size?: number;
  iops?: number;
  delete_on_termination?: boolean;
}

export function fieldsFromInstanceRootBlockDeviceParams(params: InstanceRootBlockDeviceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "volume_type", params.volume_type, TF.stringValue);
  TF.addOptionalField(fields, "volume_size", params.volume_size, TF.numberValue);
  TF.addOptionalField(fields, "iops", params.iops, TF.numberValue);
  TF.addOptionalField(fields, "delete_on_termination", params.delete_on_termination, TF.booleanValue);
  return fields;
}

export interface InstanceParams {
  ami: AT.Ami;
  instance_type: AT.InstanceType;
  availability_zone?: AT.AvailabilityZone;
  ebs_optimised?: boolean;
  key_name?: AT.KeyName;
  monitoring?: boolean;
  subnet_id?: SubnetId;
  associate_public_ip_address?: boolean;
  root_block_device?: InstanceRootBlockDeviceParams;
  user_data?: string;
  iam_instance_profile?: IamInstanceProfileId;
  vpc_security_group_ids?: (SecurityGroupId)[];
  tags?: TF.TagsMap;
}

export function fieldsFromInstanceParams(params: InstanceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "ami", params.ami, TF.stringAliasValue);
  TF.addField(fields, "instance_type", params.instance_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  TF.addOptionalField(fields, "ebs_optimised", params.ebs_optimised, TF.booleanValue);
  TF.addOptionalField(fields, "key_name", params.key_name, TF.stringAliasValue);
  TF.addOptionalField(fields, "monitoring", params.monitoring, TF.booleanValue);
  TF.addOptionalField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "associate_public_ip_address", params.associate_public_ip_address, TF.booleanValue);
  TF.addOptionalField(fields, "root_block_device", params.root_block_device, (v) => TF.mapValue(fieldsFromInstanceRootBlockDeviceParams(v)));
  TF.addOptionalField(fields, "user_data", params.user_data, TF.stringValue);
  TF.addOptionalField(fields, "iam_instance_profile", params.iam_instance_profile, TF.resourceIdValue);
  TF.addOptionalField(fields, "vpc_security_group_ids", params.vpc_security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface DbInstanceParams {
  allocated_storage: number;
  engine: AT.DbEngine;
  instance_class: AT.DbInstanceType;
  username: string;
  password?: string;
  engine_version?: string;
  identifier?: string;
  name?: string;
  port?: number;
  publicly_accessible?: boolean;
  backup_retention_period?: number;
  vpc_security_group_ids?: (SecurityGroupId)[];
  parameter_group_name?: string;
  db_subnet_group_name?: string;
  tags?: TF.TagsMap;
  skip_final_snapshot?: boolean;
  final_snapshot_identifier?: string;
  multi_az?: boolean;
  license_model?: string;
  auto_minor_version_upgrade?: boolean;
  replicate_source_db?: DbInstanceId;
  apply_immediately?: boolean;
  storage_encrypted?: boolean;
  storage_type?: AT.DbInstanceStorageType;
}

export function fieldsFromDbInstanceParams(params: DbInstanceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "allocated_storage", params.allocated_storage, TF.numberValue);
  TF.addField(fields, "engine", params.engine, TF.stringAliasValue);
  TF.addField(fields, "instance_class", params.instance_class, TF.stringAliasValue);
  TF.addField(fields, "username", params.username, TF.stringValue);
  TF.addOptionalField(fields, "password", params.password, TF.stringValue);
  TF.addOptionalField(fields, "engine_version", params.engine_version, TF.stringValue);
  TF.addOptionalField(fields, "identifier", params.identifier, TF.stringValue);
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "publicly_accessible", params.publicly_accessible, TF.booleanValue);
  TF.addOptionalField(fields, "backup_retention_period", params.backup_retention_period, TF.numberValue);
  TF.addOptionalField(fields, "vpc_security_group_ids", params.vpc_security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "parameter_group_name", params.parameter_group_name, TF.stringValue);
  TF.addOptionalField(fields, "db_subnet_group_name", params.db_subnet_group_name, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  TF.addOptionalField(fields, "skip_final_snapshot", params.skip_final_snapshot, TF.booleanValue);
  TF.addOptionalField(fields, "final_snapshot_identifier", params.final_snapshot_identifier, TF.stringValue);
  TF.addOptionalField(fields, "multi_az", params.multi_az, TF.booleanValue);
  TF.addOptionalField(fields, "license_model", params.license_model, TF.stringValue);
  TF.addOptionalField(fields, "auto_minor_version_upgrade", params.auto_minor_version_upgrade, TF.booleanValue);
  TF.addOptionalField(fields, "replicate_source_db", params.replicate_source_db, TF.stringAliasValue);
  TF.addOptionalField(fields, "apply_immediately", params.apply_immediately, TF.booleanValue);
  TF.addOptionalField(fields, "storage_encrypted", params.storage_encrypted, TF.booleanValue);
  TF.addOptionalField(fields, "storage_type", params.storage_type, TF.stringAliasValue);
  return fields;
}

export interface EipParams {
  vpc?: boolean;
  instance?: InstanceId;
  tags?: TF.TagsMap;
}

export function fieldsFromEipParams(params: EipParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "vpc", params.vpc, TF.booleanValue);
  TF.addOptionalField(fields, "instance", params.instance, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface VpcParams {
  cidr_block: AT.CidrBlock;
  instance_tenancy?: string;
  enable_dns_support?: boolean;
  enable_dns_hostnames?: boolean;
  enable_classic_link?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromVpcParams(params: VpcParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "cidr_block", params.cidr_block, TF.stringAliasValue);
  TF.addOptionalField(fields, "instance_tenancy", params.instance_tenancy, TF.stringValue);
  TF.addOptionalField(fields, "enable_dns_support", params.enable_dns_support, TF.booleanValue);
  TF.addOptionalField(fields, "enable_dns_hostnames", params.enable_dns_hostnames, TF.booleanValue);
  TF.addOptionalField(fields, "enable_classic_link", params.enable_classic_link, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SubnetParams {
  vpc_id: VpcId;
  cidr_block: AT.CidrBlock;
  map_public_ip_on_launch?: boolean;
  availability_zone?: AT.AvailabilityZone;
  tags?: TF.TagsMap;
}

export function fieldsFromSubnetParams(params: SubnetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addField(fields, "cidr_block", params.cidr_block, TF.stringAliasValue);
  TF.addOptionalField(fields, "map_public_ip_on_launch", params.map_public_ip_on_launch, TF.booleanValue);
  TF.addOptionalField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SecurityGroupParams {
  name?: string;
  name_prefix?: string;
  description?: string;
  ingress?: (IngressRuleParams)[];
  egress?: (EgressRuleParams)[];
  vpc_id?: VpcId;
  tags?: TF.TagsMap;
}

export function fieldsFromSecurityGroupParams(params: SecurityGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addOptionalField(fields, "ingress", params.ingress, TF.listValue((v) => TF.mapValue(fieldsFromIngressRuleParams(v))));
  TF.addOptionalField(fields, "egress", params.egress, TF.listValue((v) => TF.mapValue(fieldsFromEgressRuleParams(v))));
  TF.addOptionalField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface IngressRuleParams {
  from_port: number;
  to_port: number;
  protocol: 'tcp' | 'udp' | 'icmp' | '-1';
  cidr_blocks: (AT.CidrBlock)[];
}

export function fieldsFromIngressRuleParams(params: IngressRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "from_port", params.from_port, TF.numberValue);
  TF.addField(fields, "to_port", params.to_port, TF.numberValue);
  TF.addField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addField(fields, "cidr_blocks", params.cidr_blocks, TF.listValue(TF.stringAliasValue));
  return fields;
}

export interface EgressRuleParams {
  from_port: number;
  to_port: number;
  protocol: 'tcp' | 'udp' | 'icmp' | '-1';
  cidr_blocks: (AT.CidrBlock)[];
}

export function fieldsFromEgressRuleParams(params: EgressRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "from_port", params.from_port, TF.numberValue);
  TF.addField(fields, "to_port", params.to_port, TF.numberValue);
  TF.addField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addField(fields, "cidr_blocks", params.cidr_blocks, TF.listValue(TF.stringAliasValue));
  return fields;
}

export interface InternetGatewayParams {
  vpc_id: VpcId;
  tags?: TF.TagsMap;
}

export function fieldsFromInternetGatewayParams(params: InternetGatewayParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface NatGatewayParams {
  allocation_id: EipId;
  subnet_id: SubnetId;
}

export function fieldsFromNatGatewayParams(params: NatGatewayParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "allocation_id", params.allocation_id, TF.resourceIdValue);
  TF.addField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  return fields;
}

export interface RouteTableParams {
  vpc_id: VpcId;
  tags?: TF.TagsMap;
}

export function fieldsFromRouteTableParams(params: RouteTableParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface RouteParams {
  route_table_id: RouteTableId;
  destination_cidr_block: AT.CidrBlock;
  nat_gateway_id?: NatGatewayId;
  gateway_id?: InternetGatewayId;
}

export function fieldsFromRouteParams(params: RouteParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "route_table_id", params.route_table_id, TF.resourceIdValue);
  TF.addField(fields, "destination_cidr_block", params.destination_cidr_block, TF.stringAliasValue);
  TF.addOptionalField(fields, "nat_gateway_id", params.nat_gateway_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "gateway_id", params.gateway_id, TF.resourceIdValue);
  return fields;
}

export interface RouteTableAssociationParams {
  subnet_id: SubnetId;
  route_table_id: RouteTableId;
}

export function fieldsFromRouteTableAssociationParams(params: RouteTableAssociationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  TF.addField(fields, "route_table_id", params.route_table_id, TF.resourceIdValue);
  return fields;
}

export interface Route53ZoneParams {
  name: string;
  comment?: string;
  vpc_id?: VpcId;
  vpc_region?: AT.Region;
  force_destroy?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromRoute53ZoneParams(params: Route53ZoneParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "comment", params.comment, TF.stringValue);
  TF.addOptionalField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "vpc_region", params.vpc_region, TF.stringAliasValue);
  TF.addOptionalField(fields, "force_destroy", params.force_destroy, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface Route53RecordParams {
  zone_id: AT.HostedZoneId;
  name: string;
  type: 'A' | 'AAAA' | 'CAA' | 'CNAME' | 'MX' | 'NAPTR' | 'NS' | 'PTR' | 'SOA' | 'SPF' | 'SRV' | 'TXT';
  ttl?: string;
  records?: (string)[];
  alias?: Route53AliasParams;
  allow_overwrite?: boolean;
}

export function fieldsFromRoute53RecordParams(params: Route53RecordParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "zone_id", params.zone_id, TF.stringAliasValue);
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addOptionalField(fields, "ttl", params.ttl, TF.stringValue);
  TF.addOptionalField(fields, "records", params.records, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "alias", params.alias, (v) => TF.mapValue(fieldsFromRoute53AliasParams(v)));
  TF.addOptionalField(fields, "allow_overwrite", params.allow_overwrite, TF.booleanValue);
  return fields;
}

export interface Route53AliasParams {
  name: string;
  zone_id: AT.HostedZoneId;
  evaluate_target_health: boolean;
}

export function fieldsFromRoute53AliasParams(params: Route53AliasParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "zone_id", params.zone_id, TF.stringAliasValue);
  TF.addField(fields, "evaluate_target_health", params.evaluate_target_health, TF.booleanValue);
  return fields;
}

export interface BucketVersioningParams {
  enabled?: boolean;
  mfa_delete?: boolean;
}

export function fieldsFromBucketVersioningParams(params: BucketVersioningParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addOptionalField(fields, "mfa_delete", params.mfa_delete, TF.booleanValue);
  return fields;
}

export interface ExpirationParams {
  days?: number;
  date?: string;
  expired_object_delete_marker?: boolean;
}

export function fieldsFromExpirationParams(params: ExpirationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "days", params.days, TF.numberValue);
  TF.addOptionalField(fields, "date", params.date, TF.stringValue);
  TF.addOptionalField(fields, "expired_object_delete_marker", params.expired_object_delete_marker, TF.booleanValue);
  return fields;
}

export interface LifecycleRuleParams {
  id?: string;
  prefix: string;
  enabled: boolean;
  expiration?: ExpirationParams;
}

export function fieldsFromLifecycleRuleParams(params: LifecycleRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "id", params.id, TF.stringValue);
  TF.addField(fields, "prefix", params.prefix, TF.stringValue);
  TF.addField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addOptionalField(fields, "expiration", params.expiration, (v) => TF.mapValue(fieldsFromExpirationParams(v)));
  return fields;
}

export interface CorsRuleParams {
  allowed_headers?: (string)[];
  allowed_methods: (string)[];
  allowed_origins: (string)[];
  expose_headers?: (string)[];
  max_age_seconds?: number;
}

export function fieldsFromCorsRuleParams(params: CorsRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "allowed_headers", params.allowed_headers, TF.listValue(TF.stringValue));
  TF.addField(fields, "allowed_methods", params.allowed_methods, TF.listValue(TF.stringValue));
  TF.addField(fields, "allowed_origins", params.allowed_origins, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "expose_headers", params.expose_headers, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "max_age_seconds", params.max_age_seconds, TF.numberValue);
  return fields;
}

export interface S3BucketParams {
  bucket: string;
  acl?: AT.CannedAcl;
  policy?: string;
  versioning?: BucketVersioningParams;
  lifecycle_rule?: LifecycleRuleParams;
  cors_rule?: CorsRuleParams;
  website?: WebsiteParams;
  tags?: TF.TagsMap;
}

export function fieldsFromS3BucketParams(params: S3BucketParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addOptionalField(fields, "acl", params.acl, TF.stringAliasValue);
  TF.addOptionalField(fields, "policy", params.policy, TF.stringValue);
  TF.addOptionalField(fields, "versioning", params.versioning, (v) => TF.mapValue(fieldsFromBucketVersioningParams(v)));
  TF.addOptionalField(fields, "lifecycle_rule", params.lifecycle_rule, (v) => TF.mapValue(fieldsFromLifecycleRuleParams(v)));
  TF.addOptionalField(fields, "cors_rule", params.cors_rule, (v) => TF.mapValue(fieldsFromCorsRuleParams(v)));
  TF.addOptionalField(fields, "website", params.website, (v) => TF.mapValue(fieldsFromWebsiteParams(v)));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface WebsiteParams {
  index_document?: string;
  error_document?: string;
  redirect_all_requests_to?: string;
  routing_rules?: string;
}

export function fieldsFromWebsiteParams(params: WebsiteParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "index_document", params.index_document, TF.stringValue);
  TF.addOptionalField(fields, "error_document", params.error_document, TF.stringValue);
  TF.addOptionalField(fields, "redirect_all_requests_to", params.redirect_all_requests_to, TF.stringValue);
  TF.addOptionalField(fields, "routing_rules", params.routing_rules, TF.stringValue);
  return fields;
}

export interface S3BucketObjectParams {
  bucket: string;
  key: string;
  source?: string;
  content?: string;
}

export function fieldsFromS3BucketObjectParams(params: S3BucketObjectParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addField(fields, "key", params.key, TF.stringValue);
  TF.addOptionalField(fields, "source", params.source, TF.stringValue);
  TF.addOptionalField(fields, "content", params.content, TF.stringValue);
  return fields;
}

export interface SnsTopicParams {
  name: string;
  display_name?: string;
}

export function fieldsFromSnsTopicParams(params: SnsTopicParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "display_name", params.display_name, TF.stringValue);
  return fields;
}

export interface IamUserParams {
  name: string;
  path?: string;
  force_destroy?: boolean;
}

export function fieldsFromIamUserParams(params: IamUserParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "force_destroy", params.force_destroy, TF.booleanValue);
  return fields;
}

export interface IamUserPolicyParams {
  name: string;
  policy: string;
  user: string;
}

export function fieldsFromIamUserPolicyParams(params: IamUserPolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  TF.addField(fields, "user", params.user, TF.stringValue);
  return fields;
}

export interface IamUserPolicyAttachmentParams {
  user: string;
  policy_arn: AT.Arn;
}

export function fieldsFromIamUserPolicyAttachmentParams(params: IamUserPolicyAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "user", params.user, TF.stringValue);
  TF.addField(fields, "policy_arn", params.policy_arn, TF.stringAliasValue);
  return fields;
}

export interface EcrRepositoryParams {
  name: string;
}

export function fieldsFromEcrRepositoryParams(params: EcrRepositoryParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  return fields;
}

export interface DbSubnetGroupParams {
  name: string;
  description?: string;
  subnet_ids: (SubnetId)[];
  tags?: TF.TagsMap;
}

export function fieldsFromDbSubnetGroupParams(params: DbSubnetGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addField(fields, "subnet_ids", params.subnet_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface CloudwatchMetricAlarmParams {
  alarm_name: string;
  comparison_operator: 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
  evaluation_periods: number;
  metric_name: string;
  namespace: string;
  period: number;
  statistic: 'SampleCount' | 'Average' | 'Sum' | 'Minimum' | 'Maximum';
  threshold: number;
  actions_enabled?: boolean;
  alarm_actions?: (AT.Arn)[];
  alarm_description?: string;
  dimensions?: TF.TagsMap;
  insufficient_data_actions?: (AT.Arn)[];
  ok_actions?: (AT.Arn)[];
  unit?: string;
}

export function fieldsFromCloudwatchMetricAlarmParams(params: CloudwatchMetricAlarmParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "alarm_name", params.alarm_name, TF.stringValue);
  TF.addField(fields, "comparison_operator", params.comparison_operator, TF.stringValue);
  TF.addField(fields, "evaluation_periods", params.evaluation_periods, TF.numberValue);
  TF.addField(fields, "metric_name", params.metric_name, TF.stringValue);
  TF.addField(fields, "namespace", params.namespace, TF.stringValue);
  TF.addField(fields, "period", params.period, TF.numberValue);
  TF.addField(fields, "statistic", params.statistic, TF.stringValue);
  TF.addField(fields, "threshold", params.threshold, TF.numberValue);
  TF.addOptionalField(fields, "actions_enabled", params.actions_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "alarm_actions", params.alarm_actions, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "alarm_description", params.alarm_description, TF.stringValue);
  TF.addOptionalField(fields, "dimensions", params.dimensions, TF.tagsValue);
  TF.addOptionalField(fields, "insufficient_data_actions", params.insufficient_data_actions, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "ok_actions", params.ok_actions, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "unit", params.unit, TF.stringValue);
  return fields;
}

export interface IamInstanceProfileParams {
  name?: string;
  name_prefix?: string;
  path?: string;
  roles?: (string)[];
  role?: string;
}

export function fieldsFromIamInstanceProfileParams(params: IamInstanceProfileParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "roles", params.roles, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "role", params.role, TF.stringValue);
  return fields;
}

export interface IamRoleParams {
  name?: string;
  name_prefix?: string;
  assume_role_policy: string;
  path?: string;
}

export function fieldsFromIamRoleParams(params: IamRoleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "assume_role_policy", params.assume_role_policy, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  return fields;
}

export interface IamRolePolicyParams {
  name: string;
  policy: string;
  role: IamRoleId;
}

export function fieldsFromIamRolePolicyParams(params: IamRolePolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  TF.addField(fields, "role", params.role, TF.resourceIdValue);
  return fields;
}

export interface SqsQueueParams {
  name?: string;
  name_prefix?: string;
  visibility_timeout_seconds?: number;
  message_retention_seconds ?: number;
  max_message_size?: number;
  delay_seconds?: number;
  receive_wait_time_seconds?: number;
  policy?: string;
  redrive_policy?: string;
  fifo_queue?: boolean;
  content_based_deduplication?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromSqsQueueParams(params: SqsQueueParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "visibility_timeout_seconds", params.visibility_timeout_seconds, TF.numberValue);
  TF.addOptionalField(fields, "message_retention_seconds ", params.message_retention_seconds , TF.numberValue);
  TF.addOptionalField(fields, "max_message_size", params.max_message_size, TF.numberValue);
  TF.addOptionalField(fields, "delay_seconds", params.delay_seconds, TF.numberValue);
  TF.addOptionalField(fields, "receive_wait_time_seconds", params.receive_wait_time_seconds, TF.numberValue);
  TF.addOptionalField(fields, "policy", params.policy, TF.stringValue);
  TF.addOptionalField(fields, "redrive_policy", params.redrive_policy, TF.stringValue);
  TF.addOptionalField(fields, "fifo_queue", params.fifo_queue, TF.booleanValue);
  TF.addOptionalField(fields, "content_based_deduplication", params.content_based_deduplication, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SqsQueuePolicyParams {
  queue_url: string;
  policy: string;
}

export function fieldsFromSqsQueuePolicyParams(params: SqsQueuePolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "queue_url", params.queue_url, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  return fields;
}

export interface LbParams {
  name?: string;
  name_prefix?: string;
  internal?: boolean;
  load_balancer_type?: 'application' | 'network';
  security_groups?: (SecurityGroupId)[];
  access_logs?: LbAccessLogsParams;
  subnets?: (SubnetId)[];
  subnet_mapping?: (LbSubnetMappingParams)[];
  idle_timeout?: number;
  enable_deletion_protection?: boolean;
  enable_cross_zone_load_balancing?: boolean;
  enable_http2?: boolean;
  ip_address_type?: 'ipv4' | 'dualstack';
  tags?: TF.TagsMap;
}

export function fieldsFromLbParams(params: LbParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "internal", params.internal, TF.booleanValue);
  TF.addOptionalField(fields, "load_balancer_type", params.load_balancer_type, TF.stringValue);
  TF.addOptionalField(fields, "security_groups", params.security_groups, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "access_logs", params.access_logs, (v) => TF.mapValue(fieldsFromLbAccessLogsParams(v)));
  TF.addOptionalField(fields, "subnets", params.subnets, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "subnet_mapping", params.subnet_mapping, TF.listValue((v) => TF.mapValue(fieldsFromLbSubnetMappingParams(v))));
  TF.addOptionalField(fields, "idle_timeout", params.idle_timeout, TF.numberValue);
  TF.addOptionalField(fields, "enable_deletion_protection", params.enable_deletion_protection, TF.booleanValue);
  TF.addOptionalField(fields, "enable_cross_zone_load_balancing", params.enable_cross_zone_load_balancing, TF.booleanValue);
  TF.addOptionalField(fields, "enable_http2", params.enable_http2, TF.booleanValue);
  TF.addOptionalField(fields, "ip_address_type", params.ip_address_type, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface LbAccessLogsParams {
  bucket: string;
  bucket_prefix?: string;
  interval?: number;
  enabled?: boolean;
}

export function fieldsFromLbAccessLogsParams(params: LbAccessLogsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addOptionalField(fields, "bucket_prefix", params.bucket_prefix, TF.stringValue);
  TF.addOptionalField(fields, "interval", params.interval, TF.numberValue);
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  return fields;
}

export interface LbSubnetMappingParams {
  subnet_id: SubnetId;
  allocation_id: EipId;
}

export function fieldsFromLbSubnetMappingParams(params: LbSubnetMappingParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  TF.addField(fields, "allocation_id", params.allocation_id, TF.resourceIdValue);
  return fields;
}

export interface LbListenerParams {
  load_balancer_arn: AT.ArnT<"Lb">;
  port: number;
  protocol?: 'TCP' | 'HTTP' | 'HTTPS';
  ssl_policy?: string;
  certificate_arn?: AT.ArnT<"AcmCertificate">;
  default_action: LbListenerActionParams;
}

export function fieldsFromLbListenerParams(params: LbListenerParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "load_balancer_arn", params.load_balancer_arn, TF.resourceArnValue);
  TF.addField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addOptionalField(fields, "ssl_policy", params.ssl_policy, TF.stringValue);
  TF.addOptionalField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  TF.addField(fields, "default_action", params.default_action, (v) => TF.mapValue(fieldsFromLbListenerActionParams(v)));
  return fields;
}

export interface LbListenerActionParams {
  type: 'forward' | 'redirect' | 'fixed-response';
  target_group_arn?: AT.ArnT<"LbTargetGroup">;
  redirect?: LbListenerActionRedirectParams;
  fixed_response?: LbListenerActionFixedResponseParams;
}

export function fieldsFromLbListenerActionParams(params: LbListenerActionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addOptionalField(fields, "target_group_arn", params.target_group_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "redirect", params.redirect, (v) => TF.mapValue(fieldsFromLbListenerActionRedirectParams(v)));
  TF.addOptionalField(fields, "fixed_response", params.fixed_response, (v) => TF.mapValue(fieldsFromLbListenerActionFixedResponseParams(v)));
  return fields;
}

export interface LbListenerActionRedirectParams {
  host?: string;
  path?: string;
  port?: string;
  protocol?: 'HTTP' | 'HTTPS' | '#{protocol}';
  query?: string;
  status_code: 'HTTP_301' | 'HTTP_302';
}

export function fieldsFromLbListenerActionRedirectParams(params: LbListenerActionRedirectParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "host", params.host, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.stringValue);
  TF.addOptionalField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addOptionalField(fields, "query", params.query, TF.stringValue);
  TF.addField(fields, "status_code", params.status_code, TF.stringValue);
  return fields;
}

export interface LbListenerActionFixedResponseParams {
  content_type: 'text/plain' | 'text/css' | 'text/html' | 'application/javascript' | 'application/json';
  message_body?: string;
  statusCode?: number;
}

export function fieldsFromLbListenerActionFixedResponseParams(params: LbListenerActionFixedResponseParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "content_type", params.content_type, TF.stringValue);
  TF.addOptionalField(fields, "message_body", params.message_body, TF.stringValue);
  TF.addOptionalField(fields, "statusCode", params.statusCode, TF.numberValue);
  return fields;
}

export interface LbTargetGroupParams {
  name?: string;
  name_prefix?: string;
  port: number;
  protocol: 'TCP' | 'HTTP' | 'HTTPS';
  vpc_id: VpcId;
  deregistration_delay?: number;
  slow_start?: number;
  proxy_protocol_v2?: boolean;
  stickiness?: LbTargetGroupStickinessParams;
  health_check?: LbTargetGroupHealthCheckParams;
  target_type?: 'instance' | 'ip';
  tags?: TF.TagsMap;
}

export function fieldsFromLbTargetGroupParams(params: LbTargetGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "port", params.port, TF.numberValue);
  TF.addField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "deregistration_delay", params.deregistration_delay, TF.numberValue);
  TF.addOptionalField(fields, "slow_start", params.slow_start, TF.numberValue);
  TF.addOptionalField(fields, "proxy_protocol_v2", params.proxy_protocol_v2, TF.booleanValue);
  TF.addOptionalField(fields, "stickiness", params.stickiness, (v) => TF.mapValue(fieldsFromLbTargetGroupStickinessParams(v)));
  TF.addOptionalField(fields, "health_check", params.health_check, (v) => TF.mapValue(fieldsFromLbTargetGroupHealthCheckParams(v)));
  TF.addOptionalField(fields, "target_type", params.target_type, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface LbTargetGroupHealthCheckParams {
  interval?: number;
  path?: string;
  port?: string;
  protocol?: 'TCP' | 'HTTP' | 'HTTPS';
  timeout?: number;
  healthy_threshold?: number;
  unhealthy_threshold?: number;
  matcher?: string;
}

export function fieldsFromLbTargetGroupHealthCheckParams(params: LbTargetGroupHealthCheckParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "interval", params.interval, TF.numberValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.stringValue);
  TF.addOptionalField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addOptionalField(fields, "timeout", params.timeout, TF.numberValue);
  TF.addOptionalField(fields, "healthy_threshold", params.healthy_threshold, TF.numberValue);
  TF.addOptionalField(fields, "unhealthy_threshold", params.unhealthy_threshold, TF.numberValue);
  TF.addOptionalField(fields, "matcher", params.matcher, TF.stringValue);
  return fields;
}

export interface LbTargetGroupStickinessParams {
  type: 'lb_cookie';
  cookie_duration?: number;
  enabled?: boolean;
}

export function fieldsFromLbTargetGroupStickinessParams(params: LbTargetGroupStickinessParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addOptionalField(fields, "cookie_duration", params.cookie_duration, TF.numberValue);
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  return fields;
}

export interface LbTargetGroupAttachmentParams {
  target_group_arn: AT.ArnT<"LbTargetGroup">;
  target_id: string;
  port?: number;
  availability_zone?: AT.AvailabilityZone;
}

export function fieldsFromLbTargetGroupAttachmentParams(params: LbTargetGroupAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "target_group_arn", params.target_group_arn, TF.resourceArnValue);
  TF.addField(fields, "target_id", params.target_id, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  return fields;
}

export interface LbListenerRuleParams {
  listener_arn: AT.ArnT<"LbListener">;
  priority?: number;
  action: LbListenerActionParams;
  condition: LbListenerRuleConditionParams;
}

export function fieldsFromLbListenerRuleParams(params: LbListenerRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "listener_arn", params.listener_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "priority", params.priority, TF.numberValue);
  TF.addField(fields, "action", params.action, (v) => TF.mapValue(fieldsFromLbListenerActionParams(v)));
  TF.addField(fields, "condition", params.condition, (v) => TF.mapValue(fieldsFromLbListenerRuleConditionParams(v)));
  return fields;
}

export interface LbListenerRuleConditionParams {
  field: 'path-pattern' | 'host-header';
  values: (string)[];
}

export function fieldsFromLbListenerRuleConditionParams(params: LbListenerRuleConditionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "field", params.field, TF.stringValue);
  TF.addField(fields, "values", params.values, TF.listValue(TF.stringValue));
  return fields;
}

export interface CloudwatchLogGroupParams {
  name?: string;
  name_prefix?: string;
  retention_in_days?: number;
  tags?: TF.TagsMap;
}

export function fieldsFromCloudwatchLogGroupParams(params: CloudwatchLogGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "retention_in_days", params.retention_in_days, TF.numberValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface AwsParams {
  region?: AT.Region;
}

export function fieldsFromAwsParams(params: AwsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "region", params.region, TF.stringAliasValue);
  return fields;
}

export interface ElasticsearchDomainParams {
  domain_name: string;
  access_policies?: string;
  advanced_options?: TF.TagsMap;
  ebs_options?: ElasticsearchDomainEbsOptionsParams;
  cluster_config?: ElasticsearchDomainClusterConfigParams;
  snapshot_options?: ElasticsearchDomainSnapshotOptionsParams;
  elasticsearch_version?: string;
  tags?: TF.TagsMap;
}

export function fieldsFromElasticsearchDomainParams(params: ElasticsearchDomainParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "access_policies", params.access_policies, TF.stringValue);
  TF.addOptionalField(fields, "advanced_options", params.advanced_options, TF.tagsValue);
  TF.addOptionalField(fields, "ebs_options", params.ebs_options, (v) => TF.mapValue(fieldsFromElasticsearchDomainEbsOptionsParams(v)));
  TF.addOptionalField(fields, "cluster_config", params.cluster_config, (v) => TF.mapValue(fieldsFromElasticsearchDomainClusterConfigParams(v)));
  TF.addOptionalField(fields, "snapshot_options", params.snapshot_options, (v) => TF.mapValue(fieldsFromElasticsearchDomainSnapshotOptionsParams(v)));
  TF.addOptionalField(fields, "elasticsearch_version", params.elasticsearch_version, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface ElasticsearchDomainClusterConfigParams {
  instance_type?: AT.EsInstanceType;
  instance_count?: number;
  dedicated_master_enabled?: boolean;
  dedicated_master_type?: AT.EsInstanceType;
  dedicated_master_count?: number;
  zone_awareness_enabled?: boolean;
}

export function fieldsFromElasticsearchDomainClusterConfigParams(params: ElasticsearchDomainClusterConfigParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "instance_type", params.instance_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "instance_count", params.instance_count, TF.numberValue);
  TF.addOptionalField(fields, "dedicated_master_enabled", params.dedicated_master_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "dedicated_master_type", params.dedicated_master_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "dedicated_master_count", params.dedicated_master_count, TF.numberValue);
  TF.addOptionalField(fields, "zone_awareness_enabled", params.zone_awareness_enabled, TF.booleanValue);
  return fields;
}

export interface ElasticsearchDomainEbsOptionsParams {
  ebs_enabled: boolean;
  volume_type?: string;
  volume_size?: number;
  iops?: number;
}

export function fieldsFromElasticsearchDomainEbsOptionsParams(params: ElasticsearchDomainEbsOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "ebs_enabled", params.ebs_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "volume_type", params.volume_type, TF.stringValue);
  TF.addOptionalField(fields, "volume_size", params.volume_size, TF.numberValue);
  TF.addOptionalField(fields, "iops", params.iops, TF.numberValue);
  return fields;
}

export interface ElasticsearchDomainSnapshotOptionsParams {
  automated_snapshot_start_hour: number;
}

export function fieldsFromElasticsearchDomainSnapshotOptionsParams(params: ElasticsearchDomainSnapshotOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "automated_snapshot_start_hour", params.automated_snapshot_start_hour, TF.numberValue);
  return fields;
}

export interface ElasticsearchDomainPolicyParams {
  domain_name: string;
  access_policies?: string;
}

export function fieldsFromElasticsearchDomainPolicyParams(params: ElasticsearchDomainPolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "access_policies", params.access_policies, TF.stringValue);
  return fields;
}

export interface AcmCertificateParams {
  domain_name: string;
  subject_alternative_names?: (string)[];
  validation_method: string;
  tags?: TF.TagsMap;
}

export function fieldsFromAcmCertificateParams(params: AcmCertificateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "subject_alternative_names", params.subject_alternative_names, TF.listValue(TF.stringValue));
  TF.addField(fields, "validation_method", params.validation_method, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface AcmCertificateValidationParams {
  certificate_arn: AT.ArnT<"AcmCertificate">;
  validation_record_fqdns?: (string)[];
}

export function fieldsFromAcmCertificateValidationParams(params: AcmCertificateValidationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "validation_record_fqdns", params.validation_record_fqdns, TF.listValue(TF.stringValue));
  return fields;
}

export interface LbListenerCertificateParams {
  listener_arn: AT.ArnT<"LbListener">;
  certificate_arn: AT.ArnT<"AcmCertificate">;
}

export function fieldsFromLbListenerCertificateParams(params: LbListenerCertificateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "listener_arn", params.listener_arn, TF.resourceArnValue);
  TF.addField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  return fields;
}

export interface LaunchConfigurationParams {
  name?: string;
  name_prefix?: string;
  image_id: AT.Ami;
  instance_type: AT.InstanceType;
  iam_instance_profile?: IamInstanceProfileId;
  key_name?: AT.KeyName;
  security_groups?: (SecurityGroupId)[];
  associate_public_ip_address?: boolean;
  user_data?: string;
  enable_monitoring?: boolean;
  ebs_optimized?: boolean;
  root_block_device?: InstanceRootBlockDeviceParams;
}

export function fieldsFromLaunchConfigurationParams(params: LaunchConfigurationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "image_id", params.image_id, TF.stringAliasValue);
  TF.addField(fields, "instance_type", params.instance_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "iam_instance_profile", params.iam_instance_profile, TF.resourceIdValue);
  TF.addOptionalField(fields, "key_name", params.key_name, TF.stringAliasValue);
  TF.addOptionalField(fields, "security_groups", params.security_groups, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "associate_public_ip_address", params.associate_public_ip_address, TF.booleanValue);
  TF.addOptionalField(fields, "user_data", params.user_data, TF.stringValue);
  TF.addOptionalField(fields, "enable_monitoring", params.enable_monitoring, TF.booleanValue);
  TF.addOptionalField(fields, "ebs_optimized", params.ebs_optimized, TF.booleanValue);
  TF.addOptionalField(fields, "root_block_device", params.root_block_device, (v) => TF.mapValue(fieldsFromInstanceRootBlockDeviceParams(v)));
  return fields;
}

export interface CloudwatchLoggingOptionsParams {
  enabled?: boolean;
  log_group_name?: string;
  log_stream_name?: string;
}

export function fieldsFromCloudwatchLoggingOptionsParams(params: CloudwatchLoggingOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addOptionalField(fields, "log_group_name", params.log_group_name, TF.stringValue);
  TF.addOptionalField(fields, "log_stream_name", params.log_stream_name, TF.stringValue);
  return fields;
}

export interface ExtendedS3ConfigurationParams {
  role_arn: AT.ArnT<"IamRole">;
  bucket_arn: AT.ArnT<"S3Bucket">;
  buffer_size?: number;
  buffer_interval?: number;
  cloudwatch_logging_options?: CloudwatchLoggingOptionsParams;
}

export function fieldsFromExtendedS3ConfigurationParams(params: ExtendedS3ConfigurationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "role_arn", params.role_arn, TF.resourceArnValue);
  TF.addField(fields, "bucket_arn", params.bucket_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "buffer_size", params.buffer_size, TF.numberValue);
  TF.addOptionalField(fields, "buffer_interval", params.buffer_interval, TF.numberValue);
  TF.addOptionalField(fields, "cloudwatch_logging_options", params.cloudwatch_logging_options, (v) => TF.mapValue(fieldsFromCloudwatchLoggingOptionsParams(v)));
  return fields;
}

export interface KinesisFirehoseDeliveryStreamParams {
  name: string;
  destination: 'extended_s3' | 'redshift' | 'elasticsearch' | 'splunk';
  extended_s3_configuration?: ExtendedS3ConfigurationParams;
  tags?: TF.TagsMap;
}

export function fieldsFromKinesisFirehoseDeliveryStreamParams(params: KinesisFirehoseDeliveryStreamParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "destination", params.destination, TF.stringValue);
  TF.addOptionalField(fields, "extended_s3_configuration", params.extended_s3_configuration, (v) => TF.mapValue(fieldsFromExtendedS3ConfigurationParams(v)));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface S3BucketMetricParams {
  bucket: string;
  name: string;
}

export function fieldsFromS3BucketMetricParams(params: S3BucketMetricParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addField(fields, "name", params.name, TF.stringValue);
  return fields;
}

export interface ElasticacheParameterGroupParams {
  name: string;
  family: string;
  description?: string;
}

export function fieldsFromElasticacheParameterGroupParams(params: ElasticacheParameterGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "family", params.family, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface ElasticacheSubnetGroupParams {
  name: string;
  description?: string;
  subnet_ids: (SubnetId)[];
}

export function fieldsFromElasticacheSubnetGroupParams(params: ElasticacheSubnetGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addField(fields, "subnet_ids", params.subnet_ids, TF.listValue(TF.resourceIdValue));
  return fields;
}

export interface ElasticacheClusterParams {
  cluster_id: string;
  engine: 'memcached' | 'redis';
  node_type: AT.CacheNodeType;
  num_cache_nodes: number;
  parameter_group_name: AT.ElasticacheParameterGroupName;
  port?: number;
  security_group_ids?: (SecurityGroupId)[];
  subnet_group_name?: string;
  tags?: TF.TagsMap;
}

export function fieldsFromElasticacheClusterParams(params: ElasticacheClusterParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "cluster_id", params.cluster_id, TF.stringValue);
  TF.addField(fields, "engine", params.engine, TF.stringValue);
  TF.addField(fields, "node_type", params.node_type, TF.stringAliasValue);
  TF.addField(fields, "num_cache_nodes", params.num_cache_nodes, TF.numberValue);
  TF.addField(fields, "parameter_group_name", params.parameter_group_name, TF.stringAliasValue);
  TF.addOptionalField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "security_group_ids", params.security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "subnet_group_name", params.subnet_group_name, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface VpcConfigParams {
  subnet_ids: (SubnetId)[];
  security_group_ids: (SecurityGroupId)[];
}

export function fieldsFromVpcConfigParams(params: VpcConfigParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "subnet_ids", params.subnet_ids, TF.listValue(TF.resourceIdValue));
  TF.addField(fields, "security_group_ids", params.security_group_ids, TF.listValue(TF.resourceIdValue));
  return fields;
}

export interface LambdaFunctionParams {
  function_name: string;
  filename?: string;
  s3_bucket?: string;
  s3_key?: string;
  source_code_hash?: string;
  role: AT.ArnT<"IamRole">;
  handler: string;
  runtime: AT.LambdaRuntime;
  vpc_config?: VpcConfigParams;
  environment?: LambdaFunctionEnvironmentParams;
  timeout?: number;
  memory_size?: number;
  tags?: TF.TagsMap;
}

export function fieldsFromLambdaFunctionParams(params: LambdaFunctionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "function_name", params.function_name, TF.stringValue);
  TF.addOptionalField(fields, "filename", params.filename, TF.stringValue);
  TF.addOptionalField(fields, "s3_bucket", params.s3_bucket, TF.stringValue);
  TF.addOptionalField(fields, "s3_key", params.s3_key, TF.stringValue);
  TF.addOptionalField(fields, "source_code_hash", params.source_code_hash, TF.stringValue);
  TF.addField(fields, "role", params.role, TF.resourceArnValue);
  TF.addField(fields, "handler", params.handler, TF.stringValue);
  TF.addField(fields, "runtime", params.runtime, TF.stringAliasValue);
  TF.addOptionalField(fields, "vpc_config", params.vpc_config, (v) => TF.mapValue(fieldsFromVpcConfigParams(v)));
  TF.addOptionalField(fields, "environment", params.environment, (v) => TF.mapValue(fieldsFromLambdaFunctionEnvironmentParams(v)));
  TF.addOptionalField(fields, "timeout", params.timeout, TF.numberValue);
  TF.addOptionalField(fields, "memory_size", params.memory_size, TF.numberValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface LambdaFunctionEnvironmentParams {
  variables?: TF.TagsMap;
}

export function fieldsFromLambdaFunctionEnvironmentParams(params: LambdaFunctionEnvironmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "variables", params.variables, TF.tagsValue);
  return fields;
}

export interface LambdaPermissionParams {
  action: AT.LambdaPermissionAction;
  function_name: string;
  principal: string;
  source_arn?: AT.Arn;
}

export function fieldsFromLambdaPermissionParams(params: LambdaPermissionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "action", params.action, TF.stringAliasValue);
  TF.addField(fields, "function_name", params.function_name, TF.stringValue);
  TF.addField(fields, "principal", params.principal, TF.stringValue);
  TF.addOptionalField(fields, "source_arn", params.source_arn, TF.stringAliasValue);
  return fields;
}

export interface CloudwatchEventRuleParams {
  name?: string;
  schedule_expression?: string;
  description?: string;
}

export function fieldsFromCloudwatchEventRuleParams(params: CloudwatchEventRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "schedule_expression", params.schedule_expression, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface CloudwatchEventTargetParams {
  rule: string;
  arn: AT.Arn;
  input: string;
}

export function fieldsFromCloudwatchEventTargetParams(params: CloudwatchEventTargetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rule", params.rule, TF.stringValue);
  TF.addField(fields, "arn", params.arn, TF.stringAliasValue);
  TF.addField(fields, "input", params.input, TF.stringValue);
  return fields;
}

export interface FieldToMatchParams {
  data?: string;
  type: 'HEADER' | 'METHOD' | 'QUERY_STRING' | 'URI' | 'BODY' | 'SINGLE_QUERY_ARG' | 'ALL_QUERY_ARGS';
}

export function fieldsFromFieldToMatchParams(params: FieldToMatchParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "data", params.data, TF.stringValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface ByteMatchTuplesParams {
  field_to_match: FieldToMatchParams;
  positional_constraint: AT.PositionalConstraint;
  target_string?: string;
}

export function fieldsFromByteMatchTuplesParams(params: ByteMatchTuplesParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "field_to_match", params.field_to_match, (v) => TF.mapValue(fieldsFromFieldToMatchParams(v)));
  TF.addField(fields, "positional_constraint", params.positional_constraint, TF.stringAliasValue);
  TF.addOptionalField(fields, "target_string", params.target_string, TF.stringValue);
  return fields;
}

export interface WafByteMatchSetParams {
  name: string;
  byte_match_tuples: ByteMatchTuplesParams;
}

export function fieldsFromWafByteMatchSetParams(params: WafByteMatchSetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "byte_match_tuples", params.byte_match_tuples, (v) => TF.mapValue(fieldsFromByteMatchTuplesParams(v)));
  return fields;
}

export interface IpSetDescriptorsParams {
  type: 'IPV4' | 'IPV6';
  value: string;
}

export function fieldsFromIpSetDescriptorsParams(params: IpSetDescriptorsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addField(fields, "value", params.value, TF.stringValue);
  return fields;
}

export interface WafIpsetParams {
  name: string;
  ip_set_descriptors: IpSetDescriptorsParams;
}

export function fieldsFromWafIpsetParams(params: WafIpsetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "ip_set_descriptors", params.ip_set_descriptors, (v) => TF.mapValue(fieldsFromIpSetDescriptorsParams(v)));
  return fields;
}

export interface WafregionalRegexPatternSetParams {
  name: string;
  regex_pattern_strings?: (string)[];
}

export function fieldsFromWafregionalRegexPatternSetParams(params: WafregionalRegexPatternSetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "regex_pattern_strings", params.regex_pattern_strings, TF.listValue(TF.stringValue));
  return fields;
}

export interface RegexMatchTupleParams {
  field_to_match: FieldToMatchParams;
  regex_pattern_set_id: WafregionalRegexPatternSetId;
  text_transformation: AT.TextTransformation;
}

export function fieldsFromRegexMatchTupleParams(params: RegexMatchTupleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "field_to_match", params.field_to_match, (v) => TF.mapValue(fieldsFromFieldToMatchParams(v)));
  TF.addField(fields, "regex_pattern_set_id", params.regex_pattern_set_id, TF.resourceIdValue);
  TF.addField(fields, "text_transformation", params.text_transformation, TF.stringAliasValue);
  return fields;
}

export interface WafregionalRegexMatchSetParams {
  name: string;
  regex_match_tuple: RegexMatchTupleParams;
}

export function fieldsFromWafregionalRegexMatchSetParams(params: WafregionalRegexMatchSetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "regex_match_tuple", params.regex_match_tuple, (v) => TF.mapValue(fieldsFromRegexMatchTupleParams(v)));
  return fields;
}

export interface WafregionalIpsetParams {
  name: string;
  ip_set_descriptor?: (IpSetDescriptorsParams)[];
}

export function fieldsFromWafregionalIpsetParams(params: WafregionalIpsetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "ip_set_descriptor", params.ip_set_descriptor, TF.listValue((v) => TF.mapValue(fieldsFromIpSetDescriptorsParams(v))));
  return fields;
}

export interface PredicateParams {
  type: 'IPMatch' | 'ByteMatch' | 'SqlInjectionMatch' | 'GeoMatch' | 'SizeConstraint' | 'XssMatch' | 'RegexMatch';
  data_id: string;
  negated: boolean;
}

export function fieldsFromPredicateParams(params: PredicateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addField(fields, "data_id", params.data_id, TF.stringValue);
  TF.addField(fields, "negated", params.negated, TF.booleanValue);
  return fields;
}

export interface WafregionalRuleParams {
  name: string;
  metric_name: string;
  predicate?: (PredicateParams)[];
}

export function fieldsFromWafregionalRuleParams(params: WafregionalRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "metric_name", params.metric_name, TF.stringValue);
  TF.addOptionalField(fields, "predicate", params.predicate, TF.listValue((v) => TF.mapValue(fieldsFromPredicateParams(v))));
  return fields;
}

export interface ActionParams {
  type: 'ALLOW' | 'BLOCK' | 'COUNT';
}

export function fieldsFromActionParams(params: ActionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface RuleParams {
  action: ActionParams;
  override_action?: ActionParams;
  priority: number;
  rule_id: WafregionalRuleId;
  type?: 'REGULAR' | 'RATE_BASED' | 'GROUP';
}

export function fieldsFromRuleParams(params: RuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "action", params.action, (v) => TF.mapValue(fieldsFromActionParams(v)));
  TF.addOptionalField(fields, "override_action", params.override_action, (v) => TF.mapValue(fieldsFromActionParams(v)));
  TF.addField(fields, "priority", params.priority, TF.numberValue);
  TF.addField(fields, "rule_id", params.rule_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface WafregionalWebAclParams {
  name: string;
  metric_name: string;
  default_action: ActionParams;
  rule: RuleParams;
}

export function fieldsFromWafregionalWebAclParams(params: WafregionalWebAclParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "metric_name", params.metric_name, TF.stringValue);
  TF.addField(fields, "default_action", params.default_action, (v) => TF.mapValue(fieldsFromActionParams(v)));
  TF.addField(fields, "rule", params.rule, (v) => TF.mapValue(fieldsFromRuleParams(v)));
  return fields;
}

export interface WafregionalWebAclAssociationParams {
  web_acl_id: WafregionalWebAclId;
  resource_arn: AT.ArnT<"Lb">;
}

export function fieldsFromWafregionalWebAclAssociationParams(params: WafregionalWebAclAssociationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "web_acl_id", params.web_acl_id, TF.resourceIdValue);
  TF.addField(fields, "resource_arn", params.resource_arn, TF.resourceArnValue);
  return fields;
}

export interface SecretsmanagerSecretParams {
  name?: string;
  name_prefix?: string;
  description?: string;
  tags?: TF.TagsMap;
}

export function fieldsFromSecretsmanagerSecretParams(params: SecretsmanagerSecretParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SecretsmanagerSecretVersionParams {
  secret_id: SecretsmanagerSecretId;
  secret_string?: string;
  secret_binary?: string;
  version_stages?: (string)[];
}

export function fieldsFromSecretsmanagerSecretVersionParams(params: SecretsmanagerSecretVersionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "secret_id", params.secret_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "secret_string", params.secret_string, TF.stringValue);
  TF.addOptionalField(fields, "secret_binary", params.secret_binary, TF.stringValue);
  TF.addOptionalField(fields, "version_stages", params.version_stages, TF.listValue(TF.stringValue));
  return fields;
}

export interface CloudfrontCookiesParams {
  forward: 'all' | 'none' | 'whitelist';
  whitelisted_names?: (string)[];
}

export function fieldsFromCloudfrontCookiesParams(params: CloudfrontCookiesParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "forward", params.forward, TF.stringValue);
  TF.addOptionalField(fields, "whitelisted_names", params.whitelisted_names, TF.listValue(TF.stringValue));
  return fields;
}

export interface CloudfrontCustomOriginConfigParams {
  http_port: number;
  https_port: number;
  origin_protocol_policy: 'http-only' | 'https-only' | 'match-viewer';
  origin_ssl_protocols: ('SSLv3' | 'TLSv1' | 'TLSv1.1' | 'TLSv1.2')[];
  origin_keepalive_timeout?: number;
  origin_read_timeout?: number;
}

export function fieldsFromCloudfrontCustomOriginConfigParams(params: CloudfrontCustomOriginConfigParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "http_port", params.http_port, TF.numberValue);
  TF.addField(fields, "https_port", params.https_port, TF.numberValue);
  TF.addField(fields, "origin_protocol_policy", params.origin_protocol_policy, TF.stringValue);
  TF.addField(fields, "origin_ssl_protocols", params.origin_ssl_protocols, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "origin_keepalive_timeout", params.origin_keepalive_timeout, TF.numberValue);
  TF.addOptionalField(fields, "origin_read_timeout", params.origin_read_timeout, TF.numberValue);
  return fields;
}

export interface CloudfrontCustomErrorResponseParams {
  error_code: number;
  response_code?: number;
  response_page_path?: string;
  error_caching_min_ttl?: number;
}

export function fieldsFromCloudfrontCustomErrorResponseParams(params: CloudfrontCustomErrorResponseParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "error_code", params.error_code, TF.numberValue);
  TF.addOptionalField(fields, "response_code", params.response_code, TF.numberValue);
  TF.addOptionalField(fields, "response_page_path", params.response_page_path, TF.stringValue);
  TF.addOptionalField(fields, "error_caching_min_ttl", params.error_caching_min_ttl, TF.numberValue);
  return fields;
}

export interface CloudfrontCacheBehaviourParams {
  allowed_methods: (string)[];
  cached_methods: (string)[];
  forwarded_values: CloudfrontForwardedValuesParams;
  path_pattern?: string;
  compress?: boolean;
  default_ttl?: number;
  min_ttl?: number;
  max_ttl?: number;
  target_origin_id: string;
  viewer_protocol_policy: 'allow-all' | 'https-only' | 'redirect-to-https';
}

export function fieldsFromCloudfrontCacheBehaviourParams(params: CloudfrontCacheBehaviourParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "allowed_methods", params.allowed_methods, TF.listValue(TF.stringValue));
  TF.addField(fields, "cached_methods", params.cached_methods, TF.listValue(TF.stringValue));
  TF.addField(fields, "forwarded_values", params.forwarded_values, (v) => TF.mapValue(fieldsFromCloudfrontForwardedValuesParams(v)));
  TF.addOptionalField(fields, "path_pattern", params.path_pattern, TF.stringValue);
  TF.addOptionalField(fields, "compress", params.compress, TF.booleanValue);
  TF.addOptionalField(fields, "default_ttl", params.default_ttl, TF.numberValue);
  TF.addOptionalField(fields, "min_ttl", params.min_ttl, TF.numberValue);
  TF.addOptionalField(fields, "max_ttl", params.max_ttl, TF.numberValue);
  TF.addField(fields, "target_origin_id", params.target_origin_id, TF.stringValue);
  TF.addField(fields, "viewer_protocol_policy", params.viewer_protocol_policy, TF.stringValue);
  return fields;
}

export interface CloudfrontDistributionParams {
  default_cache_behavior: CloudfrontCacheBehaviourParams;
  enabled: boolean;
  origin: (CloudfrontOriginParams)[];
  restrictions: CloudfrontRestrictionsParams;
  viewer_certificate: CloudfrontViewerCertificateParams;
  aliases?: (string)[];
  is_ipv6_enabled?: boolean;
  custom_error_response?: (CloudfrontCustomErrorResponseParams)[];
  tags?: TF.TagsMap;
}

export function fieldsFromCloudfrontDistributionParams(params: CloudfrontDistributionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "default_cache_behavior", params.default_cache_behavior, (v) => TF.mapValue(fieldsFromCloudfrontCacheBehaviourParams(v)));
  TF.addField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addField(fields, "origin", params.origin, TF.listValue((v) => TF.mapValue(fieldsFromCloudfrontOriginParams(v))));
  TF.addField(fields, "restrictions", params.restrictions, (v) => TF.mapValue(fieldsFromCloudfrontRestrictionsParams(v)));
  TF.addField(fields, "viewer_certificate", params.viewer_certificate, (v) => TF.mapValue(fieldsFromCloudfrontViewerCertificateParams(v)));
  TF.addOptionalField(fields, "aliases", params.aliases, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "is_ipv6_enabled", params.is_ipv6_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "custom_error_response", params.custom_error_response, TF.listValue((v) => TF.mapValue(fieldsFromCloudfrontCustomErrorResponseParams(v))));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface CloudfrontForwardedValuesParams {
  cookies: CloudfrontCookiesParams;
  query_string: boolean;
}

export function fieldsFromCloudfrontForwardedValuesParams(params: CloudfrontForwardedValuesParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "cookies", params.cookies, (v) => TF.mapValue(fieldsFromCloudfrontCookiesParams(v)));
  TF.addField(fields, "query_string", params.query_string, TF.booleanValue);
  return fields;
}

export interface CloudfrontOriginParams {
  domain_name: string;
  origin_id: string;
  s3_origin_config?: CloudfrontS3OriginConfigParams;
  custom_origin_config?: CloudfrontCustomOriginConfigParams;
}

export function fieldsFromCloudfrontOriginParams(params: CloudfrontOriginParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addField(fields, "origin_id", params.origin_id, TF.stringValue);
  TF.addOptionalField(fields, "s3_origin_config", params.s3_origin_config, (v) => TF.mapValue(fieldsFromCloudfrontS3OriginConfigParams(v)));
  TF.addOptionalField(fields, "custom_origin_config", params.custom_origin_config, (v) => TF.mapValue(fieldsFromCloudfrontCustomOriginConfigParams(v)));
  return fields;
}

export interface CloudfrontGeoRestrictionsParams {
  restriction_type: 'none' | 'whitelist' | 'blacklist';
  locations?: (string)[];
}

export function fieldsFromCloudfrontGeoRestrictionsParams(params: CloudfrontGeoRestrictionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "restriction_type", params.restriction_type, TF.stringValue);
  TF.addOptionalField(fields, "locations", params.locations, TF.listValue(TF.stringValue));
  return fields;
}

export interface CloudfrontRestrictionsParams {
  geo_restriction: CloudfrontGeoRestrictionsParams;
}

export function fieldsFromCloudfrontRestrictionsParams(params: CloudfrontRestrictionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "geo_restriction", params.geo_restriction, (v) => TF.mapValue(fieldsFromCloudfrontGeoRestrictionsParams(v)));
  return fields;
}

export interface CloudfrontS3OriginConfigParams {
}

export function fieldsFromCloudfrontS3OriginConfigParams(params: CloudfrontS3OriginConfigParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  return fields;
}

export interface CloudfrontViewerCertificateParams {
  cloudfront_default_certificate?: boolean;
  acm_certificate_arn?: AT.ArnT<"AcmCertificate">;
  minimum_protocol_version?: 'SSLv3' | 'TLSv1' | 'TLSv1_2016' | 'TLSv1.1_2016' | 'TLSv1.2_2018';
  ssl_support_method?: 'vip' | 'sni-only';
}

export function fieldsFromCloudfrontViewerCertificateParams(params: CloudfrontViewerCertificateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "cloudfront_default_certificate", params.cloudfront_default_certificate, TF.booleanValue);
  TF.addOptionalField(fields, "acm_certificate_arn", params.acm_certificate_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "minimum_protocol_version", params.minimum_protocol_version, TF.stringValue);
  TF.addOptionalField(fields, "ssl_support_method", params.ssl_support_method, TF.stringValue);
  return fields;
}

export interface ApiGatewayRestApiParams {
  name: string;
  description?: string;
}

export function fieldsFromApiGatewayRestApiParams(params: ApiGatewayRestApiParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface ApiGatewayResourceParams {
  rest_api_id: ApiGatewayRestApiId;
  parent_id: ApiGatewayRestApiId;
  path_part: string;
}

export function fieldsFromApiGatewayResourceParams(params: ApiGatewayResourceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "parent_id", params.parent_id, TF.resourceIdValue);
  TF.addField(fields, "path_part", params.path_part, TF.stringValue);
  return fields;
}

export interface ApiGatewayMethodParams {
  rest_api_id: ApiGatewayRestApiId;
  resource_id: ApiGatewayResourceId;
  http_method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'ANY';
  authorization: 'NONE' | 'CUSTOM' | 'AWS_IAM' | 'COGNITO_USER_POOLS';
}

export function fieldsFromApiGatewayMethodParams(params: ApiGatewayMethodParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "resource_id", params.resource_id, TF.resourceIdValue);
  TF.addField(fields, "http_method", params.http_method, TF.stringValue);
  TF.addField(fields, "authorization", params.authorization, TF.stringValue);
  return fields;
}

export interface ApiGatewayMethodResponseParams {
  rest_api_id: ApiGatewayRestApiId;
  resource_id: ApiGatewayResourceId;
  http_method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'ANY';
  status_code: string;
  response_models?: TF.TagsMap;
  response_parameters?: TF.TagsMap;
}

export function fieldsFromApiGatewayMethodResponseParams(params: ApiGatewayMethodResponseParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "resource_id", params.resource_id, TF.resourceIdValue);
  TF.addField(fields, "http_method", params.http_method, TF.stringValue);
  TF.addField(fields, "status_code", params.status_code, TF.stringValue);
  TF.addOptionalField(fields, "response_models", params.response_models, TF.tagsValue);
  TF.addOptionalField(fields, "response_parameters", params.response_parameters, TF.tagsValue);
  return fields;
}

export interface ApiGatewayIntegrationParams {
  rest_api_id: ApiGatewayRestApiId;
  resource_id: ApiGatewayResourceId;
  http_method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'ANY';
  integration_http_method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTION';
  uri?: string;
  request_templates?: TF.TagsMap;
  type: 'HTTP' | 'MOCK' | 'AWS' | 'AWS_PROXY' | 'HTTP_PROXY';
}

export function fieldsFromApiGatewayIntegrationParams(params: ApiGatewayIntegrationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "resource_id", params.resource_id, TF.resourceIdValue);
  TF.addField(fields, "http_method", params.http_method, TF.stringValue);
  TF.addOptionalField(fields, "integration_http_method", params.integration_http_method, TF.stringValue);
  TF.addOptionalField(fields, "uri", params.uri, TF.stringValue);
  TF.addOptionalField(fields, "request_templates", params.request_templates, TF.tagsValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface ApiGatewayIntegrationResponseParams {
  rest_api_id: ApiGatewayRestApiId;
  resource_id: ApiGatewayResourceId;
  http_method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'ANY';
  status_code: string;
  response_parameters?: TF.TagsMap;
}

export function fieldsFromApiGatewayIntegrationResponseParams(params: ApiGatewayIntegrationResponseParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "resource_id", params.resource_id, TF.resourceIdValue);
  TF.addField(fields, "http_method", params.http_method, TF.stringValue);
  TF.addField(fields, "status_code", params.status_code, TF.stringValue);
  TF.addOptionalField(fields, "response_parameters", params.response_parameters, TF.tagsValue);
  return fields;
}

export interface ApiGatewayDeploymentParams {
  rest_api_id: ApiGatewayRestApiId;
  stage_name: string;
  description?: string;
}

export function fieldsFromApiGatewayDeploymentParams(params: ApiGatewayDeploymentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "stage_name", params.stage_name, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface ApiGatewayDomainNameParams {
  domain_name: string;
  certificate_arn?: AT.ArnT<"AcmCertificate">;
}

export function fieldsFromApiGatewayDomainNameParams(params: ApiGatewayDomainNameParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  return fields;
}

export interface ApiGatewayBasePathMappingParams {
  domain_name: string;
  api_id: ApiGatewayRestApiId;
  stage_name?: string;
  base_path?: string;
}

export function fieldsFromApiGatewayBasePathMappingParams(params: ApiGatewayBasePathMappingParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addField(fields, "api_id", params.api_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "stage_name", params.stage_name, TF.stringValue);
  TF.addOptionalField(fields, "base_path", params.base_path, TF.stringValue);
  return fields;
}
