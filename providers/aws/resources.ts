/** Automatically @generated by gen-providers.ts, DO NOT EDIT */

import * as _ from "lodash";
import * as AT from "./types";
import * as TF from "../../core/core";

/**
 *  Provides attachment of a autoscaling group to a ALB load balancer
 *
 *  see https://www.terraform.io/docs/providers/aws/r/autoscaling_attachment.html
 */
export function createAutoscalingAttachment(tfgen: TF.Generator, rname: string, params: AutoscalingAttachmentParams): AutoscalingAttachment {
  const fields = fieldsFromAutoscalingAttachmentParams(params);
  const resource = tfgen.createTypedResource('AutoscalingAttachment', 'aws_autoscaling_attachment', rname, fields);

  return {
    ...resource,
  };
}

export interface AutoscalingAttachment extends TF.ResourceT<'AutoscalingAttachment'> {
}

export type AutoscalingAttachmentId = {type:'AutoscalingAttachmentId',value:string};

/**
 *  Provides aws_autoscaling_group
 *
 *  see https://www.terraform.io/docs/providers/aws/r/autoscaling_group.html
 */
export function createAutoscalingGroup(tfgen: TF.Generator, rname: string, params: AutoscalingGroupParams): AutoscalingGroup {
  const fields = fieldsFromAutoscalingGroupParams(params);
  const resource = tfgen.createTypedResource('AutoscalingGroup', 'aws_autoscaling_group', rname, fields);
  const id: AutoscalingGroupId =  {type: 'AutoscalingGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: AutoscalingGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'AutoscalingGroup');

  return {
    ...resource,
    id,
    name,
    arn,
  };
}

export interface AutoscalingGroup extends TF.ResourceT<'AutoscalingGroup'> {
  id: AutoscalingGroupId;
  name: string;
  arn: AutoscalingGroupArn;
}

export type AutoscalingGroupId = {type:'AutoscalingGroupId',value:string};
export type AutoscalingGroupArn = AT.ArnT<"AutoscalingGroup">;

/**
 *  Provides an AutoScaling Schedule resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/autoscaling_schedule.html
 */
export function createAutoscalingSchedule(tfgen: TF.Generator, rname: string, params: AutoscalingScheduleParams): AutoscalingSchedule {
  const fields = fieldsFromAutoscalingScheduleParams(params);
  const resource = tfgen.createTypedResource('AutoscalingSchedule', 'aws_autoscaling_schedule', rname, fields);
  const arn: AutoscalingScheduleArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'AutoscalingSchedule');

  return {
    ...resource,
    arn,
  };
}

export interface AutoscalingSchedule extends TF.ResourceT<'AutoscalingSchedule'> {
  arn: AutoscalingScheduleArn;
}

export type AutoscalingScheduleId = {type:'AutoscalingScheduleId',value:string};
export type AutoscalingScheduleArn = AT.ArnT<"AutoscalingSchedule">;

/**
 *  Provides an EC2 instance resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/instance.html
 */
export function createInstance(tfgen: TF.Generator, rname: string, params: InstanceParams): Instance {
  const fields = fieldsFromInstanceParams(params);
  const resource = tfgen.createTypedResource('Instance', 'aws_instance', rname, fields);
  const id: InstanceId =  {type: 'InstanceId', value: '${' + TF.resourceName(resource) + '.id}'};
  const availability_zone: AT.AvailabilityZone =  {type: 'AvailabilityZone', value: '${' + TF.resourceName(resource) + '.availability_zone}'};
  const public_dns: string =  '${' + TF.resourceName(resource) + '.public_dns}';
  const public_ip: AT.IpAddress =  {type: 'IpAddress', value: '${' + TF.resourceName(resource) + '.public_ip}'};
  const private_dns: string =  '${' + TF.resourceName(resource) + '.private_dns}';
  const private_ip: AT.IpAddress =  {type: 'IpAddress', value: '${' + TF.resourceName(resource) + '.private_ip}'};
  const arn: InstanceArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'Instance');

  return {
    ...resource,
    id,
    availability_zone,
    public_dns,
    public_ip,
    private_dns,
    private_ip,
    arn,
  };
}

export interface Instance extends TF.ResourceT<'Instance'> {
  id: InstanceId;
  availability_zone: AT.AvailabilityZone;
  public_dns: string;
  public_ip: AT.IpAddress;
  private_dns: string;
  private_ip: AT.IpAddress;
  arn: InstanceArn;
}

export type InstanceId = {type:'InstanceId',value:string};
export type InstanceArn = AT.ArnT<"Instance">;

/**
 *  Manages a single EBS volume.
 *
 *  see https://registry.terraform.io/providers/hashicorp/aws/2.70.0/docs/resources/ebs_volume
 */
export function createEbsVolume(tfgen: TF.Generator, rname: string, params: EbsVolumeParams): EbsVolume {
  const fields = fieldsFromEbsVolumeParams(params);
  const resource = tfgen.createTypedResource('EbsVolume', 'aws_ebs_volume', rname, fields);
  const id: EbsVolumeId =  {type: 'EbsVolumeId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: EbsVolumeArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'EbsVolume');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface EbsVolume extends TF.ResourceT<'EbsVolume'> {
  id: EbsVolumeId;
  arn: EbsVolumeArn;
}

export type EbsVolumeId = {type:'EbsVolumeId',value:string};
export type EbsVolumeArn = AT.ArnT<"EbsVolume">;

/**
 *  Provides an AWS EBS Volume Attachment as a top level resource, to attach and detach volumes from AWS Instances.
 *
 *  see https://registry.terraform.io/providers/hashicorp/aws/2.70.0/docs/resources/volume_attachment
 */
export function createVolumeAttachment(tfgen: TF.Generator, rname: string, params: VolumeAttachmentParams): VolumeAttachment {
  const fields = fieldsFromVolumeAttachmentParams(params);
  const resource = tfgen.createTypedResource('VolumeAttachment', 'aws_volume_attachment', rname, fields);
  const device_name: string =  '${' + TF.resourceName(resource) + '.device_name}';
  const instance_id: InstanceId =  {type: 'InstanceId', value: '${' + TF.resourceName(resource) + '.instance_id}'};
  const volume_id: VolumeAttachmentId =  {type: 'VolumeAttachmentId', value: '${' + TF.resourceName(resource) + '.volume_id}'};
  const arn: VolumeAttachmentArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'VolumeAttachment');

  return {
    ...resource,
    device_name,
    instance_id,
    volume_id,
    arn,
  };
}

export interface VolumeAttachment extends TF.ResourceT<'VolumeAttachment'> {
  device_name: string;
  instance_id: InstanceId;
  volume_id: VolumeAttachmentId;
  arn: VolumeAttachmentArn;
}

export type VolumeAttachmentId = {type:'VolumeAttachmentId',value:string};
export type VolumeAttachmentArn = AT.ArnT<"VolumeAttachment">;

/**
 *  Provides an RDS instance resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/db_instance.html
 */
export function createDbInstance(tfgen: TF.Generator, rname: string, params: DbInstanceParams): DbInstance {
  const fields = fieldsFromDbInstanceParams(params);
  const resource = tfgen.createTypedResource('DbInstance', 'aws_db_instance', rname, fields);
  const id: DbInstanceId =  {type: 'DbInstanceId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const username: string =  '${' + TF.resourceName(resource) + '.username}';
  const address: string =  '${' + TF.resourceName(resource) + '.address}';
  const port: string =  '${' + TF.resourceName(resource) + '.port}';
  const engine_version: string =  '${' + TF.resourceName(resource) + '.engine_version}';
  const arn: DbInstanceArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'DbInstance');

  return {
    ...resource,
    id,
    name,
    username,
    address,
    port,
    engine_version,
    arn,
  };
}

export interface DbInstance extends TF.ResourceT<'DbInstance'> {
  id: DbInstanceId;
  name: string;
  username: string;
  address: string;
  port: string;
  engine_version: string;
  arn: DbInstanceArn;
}

export type DbInstanceId = {type:'DbInstanceId',value:string};
export type DbInstanceArn = AT.ArnT<"DbInstance">;

/**
 *  Provides an RDS DB parameter group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/db_parameter_group.html
 */
export function createDbParameterGroup(tfgen: TF.Generator, rname: string, params: DbParameterGroupParams): DbParameterGroup {
  const fields = fieldsFromDbParameterGroupParams(params);
  const resource = tfgen.createTypedResource('DbParameterGroup', 'aws_db_parameter_group', rname, fields);
  const id: DbParameterGroupId =  {type: 'DbParameterGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: DbParameterGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'DbParameterGroup');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface DbParameterGroup extends TF.ResourceT<'DbParameterGroup'> {
  id: DbParameterGroupId;
  arn: DbParameterGroupArn;
}

export type DbParameterGroupId = {type:'DbParameterGroupId',value:string};
export type DbParameterGroupArn = AT.ArnT<"DbParameterGroup">;

/**
 *  Provides an Elastic IP Address.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/eip.html
 */
export function createEip(tfgen: TF.Generator, rname: string, params: EipParams): Eip {
  const fields = fieldsFromEipParams(params);
  const resource = tfgen.createTypedResource('Eip', 'aws_eip', rname, fields);
  const id: EipId =  {type: 'EipId', value: '${' + TF.resourceName(resource) + '.id}'};
  const public_ip: AT.IpAddress =  {type: 'IpAddress', value: '${' + TF.resourceName(resource) + '.public_ip}'};
  const private_ip: AT.IpAddress =  {type: 'IpAddress', value: '${' + TF.resourceName(resource) + '.private_ip}'};

  return {
    ...resource,
    id,
    public_ip,
    private_ip,
  };
}

export interface Eip extends TF.ResourceT<'Eip'> {
  id: EipId;
  public_ip: AT.IpAddress;
  private_ip: AT.IpAddress;
}

export type EipId = {type:'EipId',value:string};

/**
 *  Provides a VPC.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/vpc.html
 */
export function createVpc(tfgen: TF.Generator, rname: string, params: VpcParams): Vpc {
  const fields = fieldsFromVpcParams(params);
  const resource = tfgen.createTypedResource('Vpc', 'aws_vpc', rname, fields);
  const id: VpcId =  {type: 'VpcId', value: '${' + TF.resourceName(resource) + '.id}'};
  const default_route_table_id: RouteTableId =  {type: 'RouteTableId', value: '${' + TF.resourceName(resource) + '.default_route_table_id}'};

  return {
    ...resource,
    id,
    default_route_table_id,
  };
}

export interface Vpc extends TF.ResourceT<'Vpc'> {
  id: VpcId;
  default_route_table_id: RouteTableId;
}

export type VpcId = {type:'VpcId',value:string};

/**
 *  Provides a resource to manage the default AWS VPC in the current region.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/default_vpc.html
 */
export function createDefaultVpc(tfgen: TF.Generator, rname: string, params: DefaultVpcParams): DefaultVpc {
  const fields = fieldsFromDefaultVpcParams(params);
  const resource = tfgen.createTypedResource('DefaultVpc', 'aws_default_vpc', rname, fields);
  const id: VpcId =  {type: 'VpcId', value: '${' + TF.resourceName(resource) + '.id}'};
  const default_route_table_id: RouteTableId =  {type: 'RouteTableId', value: '${' + TF.resourceName(resource) + '.default_route_table_id}'};

  return {
    ...resource,
    id,
    default_route_table_id,
  };
}

export interface DefaultVpc extends TF.ResourceT<'DefaultVpc'> {
  id: VpcId;
  default_route_table_id: RouteTableId;
}

export type DefaultVpcId = {type:'DefaultVpcId',value:string};

/**
 *  Provides a VPC Subnet.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/subnet.html
 */
export function createSubnet(tfgen: TF.Generator, rname: string, params: SubnetParams): Subnet {
  const fields = fieldsFromSubnetParams(params);
  const resource = tfgen.createTypedResource('Subnet', 'aws_subnet', rname, fields);
  const id: SubnetId =  {type: 'SubnetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface Subnet extends TF.ResourceT<'Subnet'> {
  id: SubnetId;
}

export type SubnetId = {type:'SubnetId',value:string};

/**
 *  Provides a resource to manage a default AWS VPC subnet in the current region.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/default_subnet.html
 */
export function createDefaultSubnet(tfgen: TF.Generator, rname: string, params: DefaultSubnetParams): DefaultSubnet {
  const fields = fieldsFromDefaultSubnetParams(params);
  const resource = tfgen.createTypedResource('DefaultSubnet', 'aws_default_subnet', rname, fields);
  const id: SubnetId =  {type: 'SubnetId', value: '${' + TF.resourceName(resource) + '.id}'};
  const availability_zone: AT.AvailabilityZone =  {type: 'AvailabilityZone', value: '${' + TF.resourceName(resource) + '.availability_zone}'};

  return {
    ...resource,
    id,
    availability_zone,
  };
}

export interface DefaultSubnet extends TF.ResourceT<'DefaultSubnet'> {
  id: SubnetId;
  availability_zone: AT.AvailabilityZone;
}

export type DefaultSubnetId = {type:'DefaultSubnetId',value:string};

/**
 *  Provides a resource to manage a AWS endpoint.
 *
 *  see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpc_endpoint
 */
export function createVpcEndpoint(tfgen: TF.Generator, rname: string, params: VpcEndpointParams): VpcEndpoint {
  const fields = fieldsFromVpcEndpointParams(params);
  const resource = tfgen.createTypedResource('VpcEndpoint', 'aws_vpc_endpoint', rname, fields);
  const id: VpcEndpointId =  {type: 'VpcEndpointId', value: '${' + TF.resourceName(resource) + '.id}'};
  const owner_id: string =  '${' + TF.resourceName(resource) + '.owner_id}';
  const prefix_list_id: string =  '${' + TF.resourceName(resource) + '.prefix_list_id}';
  const arn: VpcEndpointArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'VpcEndpoint');

  return {
    ...resource,
    id,
    owner_id,
    prefix_list_id,
    arn,
  };
}

export interface VpcEndpoint extends TF.ResourceT<'VpcEndpoint'> {
  id: VpcEndpointId;
  owner_id: string;
  prefix_list_id: string;
  arn: VpcEndpointArn;
}

export type VpcEndpointId = {type:'VpcEndpointId',value:string};
export type VpcEndpointArn = AT.ArnT<"VpcEndpoint">;

/**
 *  Provides a security group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/security_group.html
 */
export function createSecurityGroup(tfgen: TF.Generator, rname: string, params: SecurityGroupParams): SecurityGroup {
  const fields = fieldsFromSecurityGroupParams(params);
  const resource = tfgen.createTypedResource('SecurityGroup', 'aws_security_group', rname, fields);
  const id: SecurityGroupId =  {type: 'SecurityGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const owner_id: string =  '${' + TF.resourceName(resource) + '.owner_id}';

  return {
    ...resource,
    id,
    owner_id,
  };
}

export interface SecurityGroup extends TF.ResourceT<'SecurityGroup'> {
  id: SecurityGroupId;
  owner_id: string;
}

export type SecurityGroupId = {type:'SecurityGroupId',value:string};

/**
 *  Provides a security group rule resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/security_group_rule.html
 */
export function createSecurityGroupRule(tfgen: TF.Generator, rname: string, params: SecurityGroupRuleParams): SecurityGroupRule {
  const fields = fieldsFromSecurityGroupRuleParams(params);
  const resource = tfgen.createTypedResource('SecurityGroupRule', 'aws_security_group_rule', rname, fields);
  const id: SecurityGroupId =  {type: 'SecurityGroupId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface SecurityGroupRule extends TF.ResourceT<'SecurityGroupRule'> {
  id: SecurityGroupId;
}

export type SecurityGroupRuleId = {type:'SecurityGroupRuleId',value:string};

/**
 *  Provides a resource to create a VPC Custom Gateway.
 *
 *  see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/customer_gateway
 */
 export function createCustomerGateway(tfgen: TF.Generator, rname: string, params: CustomerGatewayParams): CustomerGateway {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bgp_asn", 65000, TF.numberValue);
  TF.addField(fields, "ip_address", params.ip_address, TF.stringAliasValue);
  TF.addField(fields, "type", "ipsec.1", TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  const resource = tfgen.createTypedResource('CustomerGateway', 'aws_customer_gateway', rname, fields);
  const id: CustomerGatewayId =  {type: 'CustomerGatewayId', value: '${' + TF.resourceName(resource) + '.id}'};
  return {
    ...resource,
    id,
  };
}

export interface CustomerGateway extends TF.ResourceT<'CustomerGateway'> {
  id: CustomerGatewayId;
}

export type CustomerGatewayId = {type:'CustomerGatewayId',value:string};

export interface CustomerGatewayParams {
  ip_address: AT.IpAddress;
  tags?: TF.TagsMap;
}

export interface VpnAz {
  internal_subnet: Subnet;
  rtinternal: RouteTable;
  azname: string;
};

export interface VpnConn {
  customer_gw: CustomerGateway;
  vpn_connection: VpnConnection;
};

export interface Vpn {
  azs: VpnAz[];
  vpns: VpnConn[];
}

/**
 *  see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpn_gateway
 */
 export function createVPNGateway(tfgen: TF.Generator, rname: string, params: VPNGatewayParams): VPNGateway {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  const resource = tfgen.createTypedResource('VPNGateway', 'aws_vpn_gateway', rname, fields);
  const id: VPNGatewayId =  {type: 'VPNGatewayId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: VPNGatewayArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'VPNGatewayArn');
  return {
    ...resource,
    id,
    arn,
  };
}

export interface VPNGateway extends TF.ResourceT<'VPNGateway'> {
  id: VPNGatewayId;
  arn: VPNGatewayArn;
}

export type VPNGatewayId = {type:'VPNGatewayId',value:string};
export type VPNGatewayArn = AT.ArnT<"VPNGatewayArn">;

export interface VPNGatewayParams {
  vpc_id: VpcId;
  //availability_zone
  //amazon_side_asn
  tags?: TF.TagsMap;
}

/** see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpn_gateway_attachment */

export function createVpnGatewayAttachment(tfgen: TF.Generator, rname: string, params: VpnGatewayAttachmentParams): VpnGatewayAttachment {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.stringAliasValue);
  TF.addField(fields, "vpn_gateway_id", params.vpn_gateway_id, TF.stringAliasValue);

  const resource = tfgen.createTypedResource('VpnGatewayAttachment', 'aws_vpn_gateway_attachment', rname, fields);
  return {
    ...resource,
  };
}

export interface VpnGatewayAttachmentParams {
  vpc_id: VpcId;
  vpn_gateway_id: VPNGatewayId;
}

export interface VpnGatewayAttachment extends TF.ResourceT<'VpnGatewayAttachment'> {
}

/** see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpn_connection */

export function createVpnConnection(tfgen: TF.Generator, rname: string, params: VpnConnectionParams): VpnConnection {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpn_gateway_id", params.vpn_gateway_id, TF.stringAliasValue);
  TF.addField(fields, "customer_gateway_id", params.customer_gateway_id, TF.stringAliasValue);
  TF.addField(fields, "type", "ipsec.1", TF.stringValue);
  TF.addField(fields, "static_routes_only", true, TF.booleanValue);
  const resource = tfgen.createTypedResource('VpnConnection', 'aws_vpn_connection', rname, fields);
  const id: VpnConnectionId =  {type: 'VpnConnectionId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: VpnConnectionArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'VpnConnectionArn');
  return {
    ...resource,
    id,
    arn,
  };
}

export interface VpnConnectionParams {
  customer_gateway_id: CustomerGatewayId;
  vpn_gateway_id: VPNGatewayId; // or transit_gateway_id
}

export interface VpnConnection extends TF.ResourceT<'VpnConnection'> {
  id: VpnConnectionId;
  arn: VpnConnectionArn;
}

export type VpnConnectionId = {type:'VpnConnectionId',value:string};
export type VpnConnectionArn = AT.ArnT<"VpnConnectionArn">;

/** see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpn_connection_route */

export function createVpnConnectionRoute(tfgen: TF.Generator, rname: string, params: VpnConnectionRouteParams): VpnConnectionRoute {
    const fields: TF.ResourceFieldMap = [];
    TF.addField(fields, "destination_cidr_block", params.destination_cidr_block, TF.stringAliasValue);
    TF.addField(fields, "vpn_connection_id", params.vpn_connection_id, TF.stringAliasValue);
    const resource = tfgen.createTypedResource('VpnConnectionRoute', 'aws_vpn_connection_route', rname, fields);
    return {
      ...resource,
    };
}

export interface VpnConnectionRouteParams {
  destination_cidr_block: AT.CidrBlock;
  vpn_connection_id: VpnConnectionId;
}

export interface VpnConnectionRoute extends TF.ResourceT<'VpnConnectionRoute'> {
}

/**
 *  Provides a resource to create a VPC Internet Gateway.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/internet_gateway.html
 */
export function createInternetGateway(tfgen: TF.Generator, rname: string, params: InternetGatewayParams): InternetGateway {
  const fields = fieldsFromInternetGatewayParams(params);
  const resource = tfgen.createTypedResource('InternetGateway', 'aws_internet_gateway', rname, fields);
  const id: InternetGatewayId =  {type: 'InternetGatewayId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface InternetGateway extends TF.ResourceT<'InternetGateway'> {
  id: InternetGatewayId;
}

export type InternetGatewayId = {type:'InternetGatewayId',value:string};

/**
 *  Provides a resource to create a VPC NAT Gateway.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/nat_gateway.html
 */
export function createNatGateway(tfgen: TF.Generator, rname: string, params: NatGatewayParams): NatGateway {
  const fields = fieldsFromNatGatewayParams(params);
  const resource = tfgen.createTypedResource('NatGateway', 'aws_nat_gateway', rname, fields);
  const id: NatGatewayId =  {type: 'NatGatewayId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface NatGateway extends TF.ResourceT<'NatGateway'> {
  id: NatGatewayId;
}

export type NatGatewayId = {type:'NatGatewayId',value:string};

/**
 *  Provides a resource to create a VPC routing table.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route_table.html
 */
export function createRouteTable(tfgen: TF.Generator, rname: string, params: RouteTableParams): RouteTable {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  const resource = tfgen.createTypedResource('RouteTable', 'aws_route_table', rname, fields);
  const id: RouteTableId =  {type: 'RouteTableId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface RouteTableParams {
  vpc_id: VpcId;
  tags?: TF.TagsMap;
}

export interface RouteTable extends TF.ResourceT<'RouteTable'> {
  id: RouteTableId;
}

export type RouteTableId = {type:'RouteTableId',value:string};

/**
 *  Provides a resource to create a routing table entry (a route) in a VPC routing table.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route.html
 */
export function createRoute(tfgen: TF.Generator, rname: string, params: RouteParams): Route {
  const fields = fieldsFromRouteParams(params);
  const resource = tfgen.createTypedResource('Route', 'aws_route', rname, fields);

  return {
    ...resource,
  };
}

export interface RouteParams {
  route_table_id: RouteTableId;
  destination_cidr_block: AT.CidrBlock;
  nat_gateway_id?: NatGatewayId;
  gateway_id?: InternetGatewayId | VPNGatewayId;
}

export function fieldsFromRouteParams(params: RouteParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "route_table_id", params.route_table_id, TF.resourceIdValue);
  TF.addField(fields, "destination_cidr_block", params.destination_cidr_block, TF.stringAliasValue);
  TF.addOptionalField(fields, "nat_gateway_id", params.nat_gateway_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "gateway_id", params.gateway_id, TF.resourceIdValue);
  return fields;
}

export interface Route extends TF.ResourceT<'Route'> {
}

export type RouteId = {type:'RouteId',value:string};

/**
 *  Provides a resource to create an association between a subnet and routing table.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route_table_association.html
 */
export function createRouteTableAssociation(tfgen: TF.Generator, rname: string, params: RouteTableAssociationParams): RouteTableAssociation {
  const fields = fieldsFromRouteTableAssociationParams(params);
  const resource = tfgen.createTypedResource('RouteTableAssociation', 'aws_route_table_association', rname, fields);
  const id: RouteTableAssociationId =  {type: 'RouteTableAssociationId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface RouteTableAssociation extends TF.ResourceT<'RouteTableAssociation'> {
  id: RouteTableAssociationId;
}

export type RouteTableAssociationId = {type:'RouteTableAssociationId',value:string};

/**
 *  Provides a Route53 record resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route53_record.htm
 */
export function createRoute53Record(tfgen: TF.Generator, rname: string, params: Route53RecordParams): Route53Record {
  const fields = fieldsFromRoute53RecordParams(params);
  const resource = tfgen.createTypedResource('Route53Record', 'aws_route53_record', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const fqdn: string =  '${' + TF.resourceName(resource) + '.fqdn}';

  return {
    ...resource,
    name,
    fqdn,
  };
}

export interface Route53Record extends TF.ResourceT<'Route53Record'> {
  name: string;
  fqdn: string;
}

export type Route53RecordId = {type:'Route53RecordId',value:string};

/**
 *  Provides a S3 bucket resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/s3_bucket.html
 */
export function createS3Bucket(tfgen: TF.Generator, rname: string, params: S3BucketParams): S3Bucket {
  const fields = fieldsFromS3BucketParams(params);
  const resource = tfgen.createTypedResource('S3Bucket', 'aws_s3_bucket', rname, fields);
  const id: string =  '${' + TF.resourceName(resource) + '.id}';
  const arn: S3BucketArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'S3Bucket');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface S3Bucket extends TF.ResourceT<'S3Bucket'> {
  id: string;
  arn: S3BucketArn;
}

export type S3BucketId = {type:'S3BucketId',value:string};
export type S3BucketArn = AT.ArnT<"S3Bucket">;

/**
 *  Provides a S3 bucket object resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/s3_bucket_object.html
 */
export function createS3BucketObject(tfgen: TF.Generator, rname: string, params: S3BucketObjectParams): S3BucketObject {
  const fields = fieldsFromS3BucketObjectParams(params);
  const resource = tfgen.createTypedResource('S3BucketObject', 'aws_s3_bucket_object', rname, fields);
  const id: string =  '${' + TF.resourceName(resource) + '.id}';
  const etag: string =  '${' + TF.resourceName(resource) + '.etag}';
  const version_id: string =  '${' + TF.resourceName(resource) + '.version_id}';

  return {
    ...resource,
    id,
    etag,
    version_id,
  };
}

export interface S3BucketObject extends TF.ResourceT<'S3BucketObject'> {
  id: string;
  etag: string;
  version_id: string;
}

export type S3BucketObjectId = {type:'S3BucketObjectId',value:string};

/**
 *  Provides an SNS topic resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/sns_topic.html
 */
export function createSnsTopic(tfgen: TF.Generator, rname: string, params: SnsTopicParams): SnsTopic {
  const fields = fieldsFromSnsTopicParams(params);
  const resource = tfgen.createTypedResource('SnsTopic', 'aws_sns_topic', rname, fields);
  const id: SnsTopicId =  {type: 'SnsTopicId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: SnsTopicArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'SnsTopic');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface SnsTopic extends TF.ResourceT<'SnsTopic'> {
  id: SnsTopicId;
  arn: SnsTopicArn;
}

export type SnsTopicId = {type:'SnsTopicId',value:string};
export type SnsTopicArn = AT.ArnT<"SnsTopic">;

/**
 *  Provides an IAM user.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_user.html
 */
export function createIamUser(tfgen: TF.Generator, rname: string, params: IamUserParams): IamUser {
  const fields = fieldsFromIamUserParams(params);
  const resource = tfgen.createTypedResource('IamUser', 'aws_iam_user', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const unique_id: string =  '${' + TF.resourceName(resource) + '.unique_id}';
  const arn: IamUserArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamUser');

  return {
    ...resource,
    name,
    unique_id,
    arn,
  };
}

export interface IamUser extends TF.ResourceT<'IamUser'> {
  name: string;
  unique_id: string;
  arn: IamUserArn;
}

export type IamUserId = {type:'IamUserId',value:string};
export type IamUserArn = AT.ArnT<"IamUser">;

/**
 *  Provides an IAM policy attached to a user.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_user_policy.html
 */
export function createIamUserPolicy(tfgen: TF.Generator, rname: string, params: IamUserPolicyParams): IamUserPolicy {
  const fields = fieldsFromIamUserPolicyParams(params);
  const resource = tfgen.createTypedResource('IamUserPolicy', 'aws_iam_user_policy', rname, fields);

  return {
    ...resource,
  };
}

export interface IamUserPolicy extends TF.ResourceT<'IamUserPolicy'> {
}

export type IamUserPolicyId = {type:'IamUserPolicyId',value:string};

/**
 *  Attaches a Managed IAM Policy to an IAM user
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_user_policy_attachment.html
 */
export function createIamUserPolicyAttachment(tfgen: TF.Generator, rname: string, params: IamUserPolicyAttachmentParams): IamUserPolicyAttachment {
  const fields = fieldsFromIamUserPolicyAttachmentParams(params);
  const resource = tfgen.createTypedResource('IamUserPolicyAttachment', 'aws_iam_user_policy_attachment', rname, fields);

  return {
    ...resource,
  };
}

export interface IamUserPolicyAttachment extends TF.ResourceT<'IamUserPolicyAttachment'> {
}

export type IamUserPolicyAttachmentId = {type:'IamUserPolicyAttachmentId',value:string};

/**
 *  Provides an IAM group.
 *
 *  see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_group
 */
export function createIamGroup(tfgen: TF.Generator, rname: string, params: IamGroupParams): IamGroup {
  const fields = fieldsFromIamGroupParams(params);
  const resource = tfgen.createTypedResource('IamGroup', 'aws_iam_group', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const unique_id: string =  '${' + TF.resourceName(resource) + '.unique_id}';
  const arn: IamGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamGroup');

  return {
    ...resource,
    name,
    unique_id,
    arn,
  };
}

export interface IamGroup extends TF.ResourceT<'IamGroup'> {
  name: string;
  unique_id: string;
  arn: IamGroupArn;
}

export type IamGroupId = {type:'IamGroupId',value:string};
export type IamGroupArn = AT.ArnT<"IamGroup">;

/**
 *  Provides an IAM policy attached to a group.
 *
 *  see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_group_policy
 */
export function createIamGroupPolicy(tfgen: TF.Generator, rname: string, params: IamGroupPolicyParams): IamGroupPolicy {
  const fields = fieldsFromIamGroupPolicyParams(params);
  const resource = tfgen.createTypedResource('IamGroupPolicy', 'aws_iam_group_policy', rname, fields);

  return {
    ...resource,
  };
}

export interface IamGroupPolicy extends TF.ResourceT<'IamGroupPolicy'> {
}

export type IamGroupPolicyId = {type:'IamGroupPolicyId',value:string};

/**
 *  Provides an EC2 Container Registry Repository
 *
 *  see https://www.terraform.io/docs/providers/aws/r/ecr_repository.html
 */
export function createEcrRepository(tfgen: TF.Generator, rname: string, params: EcrRepositoryParams): EcrRepository {
  const fields = fieldsFromEcrRepositoryParams(params);
  const resource = tfgen.createTypedResource('EcrRepository', 'aws_ecr_repository', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const registry_id: string =  '${' + TF.resourceName(resource) + '.registry_id}';
  const repository_url: string =  '${' + TF.resourceName(resource) + '.repository_url}';
  const arn: EcrRepositoryArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'EcrRepository');

  return {
    ...resource,
    name,
    registry_id,
    repository_url,
    arn,
  };
}

export interface EcrRepository extends TF.ResourceT<'EcrRepository'> {
  name: string;
  registry_id: string;
  repository_url: string;
  arn: EcrRepositoryArn;
}

export type EcrRepositoryId = {type:'EcrRepositoryId',value:string};
export type EcrRepositoryArn = AT.ArnT<"EcrRepository">;

/**
 *  Provides an RDS DB subnet group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/db_subnet_group.html
 */
export function createDbSubnetGroup(tfgen: TF.Generator, rname: string, params: DbSubnetGroupParams): DbSubnetGroup {
  const fields = fieldsFromDbSubnetGroupParams(params);
  const resource = tfgen.createTypedResource('DbSubnetGroup', 'aws_db_subnet_group', rname, fields);
  const id: DbSubnetGroupId =  {type: 'DbSubnetGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: DbSubnetGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'DbSubnetGroup');

  return {
    ...resource,
    id,
    name,
    arn,
  };
}

export interface DbSubnetGroup extends TF.ResourceT<'DbSubnetGroup'> {
  id: DbSubnetGroupId;
  name: string;
  arn: DbSubnetGroupArn;
}

export type DbSubnetGroupId = {type:'DbSubnetGroupId',value:string};
export type DbSubnetGroupArn = AT.ArnT<"DbSubnetGroup">;

/**
 *  Provides a CloudWatch Metric Alarm resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudwatch_metric_alarm.html
 */
export function createCloudwatchMetricAlarm(tfgen: TF.Generator, rname: string, params: CloudwatchMetricAlarmParams): CloudwatchMetricAlarm {
  const fields = fieldsFromCloudwatchMetricAlarmParams(params);
  const resource = tfgen.createTypedResource('CloudwatchMetricAlarm', 'aws_cloudwatch_metric_alarm', rname, fields);
  const id: CloudwatchMetricAlarmId =  {type: 'CloudwatchMetricAlarmId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface CloudwatchMetricAlarm extends TF.ResourceT<'CloudwatchMetricAlarm'> {
  id: CloudwatchMetricAlarmId;
}

export type CloudwatchMetricAlarmId = {type:'CloudwatchMetricAlarmId',value:string};

/**
 *  Provides an IAM role.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_role.html
 */
export function createIamRole(tfgen: TF.Generator, rname: string, params: IamRoleParams): IamRole {
  const fields = fieldsFromIamRoleParams(params);
  const resource = tfgen.createTypedResource('IamRole', 'aws_iam_role', rname, fields);
  const id: IamRoleId =  {type: 'IamRoleId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const create_date: string =  '${' + TF.resourceName(resource) + '.create_date}';
  const unique_id: string =  '${' + TF.resourceName(resource) + '.unique_id}';
  const description: string =  '${' + TF.resourceName(resource) + '.description}';
  const arn: IamRoleArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamRole');

  return {
    ...resource,
    id,
    name,
    create_date,
    unique_id,
    description,
    arn,
  };
}

export interface IamRole extends TF.ResourceT<'IamRole'> {
  id: IamRoleId;
  name: string;
  create_date: string;
  unique_id: string;
  description: string;
  arn: IamRoleArn;
}

export type IamRoleId = {type:'IamRoleId',value:string};
export type IamRoleArn = AT.ArnT<"IamRole">;

/**
 *  Provides an IAM role policy
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_role_policy.html
 */
export function createIamRolePolicy(tfgen: TF.Generator, rname: string, params: IamRolePolicyParams): IamRolePolicy {
  const fields = fieldsFromIamRolePolicyParams(params);
  const resource = tfgen.createTypedResource('IamRolePolicy', 'aws_iam_role_policy', rname, fields);
  const id: string =  '${' + TF.resourceName(resource) + '.id}';
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const policy: string =  '${' + TF.resourceName(resource) + '.policy}';
  const role: string =  '${' + TF.resourceName(resource) + '.role}';

  return {
    ...resource,
    id,
    name,
    policy,
    role,
  };
}

export interface IamRolePolicy extends TF.ResourceT<'IamRolePolicy'> {
  id: string;
  name: string;
  policy: string;
  role: string;
}

export type IamRolePolicyId = {type:'IamRolePolicyId',value:string};

/**
 *  Provides an IAM policy.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_policy.html
 */
export function createIamPolicy(tfgen: TF.Generator, rname: string, params: IamPolicyParams): IamPolicy {
  const fields = fieldsFromIamPolicyParams(params);
  const resource = tfgen.createTypedResource('IamPolicy', 'aws_iam_policy', rname, fields);
  const id: IamPolicyId =  {type: 'IamPolicyId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: IamPolicyArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamPolicy');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface IamPolicy extends TF.ResourceT<'IamPolicy'> {
  id: IamPolicyId;
  arn: IamPolicyArn;
}

export type IamPolicyId = {type:'IamPolicyId',value:string};
export type IamPolicyArn = AT.ArnT<"IamPolicy">;

/**
 *  Attaches a Managed IAM Policy to an IAM role
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_role_policy_attachment.html
 */
export function createIamRolePolicyAttachment(tfgen: TF.Generator, rname: string, params: IamRolePolicyAttachmentParams): IamRolePolicyAttachment {
  const fields = fieldsFromIamRolePolicyAttachmentParams(params);
  const resource = tfgen.createTypedResource('IamRolePolicyAttachment', 'aws_iam_role_policy_attachment', rname, fields);

  return {
    ...resource,
  };
}

export interface IamRolePolicyAttachment extends TF.ResourceT<'IamRolePolicyAttachment'> {
}

export type IamRolePolicyAttachmentId = {type:'IamRolePolicyAttachmentId',value:string};

/**
 *  Provides an IAM instance profile.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/iam_instance_profile.html
 */
export function createIamInstanceProfile(tfgen: TF.Generator, rname: string, params: IamInstanceProfileParams): IamInstanceProfile {
  const fields = fieldsFromIamInstanceProfileParams(params);
  const resource = tfgen.createTypedResource('IamInstanceProfile', 'aws_iam_instance_profile', rname, fields);
  const id: IamInstanceProfileId =  {type: 'IamInstanceProfileId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const create_date: string =  '${' + TF.resourceName(resource) + '.create_date}';
  const unique_id: string =  '${' + TF.resourceName(resource) + '.unique_id}';
  const role: string =  '${' + TF.resourceName(resource) + '.role}';
  const arn: IamInstanceProfileArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'IamInstanceProfile');

  return {
    ...resource,
    id,
    name,
    create_date,
    unique_id,
    role,
    arn,
  };
}

export interface IamInstanceProfile extends TF.ResourceT<'IamInstanceProfile'> {
  id: IamInstanceProfileId;
  name: string;
  create_date: string;
  unique_id: string;
  role: string;
  arn: IamInstanceProfileArn;
}

export type IamInstanceProfileId = {type:'IamInstanceProfileId',value:string};
export type IamInstanceProfileArn = AT.ArnT<"IamInstanceProfile">;

/**
 *  Provides an SQS queue.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/sqs_queue.html
 */
export function createSqsQueue(tfgen: TF.Generator, rname: string, params: SqsQueueParams): SqsQueue {
  const fields = fieldsFromSqsQueueParams(params);
  const resource = tfgen.createTypedResource('SqsQueue', 'aws_sqs_queue', rname, fields);
  const id: SqsQueueId =  {type: 'SqsQueueId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: SqsQueueArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'SqsQueue');

  return {
    ...resource,
    id,
    name,
    arn,
  };
}

export interface SqsQueue extends TF.ResourceT<'SqsQueue'> {
  id: SqsQueueId;
  name: string;
  arn: SqsQueueArn;
}

export type SqsQueueId = {type:'SqsQueueId',value:string};
export type SqsQueueArn = AT.ArnT<"SqsQueue">;

/**
 *  Allows you to set a policy of an SQS Queue while referencing ARN of the queue within the policy.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/sqs_queue_policy.html
 */
export function createSqsQueuePolicy(tfgen: TF.Generator, rname: string, params: SqsQueuePolicyParams): SqsQueuePolicy {
  const fields = fieldsFromSqsQueuePolicyParams(params);
  const resource = tfgen.createTypedResource('SqsQueuePolicy', 'aws_sqs_queue_policy', rname, fields);

  return {
    ...resource,
  };
}

export interface SqsQueuePolicy extends TF.ResourceT<'SqsQueuePolicy'> {
}

export type SqsQueuePolicyId = {type:'SqsQueuePolicyId',value:string};

/**
 *  Provides a Load Balancer resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb.html
 */
export function createLb(tfgen: TF.Generator, rname: string, params: LbParams): Lb {
  const fields = fieldsFromLbParams(params);
  const resource = tfgen.createTypedResource('Lb', 'aws_lb', rname, fields);
  const id: LbId =  {type: 'LbId', value: '${' + TF.resourceName(resource) + '.id}'};
  const dns_name: string =  '${' + TF.resourceName(resource) + '.dns_name}';
  const zone_id: AT.HostedZoneId =  {type: 'HostedZoneId', value: '${' + TF.resourceName(resource) + '.zone_id}'};
  const arn: LbArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'Lb');

  return {
    ...resource,
    id,
    dns_name,
    zone_id,
    arn,
  };
}

export interface Lb extends TF.ResourceT<'Lb'> {
  id: LbId;
  dns_name: string;
  zone_id: AT.HostedZoneId;
  arn: LbArn;
}

export type LbId = {type:'LbId',value:string};
export type LbArn = AT.ArnT<"Lb">;

/**
 *  Provides a Load Balancer Listener resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_listener.html
 */
export function createLbListener(tfgen: TF.Generator, rname: string, params: LbListenerParams): LbListener {
  const fields = fieldsFromLbListenerParams(params);
  const resource = tfgen.createTypedResource('LbListener', 'aws_lb_listener', rname, fields);
  const id: LbListenerId =  {type: 'LbListenerId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: LbListenerArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LbListener');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface LbListener extends TF.ResourceT<'LbListener'> {
  id: LbListenerId;
  arn: LbListenerArn;
}

export type LbListenerId = {type:'LbListenerId',value:string};
export type LbListenerArn = AT.ArnT<"LbListener">;

/**
 *  The ACM certificate resource allows requesting and management of certificates from the Amazon Certificate Manager.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/acm_certificate.html
 */
export function createAcmCertificate(tfgen: TF.Generator, rname: string, params: AcmCertificateParams): AcmCertificate {
  const fields = fieldsFromAcmCertificateParams(params);
  const resource = tfgen.createTypedResource('AcmCertificate', 'aws_acm_certificate', rname, fields);
  const id: AcmCertificateId =  {type: 'AcmCertificateId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: AcmCertificateArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'AcmCertificate');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface AcmCertificate extends TF.ResourceT<'AcmCertificate'> {
  id: AcmCertificateId;
  arn: AcmCertificateArn;
}

export type AcmCertificateId = {type:'AcmCertificateId',value:string};
export type AcmCertificateArn = AT.ArnT<"AcmCertificate">;

/**
 *  This resource represents a successful validation of an ACM certificate in concert with other resources.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/acm_certificate.html
 */
export function createAcmCertificateValidation(tfgen: TF.Generator, rname: string, params: AcmCertificateValidationParams): AcmCertificateValidation {
  const fields = fieldsFromAcmCertificateValidationParams(params);
  const resource = tfgen.createTypedResource('AcmCertificateValidation', 'aws_acm_certificate_validation', rname, fields);

  return {
    ...resource,
  };
}

export interface AcmCertificateValidation extends TF.ResourceT<'AcmCertificateValidation'> {
}

export type AcmCertificateValidationId = {type:'AcmCertificateValidationId',value:string};

/**
 *  Provides a Load Balancer Listener Certificate resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_listener_certificate.html
 */
export function createLbListenerCertificate(tfgen: TF.Generator, rname: string, params: LbListenerCertificateParams): LbListenerCertificate {
  const fields = fieldsFromLbListenerCertificateParams(params);
  const resource = tfgen.createTypedResource('LbListenerCertificate', 'aws_lb_listener_certificate', rname, fields);
  const id: LbListenerCertificateId =  {type: 'LbListenerCertificateId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: LbListenerCertificateArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LbListenerCertificate');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface LbListenerCertificate extends TF.ResourceT<'LbListenerCertificate'> {
  id: LbListenerCertificateId;
  arn: LbListenerCertificateArn;
}

export type LbListenerCertificateId = {type:'LbListenerCertificateId',value:string};
export type LbListenerCertificateArn = AT.ArnT<"LbListenerCertificate">;

/**
 *  Provides a Target Group resource for use with Load Balancer resources.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_target_group.html
 */
export function createLbTargetGroup(tfgen: TF.Generator, rname: string, params: LbTargetGroupParams): LbTargetGroup {
  const fields = fieldsFromLbTargetGroupParams(params);
  const resource = tfgen.createTypedResource('LbTargetGroup', 'aws_lb_target_group', rname, fields);
  const id: LbTargetGroupId =  {type: 'LbTargetGroupId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn_suffix: string =  '${' + TF.resourceName(resource) + '.arn_suffix}';
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: LbTargetGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LbTargetGroup');

  return {
    ...resource,
    id,
    arn_suffix,
    name,
    arn,
  };
}

export interface LbTargetGroup extends TF.ResourceT<'LbTargetGroup'> {
  id: LbTargetGroupId;
  arn_suffix: string;
  name: string;
  arn: LbTargetGroupArn;
}

export type LbTargetGroupId = {type:'LbTargetGroupId',value:string};
export type LbTargetGroupArn = AT.ArnT<"LbTargetGroup">;

/**
 *  Provides the ability to register instances and containers with an Application Load Balancer (ALB) or Network Load Balancer (NLB) target group. 
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_target_group_attachment.html
 */
export function createLbTargetGroupAttachment(tfgen: TF.Generator, rname: string, params: LbTargetGroupAttachmentParams): LbTargetGroupAttachment {
  const fields = fieldsFromLbTargetGroupAttachmentParams(params);
  const resource = tfgen.createTypedResource('LbTargetGroupAttachment', 'aws_lb_target_group_attachment', rname, fields);
  const id: LbTargetGroupAttachmentId =  {type: 'LbTargetGroupAttachmentId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface LbTargetGroupAttachment extends TF.ResourceT<'LbTargetGroupAttachment'> {
  id: LbTargetGroupAttachmentId;
}

export type LbTargetGroupAttachmentId = {type:'LbTargetGroupAttachmentId',value:string};

/**
 *  Provides a Load Balancer Listener Rule resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lb_listener_rule.html
 */
export function createLbListenerRule(tfgen: TF.Generator, rname: string, params: LbListenerRuleParams): LbListenerRule {
  const fields = fieldsFromLbListenerRuleParams(params);
  const resource = tfgen.createTypedResource('LbListenerRule', 'aws_lb_listener_rule', rname, fields);
  const id: LbListenerRuleId =  {type: 'LbListenerRuleId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};

  return {
    ...resource,
    id,
    arn,
  };
}

export interface LbListenerRule extends TF.ResourceT<'LbListenerRule'> {
  id: LbListenerRuleId;
  arn: AT.Arn;
}

export type LbListenerRuleId = {type:'LbListenerRuleId',value:string};

/**
 *  Provides an elasticsearch cluster
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticsearch_domain.html
 */
export function createElasticsearchDomain(tfgen: TF.Generator, rname: string, params: ElasticsearchDomainParams): ElasticsearchDomain {
  const fields = fieldsFromElasticsearchDomainParams(params);
  const resource = tfgen.createTypedResource('ElasticsearchDomain', 'aws_elasticsearch_domain', rname, fields);
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};
  const domain_id: string =  '${' + TF.resourceName(resource) + '.domain_id}';
  const domain_name: string =  '${' + TF.resourceName(resource) + '.domain_name}';
  const endpoint: string =  '${' + TF.resourceName(resource) + '.endpoint}';

  return {
    ...resource,
    arn,
    domain_id,
    domain_name,
    endpoint,
  };
}

export interface ElasticsearchDomain extends TF.ResourceT<'ElasticsearchDomain'> {
  arn: AT.Arn;
  domain_id: string;
  domain_name: string;
  endpoint: string;
}

export type ElasticsearchDomainId = {type:'ElasticsearchDomainId',value:string};

/**
 *  Allows setting policy to an Elasticsearch domain while referencing domain attributes (e.g. ARN)
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticsearch_domain_policy.html
 */
export function createElasticsearchDomainPolicy(tfgen: TF.Generator, rname: string, params: ElasticsearchDomainPolicyParams): ElasticsearchDomainPolicy {
  const fields = fieldsFromElasticsearchDomainPolicyParams(params);
  const resource = tfgen.createTypedResource('ElasticsearchDomainPolicy', 'aws_elasticsearch_domain_policy', rname, fields);
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};

  return {
    ...resource,
    arn,
  };
}

export interface ElasticsearchDomainPolicy extends TF.ResourceT<'ElasticsearchDomainPolicy'> {
  arn: AT.Arn;
}

export type ElasticsearchDomainPolicyId = {type:'ElasticsearchDomainPolicyId',value:string};

/**
 *  Provides a CloudWatch Log Group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudwatch_log_group.html
 */
export function createCloudwatchLogGroup(tfgen: TF.Generator, rname: string, params: CloudwatchLogGroupParams): CloudwatchLogGroup {
  const fields = fieldsFromCloudwatchLogGroupParams(params);
  const resource = tfgen.createTypedResource('CloudwatchLogGroup', 'aws_cloudwatch_log_group', rname, fields);
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.arn}'};

  return {
    ...resource,
    arn,
  };
}

export interface CloudwatchLogGroup extends TF.ResourceT<'CloudwatchLogGroup'> {
  arn: AT.Arn;
}

export type CloudwatchLogGroupId = {type:'CloudwatchLogGroupId',value:string};

/**
 *  Provides aws_launch_configuration
 *
 *  see https://www.terraform.io/docs/providers/aws/r/launch_configuration.html
 */
export function createLaunchConfiguration(tfgen: TF.Generator, rname: string, params: LaunchConfigurationParams): LaunchConfiguration {
  const fields = fieldsFromLaunchConfigurationParams(params);
  const resource = tfgen.createTypedResource('LaunchConfiguration', 'aws_launch_configuration', rname, fields);
  const id: LaunchConfigurationId =  {type: 'LaunchConfigurationId', value: '${' + TF.resourceName(resource) + '.id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';

  return {
    ...resource,
    id,
    name,
  };
}

export interface LaunchConfiguration extends TF.ResourceT<'LaunchConfiguration'> {
  id: LaunchConfigurationId;
  name: string;
}

export type LaunchConfigurationId = {type:'LaunchConfigurationId',value:string};

/**
 *  Provides a Kinesis Firehose Delivery Stream resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/kinesis_firehose_delivery_stream.html
 */
export function createKinesisFirehoseDeliveryStream(tfgen: TF.Generator, rname: string, params: KinesisFirehoseDeliveryStreamParams): KinesisFirehoseDeliveryStream {
  const fields = fieldsFromKinesisFirehoseDeliveryStreamParams(params);
  const resource = tfgen.createTypedResource('KinesisFirehoseDeliveryStream', 'aws_kinesis_firehose_delivery_stream', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const arn: KinesisFirehoseDeliveryStreamArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'KinesisFirehoseDeliveryStream');

  return {
    ...resource,
    name,
    arn,
  };
}

export interface KinesisFirehoseDeliveryStream extends TF.ResourceT<'KinesisFirehoseDeliveryStream'> {
  name: string;
  arn: KinesisFirehoseDeliveryStreamArn;
}

export type KinesisFirehoseDeliveryStreamId = {type:'KinesisFirehoseDeliveryStreamId',value:string};
export type KinesisFirehoseDeliveryStreamArn = AT.ArnT<"KinesisFirehoseDeliveryStream">;

/**
 *  Provides a S3 bucket metrics configuration resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/s3_bucket_metric.html
 */
export function createS3BucketMetric(tfgen: TF.Generator, rname: string, params: S3BucketMetricParams): S3BucketMetric {
  const fields = fieldsFromS3BucketMetricParams(params);
  const resource = tfgen.createTypedResource('S3BucketMetric', 'aws_s3_bucket_metric', rname, fields);

  return {
    ...resource,
  };
}

export interface S3BucketMetric extends TF.ResourceT<'S3BucketMetric'> {
}

export type S3BucketMetricId = {type:'S3BucketMetricId',value:string};

/**
 *  Provides an ElastiCache parameter group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticache_parameter_group.html
 */
export function createElasticacheParameterGroup(tfgen: TF.Generator, rname: string, params: ElasticacheParameterGroupParams): ElasticacheParameterGroup {
  const fields = fieldsFromElasticacheParameterGroupParams(params);
  const resource = tfgen.createTypedResource('ElasticacheParameterGroup', 'aws_elasticache_parameter_group', rname, fields);
  const name: AT.ElasticacheParameterGroupName =  {type: 'ElasticacheParameterGroupName', value: '${' + TF.resourceName(resource) + '.name}'};
  const family: AT.ElasticacheParameterGroupFamily =  {type: 'ElasticacheParameterGroupFamily', value: '${' + TF.resourceName(resource) + '.family}'};
  const description: string =  '${' + TF.resourceName(resource) + '.description}';
  const arn: ElasticacheParameterGroupArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'ElasticacheParameterGroup');

  return {
    ...resource,
    name,
    family,
    description,
    arn,
  };
}

export interface ElasticacheParameterGroup extends TF.ResourceT<'ElasticacheParameterGroup'> {
  name: AT.ElasticacheParameterGroupName;
  family: AT.ElasticacheParameterGroupFamily;
  description: string;
  arn: ElasticacheParameterGroupArn;
}

export type ElasticacheParameterGroupId = {type:'ElasticacheParameterGroupId',value:string};
export type ElasticacheParameterGroupArn = AT.ArnT<"ElasticacheParameterGroup">;

/**
 *  Provides an ElastiCache Subnet Group resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticache_subnet_group.html
 */
export function createElasticacheSubnetGroup(tfgen: TF.Generator, rname: string, params: ElasticacheSubnetGroupParams): ElasticacheSubnetGroup {
  const fields = fieldsFromElasticacheSubnetGroupParams(params);
  const resource = tfgen.createTypedResource('ElasticacheSubnetGroup', 'aws_elasticache_subnet_group', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';

  return {
    ...resource,
    name,
  };
}

export interface ElasticacheSubnetGroup extends TF.ResourceT<'ElasticacheSubnetGroup'> {
  name: string;
}

export type ElasticacheSubnetGroupId = {type:'ElasticacheSubnetGroupId',value:string};

/**
 *  Provides an elasticache cluster resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/elasticache_cluster.html
 */
export function createElasticacheCluster(tfgen: TF.Generator, rname: string, params: ElasticacheClusterParams): ElasticacheCluster {
  const fields = fieldsFromElasticacheClusterParams(params);
  const resource = tfgen.createTypedResource('ElasticacheCluster', 'aws_elasticache_cluster', rname, fields);
  const cluster_id: string =  '${' + TF.resourceName(resource) + '.cluster_id}';
  const engine: string =  '${' + TF.resourceName(resource) + '.engine}';
  const node_type: string =  '${' + TF.resourceName(resource) + '.node_type}';
  const parameter_group_name: AT.ElasticacheParameterGroupName =  {type: 'ElasticacheParameterGroupName', value: '${' + TF.resourceName(resource) + '.parameter_group_name}'};
  const configuration_endpoint: string =  '${' + TF.resourceName(resource) + '.configuration_endpoint}';
  const cluster_address: string =  '${' + TF.resourceName(resource) + '.cluster_address}';
  const arn: ElasticacheClusterArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'ElasticacheCluster');

  return {
    ...resource,
    cluster_id,
    engine,
    node_type,
    parameter_group_name,
    configuration_endpoint,
    cluster_address,
    arn,
  };
}

export interface ElasticacheCluster extends TF.ResourceT<'ElasticacheCluster'> {
  cluster_id: string;
  engine: string;
  node_type: string;
  parameter_group_name: AT.ElasticacheParameterGroupName;
  configuration_endpoint: string;
  cluster_address: string;
  arn: ElasticacheClusterArn;
}

export type ElasticacheClusterId = {type:'ElasticacheClusterId',value:string};
export type ElasticacheClusterArn = AT.ArnT<"ElasticacheCluster">;

/**
 *  Provides information about a Lambda Function.
 *
 *  see https://www.terraform.io/docs/providers/aws/d/lambda_function.html
 */
export function createLambdaFunction(tfgen: TF.Generator, rname: string, params: LambdaFunctionParams): LambdaFunction {
  const fields = fieldsFromLambdaFunctionParams(params);
  const resource = tfgen.createTypedResource('LambdaFunction', 'aws_lambda_function', rname, fields);
  const function_name: string =  '${' + TF.resourceName(resource) + '.function_name}';
  const role: IamRoleId =  {type: 'IamRoleId', value: '${' + TF.resourceName(resource) + '.role}'};
  const arn: LambdaFunctionArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LambdaFunction');

  return {
    ...resource,
    function_name,
    role,
    arn,
  };
}

export interface LambdaFunction extends TF.ResourceT<'LambdaFunction'> {
  function_name: string;
  role: IamRoleId;
  arn: LambdaFunctionArn;
}

export type LambdaFunctionId = {type:'LambdaFunctionId',value:string};
export type LambdaFunctionArn = AT.ArnT<"LambdaFunction">;

/**
 *  Creates a Lambda permission to allow external sources invoking the Lambda function
    (e.g. CloudWatch Event Rule, SNS or S3).
 *
 *  see https://www.terraform.io/docs/providers/aws/r/lambda_permission.html
 */
export function createLambdaPermission(tfgen: TF.Generator, rname: string, params: LambdaPermissionParams): LambdaPermission {
  const fields = fieldsFromLambdaPermissionParams(params);
  const resource = tfgen.createTypedResource('LambdaPermission', 'aws_lambda_permission', rname, fields);
  const action: AT.LambdaPermissionAction =  {type: 'LambdaPermissionAction', value: '${' + TF.resourceName(resource) + '.action}'};
  const function_name: string =  '${' + TF.resourceName(resource) + '.function_name}';
  const principal: string =  '${' + TF.resourceName(resource) + '.principal}';
  const arn: LambdaPermissionArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'LambdaPermission');

  return {
    ...resource,
    action,
    function_name,
    principal,
    arn,
  };
}

export interface LambdaPermission extends TF.ResourceT<'LambdaPermission'> {
  action: AT.LambdaPermissionAction;
  function_name: string;
  principal: string;
  arn: LambdaPermissionArn;
}

export type LambdaPermissionId = {type:'LambdaPermissionId',value:string};
export type LambdaPermissionArn = AT.ArnT<"LambdaPermission">;

/**
 *  Provides a CloudWatch Event Rule resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudwatch_event_rule.html
 */
export function createCloudwatchEventRule(tfgen: TF.Generator, rname: string, params: CloudwatchEventRuleParams): CloudwatchEventRule {
  const fields = fieldsFromCloudwatchEventRuleParams(params);
  const resource = tfgen.createTypedResource('CloudwatchEventRule', 'aws_cloudwatch_event_rule', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const schedule_expression: string =  '${' + TF.resourceName(resource) + '.schedule_expression}';
  const description: string =  '${' + TF.resourceName(resource) + '.description}';
  const arn: CloudwatchEventRuleArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'CloudwatchEventRule');

  return {
    ...resource,
    name,
    schedule_expression,
    description,
    arn,
  };
}

export interface CloudwatchEventRule extends TF.ResourceT<'CloudwatchEventRule'> {
  name: string;
  schedule_expression: string;
  description: string;
  arn: CloudwatchEventRuleArn;
}

export type CloudwatchEventRuleId = {type:'CloudwatchEventRuleId',value:string};
export type CloudwatchEventRuleArn = AT.ArnT<"CloudwatchEventRule">;

/**
 *  Provides a CloudWatch Event Target resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudwatch_event_target.html
 */
export function createCloudwatchEventTarget(tfgen: TF.Generator, rname: string, params: CloudwatchEventTargetParams): CloudwatchEventTarget {
  const fields = fieldsFromCloudwatchEventTargetParams(params);
  const resource = tfgen.createTypedResource('CloudwatchEventTarget', 'aws_cloudwatch_event_target', rname, fields);
  const arn: CloudwatchEventTargetArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'CloudwatchEventTarget');

  return {
    ...resource,
    arn,
  };
}

export interface CloudwatchEventTarget extends TF.ResourceT<'CloudwatchEventTarget'> {
  arn: CloudwatchEventTargetArn;
}

export type CloudwatchEventTargetId = {type:'CloudwatchEventTargetId',value:string};
export type CloudwatchEventTargetArn = AT.ArnT<"CloudwatchEventTarget">;

/**
 *  Provides a WAF Byte Match Set Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/waf_byte_match_set.html
 */
export function createWafByteMatchSet(tfgen: TF.Generator, rname: string, params: WafByteMatchSetParams): WafByteMatchSet {
  const fields = fieldsFromWafByteMatchSetParams(params);
  const resource = tfgen.createTypedResource('WafByteMatchSet', 'aws_waf_byte_match_set', rname, fields);
  const id: WafByteMatchSetId =  {type: 'WafByteMatchSetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafByteMatchSet extends TF.ResourceT<'WafByteMatchSet'> {
  id: WafByteMatchSetId;
}

export type WafByteMatchSetId = {type:'WafByteMatchSetId',value:string};

/**
 *  Provides a WAF IPSet Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/waf_ipset.html
 */
export function createWafIpset(tfgen: TF.Generator, rname: string, params: WafIpsetParams): WafIpset {
  const fields = fieldsFromWafIpsetParams(params);
  const resource = tfgen.createTypedResource('WafIpset', 'aws_waf_ipset', rname, fields);
  const id: WafIpsetId =  {type: 'WafIpsetId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: WafIpsetArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'WafIpset');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface WafIpset extends TF.ResourceT<'WafIpset'> {
  id: WafIpsetId;
  arn: WafIpsetArn;
}

export type WafIpsetId = {type:'WafIpsetId',value:string};
export type WafIpsetArn = AT.ArnT<"WafIpset">;

/**
 *  Provides a WAF Regional Regex Match Set Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_regex_match_set.html
 */
export function createWafregionalRegexMatchSet(tfgen: TF.Generator, rname: string, params: WafregionalRegexMatchSetParams): WafregionalRegexMatchSet {
  const fields = fieldsFromWafregionalRegexMatchSetParams(params);
  const resource = tfgen.createTypedResource('WafregionalRegexMatchSet', 'aws_wafregional_regex_match_set', rname, fields);
  const id: WafregionalRegexMatchSetId =  {type: 'WafregionalRegexMatchSetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalRegexMatchSet extends TF.ResourceT<'WafregionalRegexMatchSet'> {
  id: WafregionalRegexMatchSetId;
}

export type WafregionalRegexMatchSetId = {type:'WafregionalRegexMatchSetId',value:string};

/**
 *  Provides a WAF Regional Regex Pattern Set Resource
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_regex_pattern_set.html
 */
export function createWafregionalRegexPatternSet(tfgen: TF.Generator, rname: string, params: WafregionalRegexPatternSetParams): WafregionalRegexPatternSet {
  const fields = fieldsFromWafregionalRegexPatternSetParams(params);
  const resource = tfgen.createTypedResource('WafregionalRegexPatternSet', 'aws_wafregional_regex_pattern_set', rname, fields);
  const id: WafregionalRegexPatternSetId =  {type: 'WafregionalRegexPatternSetId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalRegexPatternSet extends TF.ResourceT<'WafregionalRegexPatternSet'> {
  id: WafregionalRegexPatternSetId;
}

export type WafregionalRegexPatternSetId = {type:'WafregionalRegexPatternSetId',value:string};

/**
 *  Provides a WAF Regional IPSet Resource for use with Application Load Balancer.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_ipset.html
 */
export function createWafregionalIpset(tfgen: TF.Generator, rname: string, params: WafregionalIpsetParams): WafregionalIpset {
  const fields = fieldsFromWafregionalIpsetParams(params);
  const resource = tfgen.createTypedResource('WafregionalIpset', 'aws_wafregional_ipset', rname, fields);
  const id: WafregionalIpsetId =  {type: 'WafregionalIpsetId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: WafregionalIpsetArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'WafregionalIpset');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface WafregionalIpset extends TF.ResourceT<'WafregionalIpset'> {
  id: WafregionalIpsetId;
  arn: WafregionalIpsetArn;
}

export type WafregionalIpsetId = {type:'WafregionalIpsetId',value:string};
export type WafregionalIpsetArn = AT.ArnT<"WafregionalIpset">;

/**
 *  Provides an WAF Regional Rule Resource for use with Application Load Balancer.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_rule.html
 */
export function createWafregionalRule(tfgen: TF.Generator, rname: string, params: WafregionalRuleParams): WafregionalRule {
  const fields = fieldsFromWafregionalRuleParams(params);
  const resource = tfgen.createTypedResource('WafregionalRule', 'aws_wafregional_rule', rname, fields);
  const id: WafregionalRuleId =  {type: 'WafregionalRuleId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalRule extends TF.ResourceT<'WafregionalRule'> {
  id: WafregionalRuleId;
}

export type WafregionalRuleId = {type:'WafregionalRuleId',value:string};

/**
 *  Provides a WAF Regional Web ACL Resource for use with Application Load Balancer.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_web_acl.html
 */
export function createWafregionalWebAcl(tfgen: TF.Generator, rname: string, params: WafregionalWebAclParams): WafregionalWebAcl {
  const fields = fieldsFromWafregionalWebAclParams(params);
  const resource = tfgen.createTypedResource('WafregionalWebAcl', 'aws_wafregional_web_acl', rname, fields);
  const id: WafregionalWebAclId =  {type: 'WafregionalWebAclId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalWebAcl extends TF.ResourceT<'WafregionalWebAcl'> {
  id: WafregionalWebAclId;
}

export type WafregionalWebAclId = {type:'WafregionalWebAclId',value:string};

/**
 *  Provides a resource to create an association between a WAF Regional WebACL and Application Load Balancer.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/wafregional_web_acl_association.html
 */
export function createWafregionalWebAclAssociation(tfgen: TF.Generator, rname: string, params: WafregionalWebAclAssociationParams): WafregionalWebAclAssociation {
  const fields = fieldsFromWafregionalWebAclAssociationParams(params);
  const resource = tfgen.createTypedResource('WafregionalWebAclAssociation', 'aws_wafregional_web_acl_association', rname, fields);
  const id: WafregionalWebAclAssociationId =  {type: 'WafregionalWebAclAssociationId', value: '${' + TF.resourceName(resource) + '.id}'};

  return {
    ...resource,
    id,
  };
}

export interface WafregionalWebAclAssociation extends TF.ResourceT<'WafregionalWebAclAssociation'> {
  id: WafregionalWebAclAssociationId;
}

export type WafregionalWebAclAssociationId = {type:'WafregionalWebAclAssociationId',value:string};

/**
 *  Provides a resource to manage AWS Secrets Manager secret metadata.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/secretsmanager_secret.html
 */
export function createSecretsmanagerSecret(tfgen: TF.Generator, rname: string, params: SecretsmanagerSecretParams): SecretsmanagerSecret {
  const fields = fieldsFromSecretsmanagerSecretParams(params);
  const resource = tfgen.createTypedResource('SecretsmanagerSecret', 'aws_secretsmanager_secret', rname, fields);
  const id: SecretsmanagerSecretId =  {type: 'SecretsmanagerSecretId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: SecretsmanagerSecretArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'SecretsmanagerSecret');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface SecretsmanagerSecret extends TF.ResourceT<'SecretsmanagerSecret'> {
  id: SecretsmanagerSecretId;
  arn: SecretsmanagerSecretArn;
}

export type SecretsmanagerSecretId = {type:'SecretsmanagerSecretId',value:string};
export type SecretsmanagerSecretArn = AT.ArnT<"SecretsmanagerSecret">;

/**
 *  Provides a resource to manage AWS Secrets Manager secret version including its secret value.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/secretsmanager_secret_version.html
 */
export function createSecretsmanagerSecretVersion(tfgen: TF.Generator, rname: string, params: SecretsmanagerSecretVersionParams): SecretsmanagerSecretVersion {
  const fields = fieldsFromSecretsmanagerSecretVersionParams(params);
  const resource = tfgen.createTypedResource('SecretsmanagerSecretVersion', 'aws_secretsmanager_secret_version', rname, fields);
  const id: SecretsmanagerSecretId =  {type: 'SecretsmanagerSecretId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: SecretsmanagerSecretVersionArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'SecretsmanagerSecretVersion');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface SecretsmanagerSecretVersion extends TF.ResourceT<'SecretsmanagerSecretVersion'> {
  id: SecretsmanagerSecretId;
  arn: SecretsmanagerSecretVersionArn;
}

export type SecretsmanagerSecretVersionId = {type:'SecretsmanagerSecretVersionId',value:string};
export type SecretsmanagerSecretVersionArn = AT.ArnT<"SecretsmanagerSecretVersion">;

/**
 *  Creates an Amazon CloudFront web distribution.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cloudfront_distribution.html
 */
export function createCloudfrontDistribution(tfgen: TF.Generator, rname: string, params: CloudfrontDistributionParams): CloudfrontDistribution {
  const fields = fieldsFromCloudfrontDistributionParams(params);
  const resource = tfgen.createTypedResource('CloudfrontDistribution', 'aws_cloudfront_distribution', rname, fields);
  const id: CloudfrontDistributionId =  {type: 'CloudfrontDistributionId', value: '${' + TF.resourceName(resource) + '.id}'};
  const domain_name: string =  '${' + TF.resourceName(resource) + '.domain_name}';
  const hosted_zone_id: AT.HostedZoneId =  {type: 'HostedZoneId', value: '${' + TF.resourceName(resource) + '.hosted_zone_id}'};
  const arn: CloudfrontDistributionArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'CloudfrontDistribution');

  return {
    ...resource,
    id,
    domain_name,
    hosted_zone_id,
    arn,
  };
}

export interface CloudfrontDistribution extends TF.ResourceT<'CloudfrontDistribution'> {
  id: CloudfrontDistributionId;
  domain_name: string;
  hosted_zone_id: AT.HostedZoneId;
  arn: CloudfrontDistributionArn;
}

export type CloudfrontDistributionId = {type:'CloudfrontDistributionId',value:string};
export type CloudfrontDistributionArn = AT.ArnT<"CloudfrontDistribution">;

/**
 *  Provides an API Gateway REST API.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_rest_api.html
 */
export function createApiGatewayRestApi(tfgen: TF.Generator, rname: string, params: ApiGatewayRestApiParams): ApiGatewayRestApi {
  const fields = fieldsFromApiGatewayRestApiParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayRestApi', 'aws_api_gateway_rest_api', rname, fields);
  const id: ApiGatewayRestApiId =  {type: 'ApiGatewayRestApiId', value: '${' + TF.resourceName(resource) + '.id}'};
  const root_resource_id: ApiGatewayRestApiId =  {type: 'ApiGatewayRestApiId', value: '${' + TF.resourceName(resource) + '.root_resource_id}'};

  return {
    ...resource,
    id,
    root_resource_id,
  };
}

export interface ApiGatewayRestApi extends TF.ResourceT<'ApiGatewayRestApi'> {
  id: ApiGatewayRestApiId;
  root_resource_id: ApiGatewayRestApiId;
}

export type ApiGatewayRestApiId = {type:'ApiGatewayRestApiId',value:string};

/**
 *  Provides an API Gateway Resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_resource.html
 */
export function createApiGatewayResource(tfgen: TF.Generator, rname: string, params: ApiGatewayResourceParams): ApiGatewayResource {
  const fields = fieldsFromApiGatewayResourceParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayResource', 'aws_api_gateway_resource', rname, fields);
  const id: ApiGatewayResourceId =  {type: 'ApiGatewayResourceId', value: '${' + TF.resourceName(resource) + '.id}'};
  const path: string =  '${' + TF.resourceName(resource) + '.path}';

  return {
    ...resource,
    id,
    path,
  };
}

export interface ApiGatewayResource extends TF.ResourceT<'ApiGatewayResource'> {
  id: ApiGatewayResourceId;
  path: string;
}

export type ApiGatewayResourceId = {type:'ApiGatewayResourceId',value:string};

/**
 *  Provides a HTTP Method for an API Gateway Resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_method.html
 */
export function createApiGatewayMethod(tfgen: TF.Generator, rname: string, params: ApiGatewayMethodParams): ApiGatewayMethod {
  const fields = fieldsFromApiGatewayMethodParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayMethod', 'aws_api_gateway_method', rname, fields);

  return {
    ...resource,
  };
}

export interface ApiGatewayMethod extends TF.ResourceT<'ApiGatewayMethod'> {
}

export type ApiGatewayMethodId = {type:'ApiGatewayMethodId',value:string};

/**
 *  Provides an HTTP Method Response for an API Gateway Resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_method_response.html
 */
export function createApiGatewayMethodResponse(tfgen: TF.Generator, rname: string, params: ApiGatewayMethodResponseParams): ApiGatewayMethodResponse {
  const fields = fieldsFromApiGatewayMethodResponseParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayMethodResponse', 'aws_api_gateway_method_response', rname, fields);

  return {
    ...resource,
  };
}

export interface ApiGatewayMethodResponse extends TF.ResourceT<'ApiGatewayMethodResponse'> {
}

export type ApiGatewayMethodResponseId = {type:'ApiGatewayMethodResponseId',value:string};

/**
 *  Provides an HTTP Method Integration for an API Gateway Integration.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_integration.html
 */
export function createApiGatewayIntegration(tfgen: TF.Generator, rname: string, params: ApiGatewayIntegrationParams): ApiGatewayIntegration {
  const fields = fieldsFromApiGatewayIntegrationParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayIntegration', 'aws_api_gateway_integration', rname, fields);

  return {
    ...resource,
  };
}

export interface ApiGatewayIntegration extends TF.ResourceT<'ApiGatewayIntegration'> {
}

export type ApiGatewayIntegrationId = {type:'ApiGatewayIntegrationId',value:string};

/**
 *  Provides an HTTP Method Integration Response for an API Gateway Resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_integration_response.html
 */
export function createApiGatewayIntegrationResponse(tfgen: TF.Generator, rname: string, params: ApiGatewayIntegrationResponseParams): ApiGatewayIntegrationResponse {
  const fields = fieldsFromApiGatewayIntegrationResponseParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayIntegrationResponse', 'aws_api_gateway_integration_response', rname, fields);

  return {
    ...resource,
  };
}

export interface ApiGatewayIntegrationResponse extends TF.ResourceT<'ApiGatewayIntegrationResponse'> {
}

export type ApiGatewayIntegrationResponseId = {type:'ApiGatewayIntegrationResponseId',value:string};

/**
 *  Provides an API Gateway Deployment.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_deployment.html
 */
export function createApiGatewayDeployment(tfgen: TF.Generator, rname: string, params: ApiGatewayDeploymentParams): ApiGatewayDeployment {
  const fields = fieldsFromApiGatewayDeploymentParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayDeployment', 'aws_api_gateway_deployment', rname, fields);
  const id: ApiGatewayDeploymentId =  {type: 'ApiGatewayDeploymentId', value: '${' + TF.resourceName(resource) + '.id}'};
  const invoke_url: string =  '${' + TF.resourceName(resource) + '.invoke_url}';
  const execution_arn: AT.Arn =  {type: 'Arn', value: '${' + TF.resourceName(resource) + '.execution_arn}'};

  return {
    ...resource,
    id,
    invoke_url,
    execution_arn,
  };
}

export interface ApiGatewayDeployment extends TF.ResourceT<'ApiGatewayDeployment'> {
  id: ApiGatewayDeploymentId;
  invoke_url: string;
  execution_arn: AT.Arn;
}

export type ApiGatewayDeploymentId = {type:'ApiGatewayDeploymentId',value:string};

/**
 *  Registers a custom domain name for use with AWS API Gateway.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_domain_name.html
 */
export function createApiGatewayDomainName(tfgen: TF.Generator, rname: string, params: ApiGatewayDomainNameParams): ApiGatewayDomainName {
  const fields = fieldsFromApiGatewayDomainNameParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayDomainName', 'aws_api_gateway_domain_name', rname, fields);
  const id: ApiGatewayDomainNameId =  {type: 'ApiGatewayDomainNameId', value: '${' + TF.resourceName(resource) + '.id}'};
  const cloudfront_domain_name: string =  '${' + TF.resourceName(resource) + '.cloudfront_domain_name}';
  const cloudfront_zone_id: AT.HostedZoneId =  {type: 'HostedZoneId', value: '${' + TF.resourceName(resource) + '.cloudfront_zone_id}'};

  return {
    ...resource,
    id,
    cloudfront_domain_name,
    cloudfront_zone_id,
  };
}

export interface ApiGatewayDomainName extends TF.ResourceT<'ApiGatewayDomainName'> {
  id: ApiGatewayDomainNameId;
  cloudfront_domain_name: string;
  cloudfront_zone_id: AT.HostedZoneId;
}

export type ApiGatewayDomainNameId = {type:'ApiGatewayDomainNameId',value:string};

/**
 *  Connects a custom domain name registered via aws_api_gateway_domain_name with a deployed API
 *
 *  see https://www.terraform.io/docs/providers/aws/r/api_gateway_base_path_mapping.html
 */
export function createApiGatewayBasePathMapping(tfgen: TF.Generator, rname: string, params: ApiGatewayBasePathMappingParams): ApiGatewayBasePathMapping {
  const fields = fieldsFromApiGatewayBasePathMappingParams(params);
  const resource = tfgen.createTypedResource('ApiGatewayBasePathMapping', 'aws_api_gateway_base_path_mapping', rname, fields);

  return {
    ...resource,
  };
}

export interface ApiGatewayBasePathMapping extends TF.ResourceT<'ApiGatewayBasePathMapping'> {
}

export type ApiGatewayBasePathMappingId = {type:'ApiGatewayBasePathMappingId',value:string};

/**
 *  Manages a S3 Bucket Notification Configuration.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/s3_bucket_notification.html
 */
export function createS3BucketNotification(tfgen: TF.Generator, rname: string, params: S3BucketNotificationParams): S3BucketNotification {
  const fields = fieldsFromS3BucketNotificationParams(params);
  const resource = tfgen.createTypedResource('S3BucketNotification', 'aws_s3_bucket_notification', rname, fields);

  return {
    ...resource,
  };
}

export interface S3BucketNotification extends TF.ResourceT<'S3BucketNotification'> {
}

export type S3BucketNotificationId = {type:'S3BucketNotificationId',value:string};

/**
 *  Provides a Cognito User Pool resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cognito_user_pool.html
 */
export function createCognitoUserPool(tfgen: TF.Generator, rname: string, params: CognitoUserPoolParams): CognitoUserPool {
  const fields = fieldsFromCognitoUserPoolParams(params);
  const resource = tfgen.createTypedResource('CognitoUserPool', 'aws_cognito_user_pool', rname, fields);
  const id: CognitoUserPoolId =  {type: 'CognitoUserPoolId', value: '${' + TF.resourceName(resource) + '.id}'};
  const endpoint: string =  '${' + TF.resourceName(resource) + '.endpoint}';
  const arn: CognitoUserPoolArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'CognitoUserPool');

  return {
    ...resource,
    id,
    endpoint,
    arn,
  };
}

export interface CognitoUserPool extends TF.ResourceT<'CognitoUserPool'> {
  id: CognitoUserPoolId;
  endpoint: string;
  arn: CognitoUserPoolArn;
}

export type CognitoUserPoolId = {type:'CognitoUserPoolId',value:string};
export type CognitoUserPoolArn = AT.ArnT<"CognitoUserPool">;

/**
 *  Provides a Cognito User Pool Client resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cognito_user_pool_client.html
 */
export function createCognitoUserPoolClient(tfgen: TF.Generator, rname: string, params: CognitoUserPoolClientParams): CognitoUserPoolClient {
  const fields = fieldsFromCognitoUserPoolClientParams(params);
  const resource = tfgen.createTypedResource('CognitoUserPoolClient', 'aws_cognito_user_pool_client', rname, fields);
  const id: CognitoUserPoolId =  {type: 'CognitoUserPoolId', value: '${' + TF.resourceName(resource) + '.id}'};
  const client_secret: string =  '${' + TF.resourceName(resource) + '.client_secret}';
  const arn: CognitoUserPoolClientArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'CognitoUserPoolClient');

  return {
    ...resource,
    id,
    client_secret,
    arn,
  };
}

export interface CognitoUserPoolClient extends TF.ResourceT<'CognitoUserPoolClient'> {
  id: CognitoUserPoolId;
  client_secret: string;
  arn: CognitoUserPoolClientArn;
}

export type CognitoUserPoolClientId = {type:'CognitoUserPoolClientId',value:string};
export type CognitoUserPoolClientArn = AT.ArnT<"CognitoUserPoolClient">;

/**
 *  Provides a Cognito User Pool Domain resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cognito_user_pool_domain.html
 */
export function createCognitoUserPoolDomain(tfgen: TF.Generator, rname: string, params: CognitoUserPoolDomainParams): CognitoUserPoolDomain {
  const fields = fieldsFromCognitoUserPoolDomainParams(params);
  const resource = tfgen.createTypedResource('CognitoUserPoolDomain', 'aws_cognito_user_pool_domain', rname, fields);

  return {
    ...resource,
  };
}

export interface CognitoUserPoolDomain extends TF.ResourceT<'CognitoUserPoolDomain'> {
}

export type CognitoUserPoolDomainId = {type:'CognitoUserPoolDomainId',value:string};

/**
 *  Provides an AWS Cognito Identity Pool.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cognito_identity_pool.html
 */
export function createCognitoIdentityPool(tfgen: TF.Generator, rname: string, params: CognitoIdentityPoolParams): CognitoIdentityPool {
  const fields = fieldsFromCognitoIdentityPoolParams(params);
  const resource = tfgen.createTypedResource('CognitoIdentityPool', 'aws_cognito_identity_pool', rname, fields);
  const id: CognitoIdentityPoolId =  {type: 'CognitoIdentityPoolId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: CognitoIdentityPoolArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'CognitoIdentityPool');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface CognitoIdentityPool extends TF.ResourceT<'CognitoIdentityPool'> {
  id: CognitoIdentityPoolId;
  arn: CognitoIdentityPoolArn;
}

export type CognitoIdentityPoolId = {type:'CognitoIdentityPoolId',value:string};
export type CognitoIdentityPoolArn = AT.ArnT<"CognitoIdentityPool">;

/**
 *  Provides an AWS Cognito Identity Pool Roles Attachment.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/cognito_identity_pool_roles_attachment.html
 */
export function createCognitoIdentityPoolRolesAttachment(tfgen: TF.Generator, rname: string, params: CognitoIdentityPoolRolesAttachmentParams): CognitoIdentityPoolRolesAttachment {
  const fields = fieldsFromCognitoIdentityPoolRolesAttachmentParams(params);
  const resource = tfgen.createTypedResource('CognitoIdentityPoolRolesAttachment', 'aws_cognito_identity_pool_roles_attachment', rname, fields);

  return {
    ...resource,
  };
}

export interface CognitoIdentityPoolRolesAttachment extends TF.ResourceT<'CognitoIdentityPoolRolesAttachment'> {
}

export type CognitoIdentityPoolRolesAttachmentId = {type:'CognitoIdentityPoolRolesAttachmentId',value:string};

/**
 *  Manages an EKS Cluster.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/eks_cluster.html
 */
export function createEksCluster(tfgen: TF.Generator, rname: string, params: EksClusterParams): EksCluster {
  const fields = fieldsFromEksClusterParams(params);
  const resource = tfgen.createTypedResource('EksCluster', 'aws_eks_cluster', rname, fields);
  const id: EksClusterId =  {type: 'EksClusterId', value: '${' + TF.resourceName(resource) + '.id}'};
  const endpoint: string =  '${' + TF.resourceName(resource) + '.endpoint}';
  const platform_version: string =  '${' + TF.resourceName(resource) + '.platform_version}';
  const status: string =  '${' + TF.resourceName(resource) + '.status}';
  const version: string =  '${' + TF.resourceName(resource) + '.version}';
  const certificate_authority: string =  '${' + TF.resourceName(resource) + '.certificate_authority}';
  const arn: EksClusterArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'EksCluster');

  return {
    ...resource,
    id,
    endpoint,
    platform_version,
    status,
    version,
    certificate_authority,
    arn,
  };
}

export interface EksCluster extends TF.ResourceT<'EksCluster'> {
  id: EksClusterId;
  endpoint: string;
  platform_version: string;
  status: string;
  version: string;
  certificate_authority: string;
  arn: EksClusterArn;
}

export type EksClusterId = {type:'EksClusterId',value:string};
export type EksClusterArn = AT.ArnT<"EksCluster">;

/**
 *  Creates a AWS Batch compute environment. Compute environments contain the Amazon ECS container instances that are used to run containerized batch jobs
 *
 *  see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/batch_compute_environment
 */
export function createBatchComputeEnvironment(tfgen: TF.Generator, rname: string, params: BatchComputeEnvironmentParams): BatchComputeEnvironment {
  const fields = fieldsFromBatchComputeEnvironmentParams(params);
  const resource = tfgen.createTypedResource('BatchComputeEnvironment', 'aws_batch_compute_environment', rname, fields);
  const id: BatchComputeEnvironmentId =  {type: 'BatchComputeEnvironmentId', value: '${' + TF.resourceName(resource) + '.id}'};
  const status: string =  '${' + TF.resourceName(resource) + '.status}';
  const status_reason: string =  '${' + TF.resourceName(resource) + '.status_reason}';
  const arn: BatchComputeEnvironmentArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'BatchComputeEnvironment');

  return {
    ...resource,
    id,
    status,
    status_reason,
    arn,
  };
}

export interface BatchComputeEnvironment extends TF.ResourceT<'BatchComputeEnvironment'> {
  id: BatchComputeEnvironmentId;
  status: string;
  status_reason: string;
  arn: BatchComputeEnvironmentArn;
}

export type BatchComputeEnvironmentId = {type:'BatchComputeEnvironmentId',value:string};
export type BatchComputeEnvironmentArn = AT.ArnT<"BatchComputeEnvironment">;

/**
 *  Provides a Batch Job Definition resource.
 *
 *  see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/batch_job_definition
 */
export function createBatchJobDefinition(tfgen: TF.Generator, rname: string, params: BatchJobDefinitionParams): BatchJobDefinition {
  const fields = fieldsFromBatchJobDefinitionParams(params);
  const resource = tfgen.createTypedResource('BatchJobDefinition', 'aws_batch_job_definition', rname, fields);
  const id: BatchJobDefinitionId =  {type: 'BatchJobDefinitionId', value: '${' + TF.resourceName(resource) + '.id}'};
  const revision: string =  '${' + TF.resourceName(resource) + '.revision}';
  const arn: BatchJobDefinitionArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'BatchJobDefinition');

  return {
    ...resource,
    id,
    revision,
    arn,
  };
}

export interface BatchJobDefinition extends TF.ResourceT<'BatchJobDefinition'> {
  id: BatchJobDefinitionId;
  revision: string;
  arn: BatchJobDefinitionArn;
}

export type BatchJobDefinitionId = {type:'BatchJobDefinitionId',value:string};
export type BatchJobDefinitionArn = AT.ArnT<"BatchJobDefinition">;

/**
 *  Provides a Batch Job Queue resource.
 *
 *  see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/batch_job_queue
 */
export function createBatchJobQueue(tfgen: TF.Generator, rname: string, params: BatchJobQueueParams): BatchJobQueue {
  const fields = fieldsFromBatchJobQueueParams(params);
  const resource = tfgen.createTypedResource('BatchJobQueue', 'aws_batch_job_queue', rname, fields);
  const id: BatchJobQueueId =  {type: 'BatchJobQueueId', value: '${' + TF.resourceName(resource) + '.id}'};
  const arn: BatchJobQueueArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'BatchJobQueue');

  return {
    ...resource,
    id,
    arn,
  };
}

export interface BatchJobQueue extends TF.ResourceT<'BatchJobQueue'> {
  id: BatchJobQueueId;
  arn: BatchJobQueueArn;
}

export type BatchJobQueueId = {type:'BatchJobQueueId',value:string};
export type BatchJobQueueArn = AT.ArnT<"BatchJobQueue">;

export interface AutoscalingGroupTagParams {
  key: string;
  value: string;
  propagate_at_launch: boolean;
}

export function fieldsFromAutoscalingGroupTagParams(params: AutoscalingGroupTagParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "key", params.key, TF.stringValue);
  TF.addField(fields, "value", params.value, TF.stringValue);
  TF.addField(fields, "propagate_at_launch", params.propagate_at_launch, TF.booleanValue);
  return fields;
}

export interface AutoscalingGroupParams {
  name?: string;
  name_prefix?: string;
  min_size: number;
  desired_capacity?: number;
  max_size: number;
  vpc_zone_identifier?: (SubnetId)[];
  launch_configuration: string;
  load_balancers?: (string)[];
  enabled_metrics?: ('GroupMinSize' | 'GroupMaxSize' | 'GroupDesiredCapacity' | 'GroupInServiceInstances' | 'GroupPendingInstances' | 'GroupStandbyInstances' | 'GroupTerminatingInstances' | 'GroupTotalInstances')[];
  tags?: (AutoscalingGroupTagParams)[];
  termination_policies?: ('OldestInstance' | 'NewestInstance' | 'OldestLaunchConfiguration' | 'ClosestToNextInstanceHour' | 'OldestLaunchTemplate' | 'AllocationStrategy' | 'Default')[];
}

export function fieldsFromAutoscalingGroupParams(params: AutoscalingGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "min_size", params.min_size, TF.numberValue);
  TF.addOptionalField(fields, "desired_capacity", params.desired_capacity, TF.numberValue);
  TF.addField(fields, "max_size", params.max_size, TF.numberValue);
  TF.addOptionalField(fields, "vpc_zone_identifier", params.vpc_zone_identifier, TF.listValue(TF.resourceIdValue));
  TF.addField(fields, "launch_configuration", params.launch_configuration, TF.stringValue);
  TF.addOptionalField(fields, "load_balancers", params.load_balancers, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "enabled_metrics", params.enabled_metrics, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.listValue((v) => TF.mapValue(fieldsFromAutoscalingGroupTagParams(v))));
  TF.addOptionalField(fields, "termination_policies", params.termination_policies, TF.listValue(TF.stringValue));
  return fields;
}

export interface AutoscalingScheduleParams {
  autoscaling_group_name: string;
  scheduled_action_name: string;
  start_time?: string;
  end_time?: string;
  recurrence?: string;
  min_size?: number;
  max_size?: number;
  desired_capacity?: number;
}

export function fieldsFromAutoscalingScheduleParams(params: AutoscalingScheduleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "autoscaling_group_name", params.autoscaling_group_name, TF.stringValue);
  TF.addField(fields, "scheduled_action_name", params.scheduled_action_name, TF.stringValue);
  TF.addOptionalField(fields, "start_time", params.start_time, TF.stringValue);
  TF.addOptionalField(fields, "end_time", params.end_time, TF.stringValue);
  TF.addOptionalField(fields, "recurrence", params.recurrence, TF.stringValue);
  TF.addOptionalField(fields, "min_size", params.min_size, TF.numberValue);
  TF.addOptionalField(fields, "max_size", params.max_size, TF.numberValue);
  TF.addOptionalField(fields, "desired_capacity", params.desired_capacity, TF.numberValue);
  return fields;
}

export interface AutoscalingAttachmentParams {
  autoscaling_group_name: AutoscalingGroupId;
  alb_target_group_arn: AT.ArnT<"LbTargetGroup">;
}

export function fieldsFromAutoscalingAttachmentParams(params: AutoscalingAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "autoscaling_group_name", params.autoscaling_group_name, TF.resourceIdValue);
  TF.addField(fields, "alb_target_group_arn", params.alb_target_group_arn, TF.resourceArnValue);
  return fields;
}

export interface InstanceRootBlockDeviceParams {
  volume_type?: 'standard' | 'gp2' | 'io1' | 'io2' | 'sc1' | 'st1';
  volume_size?: number;
  iops?: number;
  delete_on_termination?: boolean;
}

export function fieldsFromInstanceRootBlockDeviceParams(params: InstanceRootBlockDeviceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "volume_type", params.volume_type, TF.stringValue);
  TF.addOptionalField(fields, "volume_size", params.volume_size, TF.numberValue);
  TF.addOptionalField(fields, "iops", params.iops, TF.numberValue);
  TF.addOptionalField(fields, "delete_on_termination", params.delete_on_termination, TF.booleanValue);
  return fields;
}

export interface EbsBlockDeviceParams {
  /**
  The name of the device to mount.
  */
  device_name: string;
  volume_type?: 'standard' | 'gp2' | 'io1' | 'io2' | 'sc1' | 'st1';
  volume_size?: number;
  iops?: number;
  delete_on_termination?: boolean;
}

export function fieldsFromEbsBlockDeviceParams(params: EbsBlockDeviceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "device_name", params.device_name, TF.stringValue);
  TF.addOptionalField(fields, "volume_type", params.volume_type, TF.stringValue);
  TF.addOptionalField(fields, "volume_size", params.volume_size, TF.numberValue);
  TF.addOptionalField(fields, "iops", params.iops, TF.numberValue);
  TF.addOptionalField(fields, "delete_on_termination", params.delete_on_termination, TF.booleanValue);
  return fields;
}

export interface EphemeralBlockDeviceParams {
  /**
  The name of the block device to mount on the instance.
  */
  device_name?: string;
  virtual_name?: string;
}

export function fieldsFromEphemeralBlockDeviceParams(params: EphemeralBlockDeviceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "device_name", params.device_name, TF.stringValue);
  TF.addOptionalField(fields, "virtual_name", params.virtual_name, TF.stringValue);
  return fields;
}

export interface InstanceParams {
  ami: AT.Ami;
  instance_type: AT.InstanceType;
  availability_zone?: AT.AvailabilityZone;
  ebs_optimized?: boolean;
  disable_api_termination?: boolean;
  key_name?: AT.KeyName;
  monitoring?: boolean;
  subnet_id?: SubnetId;
  associate_public_ip_address?: boolean;
  root_block_device?: InstanceRootBlockDeviceParams;
  ebs_block_device?: (EbsBlockDeviceParams)[];
  ephemeral_block_device?: EphemeralBlockDeviceParams;
  user_data?: string;
  iam_instance_profile?: IamInstanceProfileId;
  vpc_security_group_ids?: (SecurityGroupId)[];
  tags?: TF.TagsMap;
}

export function fieldsFromInstanceParams(params: InstanceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "ami", params.ami, TF.stringAliasValue);
  TF.addField(fields, "instance_type", params.instance_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  TF.addOptionalField(fields, "ebs_optimized", params.ebs_optimized, TF.booleanValue);
  TF.addOptionalField(fields, "disable_api_termination", params.disable_api_termination, TF.booleanValue);
  TF.addOptionalField(fields, "key_name", params.key_name, TF.stringAliasValue);
  TF.addOptionalField(fields, "monitoring", params.monitoring, TF.booleanValue);
  TF.addOptionalField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "associate_public_ip_address", params.associate_public_ip_address, TF.booleanValue);
  TF.addOptionalField(fields, "root_block_device", params.root_block_device, (v) => TF.mapValue(fieldsFromInstanceRootBlockDeviceParams(v)));
  TF.addOptionalField(fields, "ebs_block_device", params.ebs_block_device, TF.listValue((v) => TF.mapValue(fieldsFromEbsBlockDeviceParams(v))));
  TF.addOptionalField(fields, "ephemeral_block_device", params.ephemeral_block_device, (v) => TF.mapValue(fieldsFromEphemeralBlockDeviceParams(v)));
  TF.addOptionalField(fields, "user_data", params.user_data, TF.stringValue);
  TF.addOptionalField(fields, "iam_instance_profile", params.iam_instance_profile, TF.resourceIdValue);
  TF.addOptionalField(fields, "vpc_security_group_ids", params.vpc_security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface EbsVolumeParams {
  availability_zone: AT.AvailabilityZone;
  iops?: number;
  size?: number;
  type?: 'standard' | 'gp2' | 'io1' | 'sc1' | 'st1';
  tags?: TF.TagsMap;
}

export function fieldsFromEbsVolumeParams(params: EbsVolumeParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  TF.addOptionalField(fields, "iops", params.iops, TF.numberValue);
  TF.addOptionalField(fields, "size", params.size, TF.numberValue);
  TF.addOptionalField(fields, "type", params.type, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface VolumeAttachmentParams {
  device_name: string;
  instance_id: InstanceId;
  volume_id: EbsVolumeId;
}

export function fieldsFromVolumeAttachmentParams(params: VolumeAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "device_name", params.device_name, TF.stringValue);
  TF.addField(fields, "instance_id", params.instance_id, TF.resourceIdValue);
  TF.addField(fields, "volume_id", params.volume_id, TF.resourceIdValue);
  return fields;
}

export interface DbInstanceParams {
  allocated_storage: number;
  engine: AT.DbEngine;
  instance_class: AT.DbInstanceType;
  username: string;
  password?: string;
  engine_version?: string;
  identifier?: string;
  name?: string;
  port?: number;
  publicly_accessible?: boolean;
  backup_retention_period?: number;
  vpc_security_group_ids?: (SecurityGroupId)[];
  deletion_protection?: boolean;
  performance_insights_enabled?: boolean;
  parameter_group_name?: string;
  db_subnet_group_name?: string;
  tags?: TF.TagsMap;
  skip_final_snapshot?: boolean;
  final_snapshot_identifier?: string;
  multi_az?: boolean;
  license_model?: string;
  auto_minor_version_upgrade?: boolean;
  replicate_source_db?: DbInstanceId;
  apply_immediately?: boolean;
  storage_encrypted?: boolean;
  storage_type?: AT.DbInstanceStorageType;
  iops?: number;
  snapshot_identifier?: string;
  monitoring_interval?: number;
}

export function fieldsFromDbInstanceParams(params: DbInstanceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "allocated_storage", params.allocated_storage, TF.numberValue);
  TF.addField(fields, "engine", params.engine, TF.stringAliasValue);
  TF.addField(fields, "instance_class", params.instance_class, TF.stringAliasValue);
  TF.addField(fields, "username", params.username, TF.stringValue);
  TF.addOptionalField(fields, "password", params.password, TF.stringValue);
  TF.addOptionalField(fields, "engine_version", params.engine_version, TF.stringValue);
  TF.addOptionalField(fields, "identifier", params.identifier, TF.stringValue);
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "publicly_accessible", params.publicly_accessible, TF.booleanValue);
  TF.addOptionalField(fields, "backup_retention_period", params.backup_retention_period, TF.numberValue);
  TF.addOptionalField(fields, "vpc_security_group_ids", params.vpc_security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "deletion_protection", params.deletion_protection, TF.booleanValue);
  TF.addOptionalField(fields, "performance_insights_enabled", params.performance_insights_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "parameter_group_name", params.parameter_group_name, TF.stringValue);
  TF.addOptionalField(fields, "db_subnet_group_name", params.db_subnet_group_name, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  TF.addOptionalField(fields, "skip_final_snapshot", params.skip_final_snapshot, TF.booleanValue);
  TF.addOptionalField(fields, "final_snapshot_identifier", params.final_snapshot_identifier, TF.stringValue);
  TF.addOptionalField(fields, "multi_az", params.multi_az, TF.booleanValue);
  TF.addOptionalField(fields, "license_model", params.license_model, TF.stringValue);
  TF.addOptionalField(fields, "auto_minor_version_upgrade", params.auto_minor_version_upgrade, TF.booleanValue);
  TF.addOptionalField(fields, "replicate_source_db", params.replicate_source_db, TF.stringAliasValue);
  TF.addOptionalField(fields, "apply_immediately", params.apply_immediately, TF.booleanValue);
  TF.addOptionalField(fields, "storage_encrypted", params.storage_encrypted, TF.booleanValue);
  TF.addOptionalField(fields, "storage_type", params.storage_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "iops", params.iops, TF.numberValue);
  TF.addOptionalField(fields, "snapshot_identifier", params.snapshot_identifier, TF.stringValue);
  TF.addOptionalField(fields, "monitoring_interval", params.monitoring_interval, TF.numberValue);
  return fields;
}

export interface DbParameterGroupParams {
  name?: string;
  family: string;
  description?: string;
  tags?: TF.TagsMap;
  parameter?: (DbParameterGroupParameterParams)[];
}

export function fieldsFromDbParameterGroupParams(params: DbParameterGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "family", params.family, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  TF.addOptionalField(fields, "parameter", params.parameter, TF.listValue((v) => TF.mapValue(fieldsFromDbParameterGroupParameterParams(v))));
  return fields;
}

export interface DbParameterGroupParameterParams {
  name: string;
  value: string;
  apply_method?: 'immediate' | 'pending-reboot';
  tags?: TF.TagsMap;
}

export function fieldsFromDbParameterGroupParameterParams(params: DbParameterGroupParameterParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "value", params.value, TF.stringValue);
  TF.addOptionalField(fields, "apply_method", params.apply_method, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface EipParams {
  vpc?: boolean;
  instance?: InstanceId;
  tags?: TF.TagsMap;
}

export function fieldsFromEipParams(params: EipParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "vpc", params.vpc, TF.booleanValue);
  TF.addOptionalField(fields, "instance", params.instance, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface VpcParams {
  cidr_block: AT.CidrBlock;
  instance_tenancy?: string;
  enable_dns_support?: boolean;
  enable_dns_hostnames?: boolean;
  enable_classiclink?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromVpcParams(params: VpcParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "cidr_block", params.cidr_block, TF.stringAliasValue);
  TF.addOptionalField(fields, "instance_tenancy", params.instance_tenancy, TF.stringValue);
  TF.addOptionalField(fields, "enable_dns_support", params.enable_dns_support, TF.booleanValue);
  TF.addOptionalField(fields, "enable_dns_hostnames", params.enable_dns_hostnames, TF.booleanValue);
  TF.addOptionalField(fields, "enable_classiclink", params.enable_classiclink, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface DefaultVpcParams {
  enable_dns_support?: boolean;
  enable_dns_hostnames?: boolean;
  enable_classiclink?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromDefaultVpcParams(params: DefaultVpcParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "enable_dns_support", params.enable_dns_support, TF.booleanValue);
  TF.addOptionalField(fields, "enable_dns_hostnames", params.enable_dns_hostnames, TF.booleanValue);
  TF.addOptionalField(fields, "enable_classiclink", params.enable_classiclink, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SubnetParams {
  vpc_id: VpcId;
  cidr_block: AT.CidrBlock;
  map_public_ip_on_launch?: boolean;
  availability_zone?: AT.AvailabilityZone;
  tags?: TF.TagsMap;
}

export function fieldsFromSubnetParams(params: SubnetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addField(fields, "cidr_block", params.cidr_block, TF.stringAliasValue);
  TF.addOptionalField(fields, "map_public_ip_on_launch", params.map_public_ip_on_launch, TF.booleanValue);
  TF.addOptionalField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface DefaultSubnetParams {
  availability_zone: AT.AvailabilityZone;
  map_public_ip_on_launch?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromDefaultSubnetParams(params: DefaultSubnetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  TF.addOptionalField(fields, "map_public_ip_on_launch", params.map_public_ip_on_launch, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface VpcEndpointParams {
  service_name: string;
  vpc_id: VpcId;
  auto_accept?: boolean;
  policy?: string;
  private_dns_enabled?: boolean;
  route_table_ids?: (RouteTableId)[];
  subnet_ids?: (SubnetId)[];
  security_group_ids?: (SecurityGroupId)[];
  tags?: TF.TagsMap;
  vpc_endpoint_type?: 'Gateway' | 'GatewayLoadBalancer' | 'Interface';
}

export function fieldsFromVpcEndpointParams(params: VpcEndpointParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "service_name", params.service_name, TF.stringValue);
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "auto_accept", params.auto_accept, TF.booleanValue);
  TF.addOptionalField(fields, "policy", params.policy, TF.stringValue);
  TF.addOptionalField(fields, "private_dns_enabled", params.private_dns_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "route_table_ids", params.route_table_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "subnet_ids", params.subnet_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "security_group_ids", params.security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  TF.addOptionalField(fields, "vpc_endpoint_type", params.vpc_endpoint_type, TF.stringValue);
  return fields;
}

export interface SecurityGroupParams {
  name?: string;
  name_prefix?: string;
  description?: string;
  ingress?: (IngressRuleParams)[];
  egress?: (EgressRuleParams)[];
  vpc_id?: VpcId;
  tags?: TF.TagsMap;
}

export function fieldsFromSecurityGroupParams(params: SecurityGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addOptionalField(fields, "ingress", params.ingress, TF.listValue((v) => TF.mapValue(fieldsFromIngressRuleParams(v))));
  TF.addOptionalField(fields, "egress", params.egress, TF.listValue((v) => TF.mapValue(fieldsFromEgressRuleParams(v))));
  TF.addOptionalField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SecurityGroupRuleParams {
  type: 'ingress' | 'egress';
  cidr_blocks?: (AT.CidrBlock)[];
  description?: string;
  from_port: number;
  protocol: 'tcp' | 'udp' | 'icmp' | 'all' | '-1';
  security_group_id?: SecurityGroupId;
  source_security_group_id?: SecurityGroupId;
  to_port: number;
}

export function fieldsFromSecurityGroupRuleParams(params: SecurityGroupRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addOptionalField(fields, "cidr_blocks", params.cidr_blocks, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addField(fields, "from_port", params.from_port, TF.numberValue);
  TF.addField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addOptionalField(fields, "security_group_id", params.security_group_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "source_security_group_id", params.source_security_group_id, TF.resourceIdValue);
  TF.addField(fields, "to_port", params.to_port, TF.numberValue);
  return fields;
}

export interface IngressRuleParams {
  from_port: number;
  to_port: number;
  protocol: 'tcp' | 'udp' | 'icmp' | '-1';
  cidr_blocks: (AT.CidrBlock)[];
  description?: string;
}

export function fieldsFromIngressRuleParams(params: IngressRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "from_port", params.from_port, TF.numberValue);
  TF.addField(fields, "to_port", params.to_port, TF.numberValue);
  TF.addField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addField(fields, "cidr_blocks", params.cidr_blocks, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface EgressRuleParams {
  from_port: number;
  to_port: number;
  protocol: 'tcp' | 'udp' | 'icmp' | '-1';
  cidr_blocks: (AT.CidrBlock)[];
  description?: string;
}

export function fieldsFromEgressRuleParams(params: EgressRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "from_port", params.from_port, TF.numberValue);
  TF.addField(fields, "to_port", params.to_port, TF.numberValue);
  TF.addField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addField(fields, "cidr_blocks", params.cidr_blocks, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface InternetGatewayParams {
  vpc_id: VpcId;
  tags?: TF.TagsMap;
}

export function fieldsFromInternetGatewayParams(params: InternetGatewayParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface NatGatewayParams {
  allocation_id: EipId;
  subnet_id: SubnetId;
}

export function fieldsFromNatGatewayParams(params: NatGatewayParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "allocation_id", params.allocation_id, TF.resourceIdValue);
  TF.addField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  return fields;
}

export interface RouteTableAssociationParams {
  subnet_id: SubnetId;
  route_table_id: RouteTableId;
}

export function fieldsFromRouteTableAssociationParams(params: RouteTableAssociationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  TF.addField(fields, "route_table_id", params.route_table_id, TF.resourceIdValue);
  return fields;
}

export interface Route53RecordParams {
  zone_id: AT.HostedZoneId;
  name: string;
  type: 'A' | 'AAAA' | 'CAA' | 'CNAME' | 'MX' | 'NAPTR' | 'NS' | 'PTR' | 'SOA' | 'SPF' | 'SRV' | 'TXT';
  ttl?: string;
  records?: (string)[];
  alias?: Route53AliasParams;
  allow_overwrite?: boolean;
}

export function fieldsFromRoute53RecordParams(params: Route53RecordParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "zone_id", params.zone_id, TF.stringAliasValue);
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addOptionalField(fields, "ttl", params.ttl, TF.stringValue);
  TF.addOptionalField(fields, "records", params.records, TF.listValue(TF.quotedStringValue));
  TF.addOptionalField(fields, "alias", params.alias, (v) => TF.mapValue(fieldsFromRoute53AliasParams(v)));
  TF.addOptionalField(fields, "allow_overwrite", params.allow_overwrite, TF.booleanValue);
  return fields;
}

export interface Route53AliasParams {
  name: string;
  zone_id: AT.HostedZoneId;
  evaluate_target_health: boolean;
}

export function fieldsFromRoute53AliasParams(params: Route53AliasParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "zone_id", params.zone_id, TF.stringAliasValue);
  TF.addField(fields, "evaluate_target_health", params.evaluate_target_health, TF.booleanValue);
  return fields;
}

export interface BucketVersioningParams {
  enabled?: boolean;
  mfa_delete?: boolean;
}

export function fieldsFromBucketVersioningParams(params: BucketVersioningParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addOptionalField(fields, "mfa_delete", params.mfa_delete, TF.booleanValue);
  return fields;
}

export interface ExpirationParams {
  /**
  Specifies the number of days after object creation when the specific rule action takes effect.
  */
  days?: number;
  /**
  Specifies the date after which you want the corresponding action to take effect.
  */
  date?: string;
  expired_object_delete_marker?: boolean;
}

export function fieldsFromExpirationParams(params: ExpirationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "days", params.days, TF.numberValue);
  TF.addOptionalField(fields, "date", params.date, TF.stringValue);
  TF.addOptionalField(fields, "expired_object_delete_marker", params.expired_object_delete_marker, TF.booleanValue);
  return fields;
}

export interface TransitionParams {
  /**
  Specifies the date after which you want the corresponding action to take effect.
  */
  date?: string;
  /**
  Specifies the number of days after object creation when the specific rule action takes effect.
  */
  days?: number;
  /**
  Specifies the Amazon S3 storage class to which you want the object to transition
  */
  storage_class: 'ONEZONE_IA' | 'STANDARD_IA' | 'INTELLIGENT_TIERING' | 'GLACIER' | 'DEEP_ARCHIVE';
}

export function fieldsFromTransitionParams(params: TransitionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "date", params.date, TF.stringValue);
  TF.addOptionalField(fields, "days", params.days, TF.numberValue);
  TF.addField(fields, "storage_class", params.storage_class, TF.stringValue);
  return fields;
}

export interface LifecycleRuleParams {
  id?: string;
  prefix?: string;
  enabled: boolean;
  expiration?: ExpirationParams;
  transition?: TransitionParams;
}

export function fieldsFromLifecycleRuleParams(params: LifecycleRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "id", params.id, TF.stringValue);
  TF.addOptionalField(fields, "prefix", params.prefix, TF.stringValue);
  TF.addField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addOptionalField(fields, "expiration", params.expiration, (v) => TF.mapValue(fieldsFromExpirationParams(v)));
  TF.addOptionalField(fields, "transition", params.transition, (v) => TF.mapValue(fieldsFromTransitionParams(v)));
  return fields;
}

export interface CorsRuleParams {
  allowed_headers?: (string)[];
  allowed_methods: (string)[];
  allowed_origins: (string)[];
  expose_headers?: (string)[];
  max_age_seconds?: number;
}

export function fieldsFromCorsRuleParams(params: CorsRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "allowed_headers", params.allowed_headers, TF.listValue(TF.stringValue));
  TF.addField(fields, "allowed_methods", params.allowed_methods, TF.listValue(TF.stringValue));
  TF.addField(fields, "allowed_origins", params.allowed_origins, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "expose_headers", params.expose_headers, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "max_age_seconds", params.max_age_seconds, TF.numberValue);
  return fields;
}

export interface S3BucketParams {
  bucket: string;
  acl?: AT.CannedAcl;
  policy?: string;
  versioning?: BucketVersioningParams;
  lifecycle_rule?: (LifecycleRuleParams)[];
  cors_rule?: CorsRuleParams;
  website?: WebsiteParams;
  tags?: TF.TagsMap;
}

export function fieldsFromS3BucketParams(params: S3BucketParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addOptionalField(fields, "acl", params.acl, TF.stringAliasValue);
  TF.addOptionalField(fields, "policy", params.policy, TF.stringValue);
  TF.addOptionalField(fields, "versioning", params.versioning, (v) => TF.mapValue(fieldsFromBucketVersioningParams(v)));
  TF.addOptionalField(fields, "lifecycle_rule", params.lifecycle_rule, TF.listValue((v) => TF.mapValue(fieldsFromLifecycleRuleParams(v))));
  TF.addOptionalField(fields, "cors_rule", params.cors_rule, (v) => TF.mapValue(fieldsFromCorsRuleParams(v)));
  TF.addOptionalField(fields, "website", params.website, (v) => TF.mapValue(fieldsFromWebsiteParams(v)));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface WebsiteParams {
  index_document?: string;
  error_document?: string;
  redirect_all_requests_to?: string;
  routing_rules?: string;
}

export function fieldsFromWebsiteParams(params: WebsiteParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "index_document", params.index_document, TF.stringValue);
  TF.addOptionalField(fields, "error_document", params.error_document, TF.stringValue);
  TF.addOptionalField(fields, "redirect_all_requests_to", params.redirect_all_requests_to, TF.stringValue);
  TF.addOptionalField(fields, "routing_rules", params.routing_rules, TF.stringValue);
  return fields;
}

export interface S3BucketObjectParams {
  bucket: string;
  key: string;
  source?: string;
  content?: string;
}

export function fieldsFromS3BucketObjectParams(params: S3BucketObjectParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addField(fields, "key", params.key, TF.stringValue);
  TF.addOptionalField(fields, "source", params.source, TF.stringValue);
  TF.addOptionalField(fields, "content", params.content, TF.stringValue);
  return fields;
}

export interface SnsTopicParams {
  name: string;
  display_name?: string;
}

export function fieldsFromSnsTopicParams(params: SnsTopicParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "display_name", params.display_name, TF.stringValue);
  return fields;
}

export interface IamUserParams {
  name: string;
  path?: string;
  force_destroy?: boolean;
}

export function fieldsFromIamUserParams(params: IamUserParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "force_destroy", params.force_destroy, TF.booleanValue);
  return fields;
}

export interface IamUserPolicyParams {
  name: string;
  policy: string;
  user: string;
}

export function fieldsFromIamUserPolicyParams(params: IamUserPolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  TF.addField(fields, "user", params.user, TF.stringValue);
  return fields;
}

export interface IamUserPolicyAttachmentParams {
  user: string;
  policy_arn: AT.Arn;
}

export function fieldsFromIamUserPolicyAttachmentParams(params: IamUserPolicyAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "user", params.user, TF.stringValue);
  TF.addField(fields, "policy_arn", params.policy_arn, TF.stringAliasValue);
  return fields;
}

export interface IamGroupParams {
  name: string;
  path?: string;
}

export function fieldsFromIamGroupParams(params: IamGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  return fields;
}

export interface IamGroupPolicyParams {
  name: string;
  policy: string;
  group: string;
}

export function fieldsFromIamGroupPolicyParams(params: IamGroupPolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  TF.addField(fields, "group", params.group, TF.stringValue);
  return fields;
}

export interface EcrRepositoryParams {
  name: string;
}

export function fieldsFromEcrRepositoryParams(params: EcrRepositoryParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  return fields;
}

export interface DbSubnetGroupParams {
  name: string;
  description?: string;
  subnet_ids: (SubnetId)[];
  tags?: TF.TagsMap;
}

export function fieldsFromDbSubnetGroupParams(params: DbSubnetGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addField(fields, "subnet_ids", params.subnet_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface CloudwatchMetricAlarmParams {
  alarm_name: string;
  comparison_operator: 'GreaterThanOrEqualToThreshold' | 'GreaterThanThreshold' | 'LessThanThreshold' | 'LessThanOrEqualToThreshold';
  /**
  The number of periods over which data is compared to the specified threshold.
  */
  evaluation_periods: number;
  metric_name: string;
  namespace: string;
  /**
  The period in seconds over which the specified statistic is applied.
  */
  period: number;
  statistic: 'SampleCount' | 'Average' | 'Sum' | 'Minimum' | 'Maximum';
  /**
  The value against which the specified statistic is compared. This parameter is required for alarms based on static thresholds
  */
  threshold: number;
  /**
  Indicates whether or not actions should be executed during any changes to the alarm's state. Defaults to true.
  */
  actions_enabled?: boolean;
  /**
  The list of actions to execute when this alarm transitions into an ALARM state from any other state
  */
  alarm_actions?: (AT.Arn)[];
  alarm_description?: string;
  /**
  The number of datapoints that must be breaching to trigger the alarm.
  */
  datapoints_to_alarm?: number;
  dimensions?: TF.TagsMap;
  /**
  The list of actions to execute when this alarm transitions into an INSUFFICIENT_DATA state from any other state
  */
  insufficient_data_actions?: (AT.Arn)[];
  /**
  The list of actions to execute when this alarm transitions into an OK state from any other state
  */
  ok_actions?: (AT.Arn)[];
  unit?: string;
  /**
  Sets how this alarm is to handle missing data points
  */
  treat_missing_data?: 'missing' | 'ignore' | 'breaching' | 'notBreaching';
}

export function fieldsFromCloudwatchMetricAlarmParams(params: CloudwatchMetricAlarmParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "alarm_name", params.alarm_name, TF.stringValue);
  TF.addField(fields, "comparison_operator", params.comparison_operator, TF.stringValue);
  TF.addField(fields, "evaluation_periods", params.evaluation_periods, TF.numberValue);
  TF.addField(fields, "metric_name", params.metric_name, TF.stringValue);
  TF.addField(fields, "namespace", params.namespace, TF.stringValue);
  TF.addField(fields, "period", params.period, TF.numberValue);
  TF.addField(fields, "statistic", params.statistic, TF.stringValue);
  TF.addField(fields, "threshold", params.threshold, TF.numberValue);
  TF.addOptionalField(fields, "actions_enabled", params.actions_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "alarm_actions", params.alarm_actions, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "alarm_description", params.alarm_description, TF.stringValue);
  TF.addOptionalField(fields, "datapoints_to_alarm", params.datapoints_to_alarm, TF.numberValue);
  TF.addOptionalField(fields, "dimensions", params.dimensions, TF.tagsValue);
  TF.addOptionalField(fields, "insufficient_data_actions", params.insufficient_data_actions, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "ok_actions", params.ok_actions, TF.listValue(TF.stringAliasValue));
  TF.addOptionalField(fields, "unit", params.unit, TF.stringValue);
  TF.addOptionalField(fields, "treat_missing_data", params.treat_missing_data, TF.stringValue);
  return fields;
}

export interface IamInstanceProfileParams {
  name?: string;
  name_prefix?: string;
  path?: string;
  roles?: (string)[];
  role?: string;
}

export function fieldsFromIamInstanceProfileParams(params: IamInstanceProfileParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "roles", params.roles, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "role", params.role, TF.stringValue);
  return fields;
}

export interface IamRoleParams {
  name?: string;
  name_prefix?: string;
  assume_role_policy: string;
  max_session_duration?: number;
  path?: string;
  description?: string;
}

export function fieldsFromIamRoleParams(params: IamRoleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "assume_role_policy", params.assume_role_policy, TF.stringValue);
  TF.addOptionalField(fields, "max_session_duration", params.max_session_duration, TF.numberValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface IamRolePolicyParams {
  name: string;
  policy: string;
  role: IamRoleId;
}

export function fieldsFromIamRolePolicyParams(params: IamRolePolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  TF.addField(fields, "role", params.role, TF.resourceIdValue);
  return fields;
}

export interface IamPolicyParams {
  description?: string;
  name?: string;
  name_prefix?: string;
  path?: string;
  policy: string;
}

export function fieldsFromIamPolicyParams(params: IamPolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  return fields;
}

export interface IamRolePolicyAttachmentParams {
  role: string;
  policy_arn: AT.ArnT<"IamPolicy">;
}

export function fieldsFromIamRolePolicyAttachmentParams(params: IamRolePolicyAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "role", params.role, TF.stringValue);
  TF.addField(fields, "policy_arn", params.policy_arn, TF.resourceArnValue);
  return fields;
}

export interface SqsQueueParams {
  name?: string;
  name_prefix?: string;
  visibility_timeout_seconds?: number;
  message_retention_seconds ?: number;
  max_message_size?: number;
  delay_seconds?: number;
  receive_wait_time_seconds?: number;
  policy?: string;
  redrive_policy?: string;
  fifo_queue?: boolean;
  content_based_deduplication?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromSqsQueueParams(params: SqsQueueParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "visibility_timeout_seconds", params.visibility_timeout_seconds, TF.numberValue);
  TF.addOptionalField(fields, "message_retention_seconds ", params.message_retention_seconds , TF.numberValue);
  TF.addOptionalField(fields, "max_message_size", params.max_message_size, TF.numberValue);
  TF.addOptionalField(fields, "delay_seconds", params.delay_seconds, TF.numberValue);
  TF.addOptionalField(fields, "receive_wait_time_seconds", params.receive_wait_time_seconds, TF.numberValue);
  TF.addOptionalField(fields, "policy", params.policy, TF.stringValue);
  TF.addOptionalField(fields, "redrive_policy", params.redrive_policy, TF.stringValue);
  TF.addOptionalField(fields, "fifo_queue", params.fifo_queue, TF.booleanValue);
  TF.addOptionalField(fields, "content_based_deduplication", params.content_based_deduplication, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SqsQueuePolicyParams {
  queue_url: string;
  policy: string;
}

export function fieldsFromSqsQueuePolicyParams(params: SqsQueuePolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "queue_url", params.queue_url, TF.stringValue);
  TF.addField(fields, "policy", params.policy, TF.stringValue);
  return fields;
}

export interface LbParams {
  name?: string;
  name_prefix?: string;
  internal?: boolean;
  load_balancer_type?: 'application' | 'network';
  security_groups?: (SecurityGroupId)[];
  access_logs?: LbAccessLogsParams;
  subnets?: (SubnetId)[];
  subnet_mapping?: (LbSubnetMappingParams)[];
  idle_timeout?: number;
  enable_deletion_protection?: boolean;
  enable_cross_zone_load_balancing?: boolean;
  enable_http2?: boolean;
  ip_address_type?: 'ipv4' | 'dualstack';
  tags?: TF.TagsMap;
}

export function fieldsFromLbParams(params: LbParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "internal", params.internal, TF.booleanValue);
  TF.addOptionalField(fields, "load_balancer_type", params.load_balancer_type, TF.stringValue);
  TF.addOptionalField(fields, "security_groups", params.security_groups, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "access_logs", params.access_logs, (v) => TF.mapValue(fieldsFromLbAccessLogsParams(v)));
  TF.addOptionalField(fields, "subnets", params.subnets, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "subnet_mapping", params.subnet_mapping, TF.listValue((v) => TF.mapValue(fieldsFromLbSubnetMappingParams(v))));
  TF.addOptionalField(fields, "idle_timeout", params.idle_timeout, TF.numberValue);
  TF.addOptionalField(fields, "enable_deletion_protection", params.enable_deletion_protection, TF.booleanValue);
  TF.addOptionalField(fields, "enable_cross_zone_load_balancing", params.enable_cross_zone_load_balancing, TF.booleanValue);
  TF.addOptionalField(fields, "enable_http2", params.enable_http2, TF.booleanValue);
  TF.addOptionalField(fields, "ip_address_type", params.ip_address_type, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface LbAccessLogsParams {
  bucket: string;
  bucket_prefix?: string;
  interval?: number;
  enabled?: boolean;
}

export function fieldsFromLbAccessLogsParams(params: LbAccessLogsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addOptionalField(fields, "bucket_prefix", params.bucket_prefix, TF.stringValue);
  TF.addOptionalField(fields, "interval", params.interval, TF.numberValue);
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  return fields;
}

export interface LbSubnetMappingParams {
  subnet_id: SubnetId;
  allocation_id: EipId;
}

export function fieldsFromLbSubnetMappingParams(params: LbSubnetMappingParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "subnet_id", params.subnet_id, TF.resourceIdValue);
  TF.addField(fields, "allocation_id", params.allocation_id, TF.resourceIdValue);
  return fields;
}

export interface LbListenerParams {
  load_balancer_arn: AT.ArnT<"Lb">;
  port: number;
  protocol?: 'TCP' | 'HTTP' | 'HTTPS';
  ssl_policy?: string;
  certificate_arn?: AT.ArnT<"AcmCertificate">;
  default_action: LbListenerActionParams;
}

export function fieldsFromLbListenerParams(params: LbListenerParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "load_balancer_arn", params.load_balancer_arn, TF.resourceArnValue);
  TF.addField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addOptionalField(fields, "ssl_policy", params.ssl_policy, TF.stringValue);
  TF.addOptionalField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  TF.addField(fields, "default_action", params.default_action, (v) => TF.mapValue(fieldsFromLbListenerActionParams(v)));
  return fields;
}

export interface LbListenerActionParams {
  type: 'forward' | 'redirect' | 'fixed-response';
  target_group_arn?: AT.ArnT<"LbTargetGroup">;
  redirect?: LbListenerActionRedirectParams;
  fixed_response?: LbListenerActionFixedResponseParams;
}

export function fieldsFromLbListenerActionParams(params: LbListenerActionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addOptionalField(fields, "target_group_arn", params.target_group_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "redirect", params.redirect, (v) => TF.mapValue(fieldsFromLbListenerActionRedirectParams(v)));
  TF.addOptionalField(fields, "fixed_response", params.fixed_response, (v) => TF.mapValue(fieldsFromLbListenerActionFixedResponseParams(v)));
  return fields;
}

export interface LbListenerActionRedirectParams {
  host?: string;
  path?: string;
  port?: string;
  protocol?: 'HTTP' | 'HTTPS' | '#{protocol}';
  query?: string;
  status_code: 'HTTP_301' | 'HTTP_302';
}

export function fieldsFromLbListenerActionRedirectParams(params: LbListenerActionRedirectParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "host", params.host, TF.stringValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.stringValue);
  TF.addOptionalField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addOptionalField(fields, "query", params.query, TF.stringValue);
  TF.addField(fields, "status_code", params.status_code, TF.stringValue);
  return fields;
}

export interface LbListenerActionFixedResponseParams {
  content_type: 'text/plain' | 'text/css' | 'text/html' | 'application/javascript' | 'application/json';
  message_body?: string;
  status_code?: number;
}

export function fieldsFromLbListenerActionFixedResponseParams(params: LbListenerActionFixedResponseParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "content_type", params.content_type, TF.stringValue);
  TF.addOptionalField(fields, "message_body", params.message_body, TF.stringValue);
  TF.addOptionalField(fields, "status_code", params.status_code, TF.numberValue);
  return fields;
}

export interface LbTargetGroupParams {
  name?: string;
  name_prefix?: string;
  port: number;
  protocol: 'TCP' | 'HTTP' | 'HTTPS';
  vpc_id: VpcId;
  deregistration_delay?: number;
  slow_start?: number;
  proxy_protocol_v2?: boolean;
  stickiness?: LbTargetGroupStickinessParams;
  health_check?: LbTargetGroupHealthCheckParams;
  target_type?: 'instance' | 'ip';
  tags?: TF.TagsMap;
}

export function fieldsFromLbTargetGroupParams(params: LbTargetGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "port", params.port, TF.numberValue);
  TF.addField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "deregistration_delay", params.deregistration_delay, TF.numberValue);
  TF.addOptionalField(fields, "slow_start", params.slow_start, TF.numberValue);
  TF.addOptionalField(fields, "proxy_protocol_v2", params.proxy_protocol_v2, TF.booleanValue);
  TF.addOptionalField(fields, "stickiness", params.stickiness, (v) => TF.mapValue(fieldsFromLbTargetGroupStickinessParams(v)));
  TF.addOptionalField(fields, "health_check", params.health_check, (v) => TF.mapValue(fieldsFromLbTargetGroupHealthCheckParams(v)));
  TF.addOptionalField(fields, "target_type", params.target_type, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface LbTargetGroupHealthCheckParams {
  interval?: number;
  path?: string;
  port?: string;
  protocol?: 'TCP' | 'HTTP' | 'HTTPS';
  timeout?: number;
  healthy_threshold?: number;
  unhealthy_threshold?: number;
  matcher?: string;
}

export function fieldsFromLbTargetGroupHealthCheckParams(params: LbTargetGroupHealthCheckParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "interval", params.interval, TF.numberValue);
  TF.addOptionalField(fields, "path", params.path, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.stringValue);
  TF.addOptionalField(fields, "protocol", params.protocol, TF.stringValue);
  TF.addOptionalField(fields, "timeout", params.timeout, TF.numberValue);
  TF.addOptionalField(fields, "healthy_threshold", params.healthy_threshold, TF.numberValue);
  TF.addOptionalField(fields, "unhealthy_threshold", params.unhealthy_threshold, TF.numberValue);
  TF.addOptionalField(fields, "matcher", params.matcher, TF.stringValue);
  return fields;
}

export interface LbTargetGroupStickinessParams {
  type: 'lb_cookie';
  cookie_duration?: number;
  enabled?: boolean;
}

export function fieldsFromLbTargetGroupStickinessParams(params: LbTargetGroupStickinessParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addOptionalField(fields, "cookie_duration", params.cookie_duration, TF.numberValue);
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  return fields;
}

export interface LbTargetGroupAttachmentParams {
  target_group_arn: AT.ArnT<"LbTargetGroup">;
  target_id: string;
  port?: number;
  availability_zone?: AT.AvailabilityZone;
}

export function fieldsFromLbTargetGroupAttachmentParams(params: LbTargetGroupAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "target_group_arn", params.target_group_arn, TF.resourceArnValue);
  TF.addField(fields, "target_id", params.target_id, TF.stringValue);
  TF.addOptionalField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "availability_zone", params.availability_zone, TF.stringAliasValue);
  return fields;
}

export interface LbListenerRuleParams {
  listener_arn: AT.ArnT<"LbListener">;
  priority?: number;
  action: LbListenerActionParams;
  condition: LbListenerRuleConditionParams;
}

export function fieldsFromLbListenerRuleParams(params: LbListenerRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "listener_arn", params.listener_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "priority", params.priority, TF.numberValue);
  TF.addField(fields, "action", params.action, (v) => TF.mapValue(fieldsFromLbListenerActionParams(v)));
  TF.addField(fields, "condition", params.condition, (v) => TF.mapValue(fieldsFromLbListenerRuleConditionParams(v)));
  return fields;
}

export interface LbListenerRuleValuesParams {
  values: (string)[];
}

export function fieldsFromLbListenerRuleValuesParams(params: LbListenerRuleValuesParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "values", params.values, TF.listValue(TF.stringValue));
  return fields;
}

export interface LbListenerRuleConditionParams {
  host_header?: LbListenerRuleValuesParams;
  http_request_method?: LbListenerRuleValuesParams;
  path_pattern?: LbListenerRuleValuesParams;
  source_ip?: LbListenerRuleValuesParams;
}

export function fieldsFromLbListenerRuleConditionParams(params: LbListenerRuleConditionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "host_header", params.host_header, (v) => TF.mapValue(fieldsFromLbListenerRuleValuesParams(v)));
  TF.addOptionalField(fields, "http_request_method", params.http_request_method, (v) => TF.mapValue(fieldsFromLbListenerRuleValuesParams(v)));
  TF.addOptionalField(fields, "path_pattern", params.path_pattern, (v) => TF.mapValue(fieldsFromLbListenerRuleValuesParams(v)));
  TF.addOptionalField(fields, "source_ip", params.source_ip, (v) => TF.mapValue(fieldsFromLbListenerRuleValuesParams(v)));
  return fields;
}

export interface CloudwatchLogGroupParams {
  name?: string;
  name_prefix?: string;
  retention_in_days?: number;
  tags?: TF.TagsMap;
}

export function fieldsFromCloudwatchLogGroupParams(params: CloudwatchLogGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "retention_in_days", params.retention_in_days, TF.numberValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface AwsParams {
  region?: AT.Region;
}

export function fieldsFromAwsParams(params: AwsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "region", params.region, TF.stringAliasValue);
  return fields;
}

export interface ElasticsearchDomainParams {
  domain_name: string;
  access_policies?: string;
  advanced_options?: TF.TagsMap;
  ebs_options?: ElasticsearchDomainEbsOptionsParams;
  cluster_config?: ElasticsearchDomainClusterConfigParams;
  snapshot_options?: ElasticsearchDomainSnapshotOptionsParams;
  cognito_options?: ElasticsearchDomainCognitoOptionsParams;
  vpc_options?: ElasticsearchDomainVpcOptionsParams;
  elasticsearch_version?: string;
  tags?: TF.TagsMap;
}

export function fieldsFromElasticsearchDomainParams(params: ElasticsearchDomainParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "access_policies", params.access_policies, TF.stringValue);
  TF.addOptionalField(fields, "advanced_options", params.advanced_options, TF.tagsValue);
  TF.addOptionalField(fields, "ebs_options", params.ebs_options, (v) => TF.mapValue(fieldsFromElasticsearchDomainEbsOptionsParams(v)));
  TF.addOptionalField(fields, "cluster_config", params.cluster_config, (v) => TF.mapValue(fieldsFromElasticsearchDomainClusterConfigParams(v)));
  TF.addOptionalField(fields, "snapshot_options", params.snapshot_options, (v) => TF.mapValue(fieldsFromElasticsearchDomainSnapshotOptionsParams(v)));
  TF.addOptionalField(fields, "cognito_options", params.cognito_options, (v) => TF.mapValue(fieldsFromElasticsearchDomainCognitoOptionsParams(v)));
  TF.addOptionalField(fields, "vpc_options", params.vpc_options, (v) => TF.mapValue(fieldsFromElasticsearchDomainVpcOptionsParams(v)));
  TF.addOptionalField(fields, "elasticsearch_version", params.elasticsearch_version, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface ElasticsearchDomainClusterConfigParams {
  instance_type?: AT.EsInstanceType;
  instance_count?: number;
  dedicated_master_enabled?: boolean;
  dedicated_master_type?: AT.EsInstanceType;
  dedicated_master_count?: number;
  zone_awareness_enabled?: boolean;
}

export function fieldsFromElasticsearchDomainClusterConfigParams(params: ElasticsearchDomainClusterConfigParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "instance_type", params.instance_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "instance_count", params.instance_count, TF.numberValue);
  TF.addOptionalField(fields, "dedicated_master_enabled", params.dedicated_master_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "dedicated_master_type", params.dedicated_master_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "dedicated_master_count", params.dedicated_master_count, TF.numberValue);
  TF.addOptionalField(fields, "zone_awareness_enabled", params.zone_awareness_enabled, TF.booleanValue);
  return fields;
}

export interface ElasticsearchDomainEbsOptionsParams {
  ebs_enabled: boolean;
  volume_type?: string;
  volume_size?: number;
  iops?: number;
}

export function fieldsFromElasticsearchDomainEbsOptionsParams(params: ElasticsearchDomainEbsOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "ebs_enabled", params.ebs_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "volume_type", params.volume_type, TF.stringValue);
  TF.addOptionalField(fields, "volume_size", params.volume_size, TF.numberValue);
  TF.addOptionalField(fields, "iops", params.iops, TF.numberValue);
  return fields;
}

export interface ElasticsearchDomainSnapshotOptionsParams {
  automated_snapshot_start_hour: number;
}

export function fieldsFromElasticsearchDomainSnapshotOptionsParams(params: ElasticsearchDomainSnapshotOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "automated_snapshot_start_hour", params.automated_snapshot_start_hour, TF.numberValue);
  return fields;
}

export interface ElasticsearchDomainVpcOptionsParams {
  security_group_ids?: (SecurityGroupId)[];
  subnet_ids: (SubnetId)[];
}

export function fieldsFromElasticsearchDomainVpcOptionsParams(params: ElasticsearchDomainVpcOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "security_group_ids", params.security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addField(fields, "subnet_ids", params.subnet_ids, TF.listValue(TF.resourceIdValue));
  return fields;
}

export interface ElasticsearchDomainCognitoOptionsParams {
  enabled?: boolean;
  user_pool_id: CognitoUserPoolId;
  identity_pool_id: CognitoIdentityPoolId;
  role_arn: AT.ArnT<"IamRole">;
}

export function fieldsFromElasticsearchDomainCognitoOptionsParams(params: ElasticsearchDomainCognitoOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addField(fields, "user_pool_id", params.user_pool_id, TF.resourceIdValue);
  TF.addField(fields, "identity_pool_id", params.identity_pool_id, TF.resourceIdValue);
  TF.addField(fields, "role_arn", params.role_arn, TF.resourceArnValue);
  return fields;
}

export interface ElasticsearchDomainPolicyParams {
  domain_name: string;
  access_policies?: string;
}

export function fieldsFromElasticsearchDomainPolicyParams(params: ElasticsearchDomainPolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "access_policies", params.access_policies, TF.stringValue);
  return fields;
}

export interface AcmCertificateParams {
  domain_name: string;
  subject_alternative_names?: (string)[];
  validation_method: string;
  tags?: TF.TagsMap;
}

export function fieldsFromAcmCertificateParams(params: AcmCertificateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "subject_alternative_names", params.subject_alternative_names, TF.listValue(TF.stringValue));
  TF.addField(fields, "validation_method", params.validation_method, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface AcmCertificateValidationParams {
  certificate_arn: AT.ArnT<"AcmCertificate">;
  validation_record_fqdns?: (string)[];
}

export function fieldsFromAcmCertificateValidationParams(params: AcmCertificateValidationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "validation_record_fqdns", params.validation_record_fqdns, TF.listValue(TF.stringValue));
  return fields;
}

export interface LbListenerCertificateParams {
  listener_arn: AT.ArnT<"LbListener">;
  certificate_arn: AT.ArnT<"AcmCertificate">;
}

export function fieldsFromLbListenerCertificateParams(params: LbListenerCertificateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "listener_arn", params.listener_arn, TF.resourceArnValue);
  TF.addField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  return fields;
}

export interface LaunchConfigurationParams {
  name?: string;
  name_prefix?: string;
  image_id: AT.Ami;
  instance_type: AT.InstanceType;
  iam_instance_profile?: IamInstanceProfileId;
  key_name?: AT.KeyName;
  security_groups?: (SecurityGroupId)[];
  associate_public_ip_address?: boolean;
  user_data?: string;
  enable_monitoring?: boolean;
  ebs_optimized?: boolean;
  root_block_device?: InstanceRootBlockDeviceParams;
  /**
  (Number in string). Maximum $ per hour spot price
  */
  spot_price?: number;
}

export function fieldsFromLaunchConfigurationParams(params: LaunchConfigurationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addField(fields, "image_id", params.image_id, TF.stringAliasValue);
  TF.addField(fields, "instance_type", params.instance_type, TF.stringAliasValue);
  TF.addOptionalField(fields, "iam_instance_profile", params.iam_instance_profile, TF.resourceIdValue);
  TF.addOptionalField(fields, "key_name", params.key_name, TF.stringAliasValue);
  TF.addOptionalField(fields, "security_groups", params.security_groups, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "associate_public_ip_address", params.associate_public_ip_address, TF.booleanValue);
  TF.addOptionalField(fields, "user_data", params.user_data, TF.stringValue);
  TF.addOptionalField(fields, "enable_monitoring", params.enable_monitoring, TF.booleanValue);
  TF.addOptionalField(fields, "ebs_optimized", params.ebs_optimized, TF.booleanValue);
  TF.addOptionalField(fields, "root_block_device", params.root_block_device, (v) => TF.mapValue(fieldsFromInstanceRootBlockDeviceParams(v)));
  TF.addOptionalField(fields, "spot_price", params.spot_price, TF.numberStringValue);
  return fields;
}

export interface CloudwatchLoggingOptionsParams {
  enabled?: boolean;
  log_group_name?: string;
  log_stream_name?: string;
}

export function fieldsFromCloudwatchLoggingOptionsParams(params: CloudwatchLoggingOptionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addOptionalField(fields, "log_group_name", params.log_group_name, TF.stringValue);
  TF.addOptionalField(fields, "log_stream_name", params.log_stream_name, TF.stringValue);
  return fields;
}

export interface ExtendedS3ConfigurationParams {
  role_arn: AT.ArnT<"IamRole">;
  bucket_arn: AT.ArnT<"S3Bucket">;
  buffer_size?: number;
  buffer_interval?: number;
  cloudwatch_logging_options?: CloudwatchLoggingOptionsParams;
}

export function fieldsFromExtendedS3ConfigurationParams(params: ExtendedS3ConfigurationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "role_arn", params.role_arn, TF.resourceArnValue);
  TF.addField(fields, "bucket_arn", params.bucket_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "buffer_size", params.buffer_size, TF.numberValue);
  TF.addOptionalField(fields, "buffer_interval", params.buffer_interval, TF.numberValue);
  TF.addOptionalField(fields, "cloudwatch_logging_options", params.cloudwatch_logging_options, (v) => TF.mapValue(fieldsFromCloudwatchLoggingOptionsParams(v)));
  return fields;
}

export interface KinesisFirehoseDeliveryStreamParams {
  name: string;
  destination: 'extended_s3' | 'redshift' | 'elasticsearch' | 'splunk';
  extended_s3_configuration?: ExtendedS3ConfigurationParams;
  tags?: TF.TagsMap;
}

export function fieldsFromKinesisFirehoseDeliveryStreamParams(params: KinesisFirehoseDeliveryStreamParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "destination", params.destination, TF.stringValue);
  TF.addOptionalField(fields, "extended_s3_configuration", params.extended_s3_configuration, (v) => TF.mapValue(fieldsFromExtendedS3ConfigurationParams(v)));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface S3BucketMetricParams {
  bucket: string;
  name: string;
}

export function fieldsFromS3BucketMetricParams(params: S3BucketMetricParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addField(fields, "name", params.name, TF.stringValue);
  return fields;
}

export interface ElasticacheParameterGroupParameterParams {
  name: string;
  value: string;
}

export function fieldsFromElasticacheParameterGroupParameterParams(params: ElasticacheParameterGroupParameterParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "value", params.value, TF.stringValue);
  return fields;
}

export interface ElasticacheParameterGroupParams {
  name: string;
  family: string;
  description?: string;
  parameter?: (ElasticacheParameterGroupParameterParams)[];
}

export function fieldsFromElasticacheParameterGroupParams(params: ElasticacheParameterGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "family", params.family, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addOptionalField(fields, "parameter", params.parameter, TF.listValue((v) => TF.mapValue(fieldsFromElasticacheParameterGroupParameterParams(v))));
  return fields;
}

export interface ElasticacheSubnetGroupParams {
  name: string;
  description?: string;
  subnet_ids: (SubnetId)[];
}

export function fieldsFromElasticacheSubnetGroupParams(params: ElasticacheSubnetGroupParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addField(fields, "subnet_ids", params.subnet_ids, TF.listValue(TF.resourceIdValue));
  return fields;
}

export interface ElasticacheClusterParams {
  cluster_id: string;
  engine: 'memcached' | 'redis';
  engine_version?: string;
  node_type: AT.CacheNodeType;
  num_cache_nodes: number;
  parameter_group_name: AT.ElasticacheParameterGroupName;
  port?: number;
  security_group_ids?: (SecurityGroupId)[];
  subnet_group_name?: string;
  tags?: TF.TagsMap;
}

export function fieldsFromElasticacheClusterParams(params: ElasticacheClusterParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "cluster_id", params.cluster_id, TF.stringValue);
  TF.addField(fields, "engine", params.engine, TF.stringValue);
  TF.addOptionalField(fields, "engine_version", params.engine_version, TF.stringValue);
  TF.addField(fields, "node_type", params.node_type, TF.stringAliasValue);
  TF.addField(fields, "num_cache_nodes", params.num_cache_nodes, TF.numberValue);
  TF.addField(fields, "parameter_group_name", params.parameter_group_name, TF.stringAliasValue);
  TF.addOptionalField(fields, "port", params.port, TF.numberValue);
  TF.addOptionalField(fields, "security_group_ids", params.security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "subnet_group_name", params.subnet_group_name, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface VpcConfigParams {
  subnet_ids: (SubnetId)[];
  security_group_ids: (SecurityGroupId)[];
}

export function fieldsFromVpcConfigParams(params: VpcConfigParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "subnet_ids", params.subnet_ids, TF.listValue(TF.resourceIdValue));
  TF.addField(fields, "security_group_ids", params.security_group_ids, TF.listValue(TF.resourceIdValue));
  return fields;
}

export interface LambdaFunctionParams {
  function_name: string;
  filename?: string;
  s3_bucket?: string;
  s3_key?: string;
  source_code_hash?: string;
  role: AT.ArnT<"IamRole">;
  handler: string;
  runtime: AT.LambdaRuntime;
  vpc_config?: VpcConfigParams;
  environment?: LambdaFunctionEnvironmentParams;
  timeout?: number;
  memory_size?: number;
  tags?: TF.TagsMap;
}

export function fieldsFromLambdaFunctionParams(params: LambdaFunctionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "function_name", params.function_name, TF.stringValue);
  TF.addOptionalField(fields, "filename", params.filename, TF.stringValue);
  TF.addOptionalField(fields, "s3_bucket", params.s3_bucket, TF.stringValue);
  TF.addOptionalField(fields, "s3_key", params.s3_key, TF.stringValue);
  TF.addOptionalField(fields, "source_code_hash", params.source_code_hash, TF.stringValue);
  TF.addField(fields, "role", params.role, TF.resourceArnValue);
  TF.addField(fields, "handler", params.handler, TF.stringValue);
  TF.addField(fields, "runtime", params.runtime, TF.stringAliasValue);
  TF.addOptionalField(fields, "vpc_config", params.vpc_config, (v) => TF.mapValue(fieldsFromVpcConfigParams(v)));
  TF.addOptionalField(fields, "environment", params.environment, (v) => TF.mapValue(fieldsFromLambdaFunctionEnvironmentParams(v)));
  TF.addOptionalField(fields, "timeout", params.timeout, TF.numberValue);
  TF.addOptionalField(fields, "memory_size", params.memory_size, TF.numberValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface LambdaFunctionEnvironmentParams {
  variables?: TF.TagsMap;
}

export function fieldsFromLambdaFunctionEnvironmentParams(params: LambdaFunctionEnvironmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "variables", params.variables, TF.tagsValue);
  return fields;
}

export interface LambdaPermissionParams {
  action: AT.LambdaPermissionAction;
  function_name: string;
  principal: string;
  source_arn?: AT.Arn;
}

export function fieldsFromLambdaPermissionParams(params: LambdaPermissionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "action", params.action, TF.stringAliasValue);
  TF.addField(fields, "function_name", params.function_name, TF.stringValue);
  TF.addField(fields, "principal", params.principal, TF.stringValue);
  TF.addOptionalField(fields, "source_arn", params.source_arn, TF.stringAliasValue);
  return fields;
}

export interface CloudwatchEventRuleParams {
  name?: string;
  schedule_expression?: string;
  description?: string;
}

export function fieldsFromCloudwatchEventRuleParams(params: CloudwatchEventRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "schedule_expression", params.schedule_expression, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface CloudwatchEventTargetParams {
  rule: string;
  arn: AT.Arn;
  input: string;
}

export function fieldsFromCloudwatchEventTargetParams(params: CloudwatchEventTargetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rule", params.rule, TF.stringValue);
  TF.addField(fields, "arn", params.arn, TF.stringAliasValue);
  TF.addField(fields, "input", params.input, TF.stringValue);
  return fields;
}

export interface FieldToMatchParams {
  data?: string;
  type: 'HEADER' | 'METHOD' | 'QUERY_STRING' | 'URI' | 'BODY' | 'SINGLE_QUERY_ARG' | 'ALL_QUERY_ARGS';
}

export function fieldsFromFieldToMatchParams(params: FieldToMatchParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "data", params.data, TF.stringValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface ByteMatchTuplesParams {
  field_to_match: FieldToMatchParams;
  positional_constraint: AT.PositionalConstraint;
  target_string?: string;
}

export function fieldsFromByteMatchTuplesParams(params: ByteMatchTuplesParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "field_to_match", params.field_to_match, (v) => TF.mapValue(fieldsFromFieldToMatchParams(v)));
  TF.addField(fields, "positional_constraint", params.positional_constraint, TF.stringAliasValue);
  TF.addOptionalField(fields, "target_string", params.target_string, TF.stringValue);
  return fields;
}

export interface WafByteMatchSetParams {
  name: string;
  byte_match_tuples: ByteMatchTuplesParams;
}

export function fieldsFromWafByteMatchSetParams(params: WafByteMatchSetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "byte_match_tuples", params.byte_match_tuples, (v) => TF.mapValue(fieldsFromByteMatchTuplesParams(v)));
  return fields;
}

export interface IpSetDescriptorsParams {
  type: 'IPV4' | 'IPV6';
  value: string;
}

export function fieldsFromIpSetDescriptorsParams(params: IpSetDescriptorsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addField(fields, "value", params.value, TF.stringValue);
  return fields;
}

export interface WafIpsetParams {
  name: string;
  ip_set_descriptors: IpSetDescriptorsParams;
}

export function fieldsFromWafIpsetParams(params: WafIpsetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "ip_set_descriptors", params.ip_set_descriptors, (v) => TF.mapValue(fieldsFromIpSetDescriptorsParams(v)));
  return fields;
}

export interface WafregionalRegexPatternSetParams {
  name: string;
  regex_pattern_strings?: (string)[];
}

export function fieldsFromWafregionalRegexPatternSetParams(params: WafregionalRegexPatternSetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "regex_pattern_strings", params.regex_pattern_strings, TF.listValue(TF.stringValue));
  return fields;
}

export interface RegexMatchTupleParams {
  field_to_match: FieldToMatchParams;
  regex_pattern_set_id: WafregionalRegexPatternSetId;
  text_transformation: AT.TextTransformation;
}

export function fieldsFromRegexMatchTupleParams(params: RegexMatchTupleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "field_to_match", params.field_to_match, (v) => TF.mapValue(fieldsFromFieldToMatchParams(v)));
  TF.addField(fields, "regex_pattern_set_id", params.regex_pattern_set_id, TF.resourceIdValue);
  TF.addField(fields, "text_transformation", params.text_transformation, TF.stringAliasValue);
  return fields;
}

export interface WafregionalRegexMatchSetParams {
  name: string;
  regex_match_tuple: RegexMatchTupleParams;
}

export function fieldsFromWafregionalRegexMatchSetParams(params: WafregionalRegexMatchSetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "regex_match_tuple", params.regex_match_tuple, (v) => TF.mapValue(fieldsFromRegexMatchTupleParams(v)));
  return fields;
}

export interface WafregionalIpsetParams {
  name: string;
  ip_set_descriptor?: (IpSetDescriptorsParams)[];
}

export function fieldsFromWafregionalIpsetParams(params: WafregionalIpsetParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "ip_set_descriptor", params.ip_set_descriptor, TF.listValue((v) => TF.mapValue(fieldsFromIpSetDescriptorsParams(v))));
  return fields;
}

export interface PredicateParams {
  type: 'IPMatch' | 'ByteMatch' | 'SqlInjectionMatch' | 'GeoMatch' | 'SizeConstraint' | 'XssMatch' | 'RegexMatch';
  data_id: string;
  negated: boolean;
}

export function fieldsFromPredicateParams(params: PredicateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  TF.addField(fields, "data_id", params.data_id, TF.stringValue);
  TF.addField(fields, "negated", params.negated, TF.booleanValue);
  return fields;
}

export interface WafregionalRuleParams {
  name: string;
  metric_name: string;
  predicate?: (PredicateParams)[];
}

export function fieldsFromWafregionalRuleParams(params: WafregionalRuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "metric_name", params.metric_name, TF.stringValue);
  TF.addOptionalField(fields, "predicate", params.predicate, TF.listValue((v) => TF.mapValue(fieldsFromPredicateParams(v))));
  return fields;
}

export interface ActionParams {
  type: 'ALLOW' | 'BLOCK' | 'COUNT';
}

export function fieldsFromActionParams(params: ActionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface RuleParams {
  action: ActionParams;
  override_action?: ActionParams;
  priority: number;
  rule_id: WafregionalRuleId;
  type?: 'REGULAR' | 'RATE_BASED' | 'GROUP';
}

export function fieldsFromRuleParams(params: RuleParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "action", params.action, (v) => TF.mapValue(fieldsFromActionParams(v)));
  TF.addOptionalField(fields, "override_action", params.override_action, (v) => TF.mapValue(fieldsFromActionParams(v)));
  TF.addField(fields, "priority", params.priority, TF.numberValue);
  TF.addField(fields, "rule_id", params.rule_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface WafregionalWebAclParams {
  name: string;
  metric_name: string;
  default_action: ActionParams;
  rule: RuleParams;
}

export function fieldsFromWafregionalWebAclParams(params: WafregionalWebAclParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "metric_name", params.metric_name, TF.stringValue);
  TF.addField(fields, "default_action", params.default_action, (v) => TF.mapValue(fieldsFromActionParams(v)));
  TF.addField(fields, "rule", params.rule, (v) => TF.mapValue(fieldsFromRuleParams(v)));
  return fields;
}

export interface WafregionalWebAclAssociationParams {
  web_acl_id: WafregionalWebAclId;
  resource_arn: AT.ArnT<"Lb">;
}

export function fieldsFromWafregionalWebAclAssociationParams(params: WafregionalWebAclAssociationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "web_acl_id", params.web_acl_id, TF.resourceIdValue);
  TF.addField(fields, "resource_arn", params.resource_arn, TF.resourceArnValue);
  return fields;
}

export interface SecretsmanagerSecretParams {
  name?: string;
  name_prefix?: string;
  description?: string;
  tags?: TF.TagsMap;
}

export function fieldsFromSecretsmanagerSecretParams(params: SecretsmanagerSecretParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "name_prefix", params.name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface SecretsmanagerSecretVersionParams {
  secret_id: SecretsmanagerSecretId;
  secret_string?: string;
  secret_binary?: string;
  version_stages?: (string)[];
}

export function fieldsFromSecretsmanagerSecretVersionParams(params: SecretsmanagerSecretVersionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "secret_id", params.secret_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "secret_string", params.secret_string, TF.stringValue);
  TF.addOptionalField(fields, "secret_binary", params.secret_binary, TF.stringValue);
  TF.addOptionalField(fields, "version_stages", params.version_stages, TF.listValue(TF.stringValue));
  return fields;
}

export interface CloudfrontCookiesParams {
  forward: 'all' | 'none' | 'whitelist';
  whitelisted_names?: (string)[];
}

export function fieldsFromCloudfrontCookiesParams(params: CloudfrontCookiesParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "forward", params.forward, TF.stringValue);
  TF.addOptionalField(fields, "whitelisted_names", params.whitelisted_names, TF.listValue(TF.stringValue));
  return fields;
}

export interface CloudfrontCustomOriginConfigParams {
  http_port: number;
  https_port: number;
  origin_protocol_policy: 'http-only' | 'https-only' | 'match-viewer';
  origin_ssl_protocols: ('SSLv3' | 'TLSv1' | 'TLSv1.1' | 'TLSv1.2')[];
  origin_keepalive_timeout?: number;
  origin_read_timeout?: number;
}

export function fieldsFromCloudfrontCustomOriginConfigParams(params: CloudfrontCustomOriginConfigParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "http_port", params.http_port, TF.numberValue);
  TF.addField(fields, "https_port", params.https_port, TF.numberValue);
  TF.addField(fields, "origin_protocol_policy", params.origin_protocol_policy, TF.stringValue);
  TF.addField(fields, "origin_ssl_protocols", params.origin_ssl_protocols, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "origin_keepalive_timeout", params.origin_keepalive_timeout, TF.numberValue);
  TF.addOptionalField(fields, "origin_read_timeout", params.origin_read_timeout, TF.numberValue);
  return fields;
}

export interface CloudfrontCustomErrorResponseParams {
  error_code: number;
  response_code?: number;
  response_page_path?: string;
  error_caching_min_ttl?: number;
}

export function fieldsFromCloudfrontCustomErrorResponseParams(params: CloudfrontCustomErrorResponseParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "error_code", params.error_code, TF.numberValue);
  TF.addOptionalField(fields, "response_code", params.response_code, TF.numberValue);
  TF.addOptionalField(fields, "response_page_path", params.response_page_path, TF.stringValue);
  TF.addOptionalField(fields, "error_caching_min_ttl", params.error_caching_min_ttl, TF.numberValue);
  return fields;
}

export interface CloudfrontCacheBehaviourParams {
  allowed_methods: (string)[];
  cached_methods: (string)[];
  forwarded_values: CloudfrontForwardedValuesParams;
  /**
  path_pattern cannot be set for default cache behaviour, defaults to *
  */
  path_pattern?: string;
  compress?: boolean;
  default_ttl?: number;
  min_ttl?: number;
  max_ttl?: number;
  target_origin_id: string;
  viewer_protocol_policy: 'allow-all' | 'https-only' | 'redirect-to-https';
}

export function fieldsFromCloudfrontCacheBehaviourParams(params: CloudfrontCacheBehaviourParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "allowed_methods", params.allowed_methods, TF.listValue(TF.stringValue));
  TF.addField(fields, "cached_methods", params.cached_methods, TF.listValue(TF.stringValue));
  TF.addField(fields, "forwarded_values", params.forwarded_values, (v) => TF.mapValue(fieldsFromCloudfrontForwardedValuesParams(v)));
  TF.addOptionalField(fields, "path_pattern", params.path_pattern, TF.stringValue);
  TF.addOptionalField(fields, "compress", params.compress, TF.booleanValue);
  TF.addOptionalField(fields, "default_ttl", params.default_ttl, TF.numberValue);
  TF.addOptionalField(fields, "min_ttl", params.min_ttl, TF.numberValue);
  TF.addOptionalField(fields, "max_ttl", params.max_ttl, TF.numberValue);
  TF.addField(fields, "target_origin_id", params.target_origin_id, TF.stringValue);
  TF.addField(fields, "viewer_protocol_policy", params.viewer_protocol_policy, TF.stringValue);
  return fields;
}

export interface CloudfrontDistributionParams {
  default_cache_behavior: CloudfrontCacheBehaviourParams;
  enabled: boolean;
  origin: (CloudfrontOriginParams)[];
  restrictions: CloudfrontRestrictionsParams;
  viewer_certificate: CloudfrontViewerCertificateParams;
  aliases?: (string)[];
  is_ipv6_enabled?: boolean;
  custom_error_response?: (CloudfrontCustomErrorResponseParams)[];
  tags?: TF.TagsMap;
}

export function fieldsFromCloudfrontDistributionParams(params: CloudfrontDistributionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "default_cache_behavior", params.default_cache_behavior, (v) => TF.mapValue(fieldsFromCloudfrontCacheBehaviourParams(v)));
  TF.addField(fields, "enabled", params.enabled, TF.booleanValue);
  TF.addField(fields, "origin", params.origin, TF.listValue((v) => TF.mapValue(fieldsFromCloudfrontOriginParams(v))));
  TF.addField(fields, "restrictions", params.restrictions, (v) => TF.mapValue(fieldsFromCloudfrontRestrictionsParams(v)));
  TF.addField(fields, "viewer_certificate", params.viewer_certificate, (v) => TF.mapValue(fieldsFromCloudfrontViewerCertificateParams(v)));
  TF.addOptionalField(fields, "aliases", params.aliases, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "is_ipv6_enabled", params.is_ipv6_enabled, TF.booleanValue);
  TF.addOptionalField(fields, "custom_error_response", params.custom_error_response, TF.listValue((v) => TF.mapValue(fieldsFromCloudfrontCustomErrorResponseParams(v))));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface CloudfrontForwardedValuesParams {
  cookies: CloudfrontCookiesParams;
  query_string: boolean;
}

export function fieldsFromCloudfrontForwardedValuesParams(params: CloudfrontForwardedValuesParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "cookies", params.cookies, (v) => TF.mapValue(fieldsFromCloudfrontCookiesParams(v)));
  TF.addField(fields, "query_string", params.query_string, TF.booleanValue);
  return fields;
}

export interface CloudfrontOriginParams {
  domain_name: string;
  origin_id: string;
  s3_origin_config?: CloudfrontS3OriginConfigParams;
  custom_origin_config?: CloudfrontCustomOriginConfigParams;
}

export function fieldsFromCloudfrontOriginParams(params: CloudfrontOriginParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addField(fields, "origin_id", params.origin_id, TF.stringValue);
  TF.addOptionalField(fields, "s3_origin_config", params.s3_origin_config, (v) => TF.mapValue(fieldsFromCloudfrontS3OriginConfigParams(v)));
  TF.addOptionalField(fields, "custom_origin_config", params.custom_origin_config, (v) => TF.mapValue(fieldsFromCloudfrontCustomOriginConfigParams(v)));
  return fields;
}

export interface CloudfrontGeoRestrictionsParams {
  restriction_type: 'none' | 'whitelist' | 'blacklist';
  locations?: (string)[];
}

export function fieldsFromCloudfrontGeoRestrictionsParams(params: CloudfrontGeoRestrictionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "restriction_type", params.restriction_type, TF.stringValue);
  TF.addOptionalField(fields, "locations", params.locations, TF.listValue(TF.stringValue));
  return fields;
}

export interface CloudfrontRestrictionsParams {
  geo_restriction: CloudfrontGeoRestrictionsParams;
}

export function fieldsFromCloudfrontRestrictionsParams(params: CloudfrontRestrictionsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "geo_restriction", params.geo_restriction, (v) => TF.mapValue(fieldsFromCloudfrontGeoRestrictionsParams(v)));
  return fields;
}

export interface CloudfrontS3OriginConfigParams {
}

export function fieldsFromCloudfrontS3OriginConfigParams(params: CloudfrontS3OriginConfigParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  return fields;
}

export interface CloudfrontViewerCertificateParams {
  cloudfront_default_certificate?: boolean;
  acm_certificate_arn?: AT.ArnT<"AcmCertificate">;
  minimum_protocol_version?: 'SSLv3' | 'TLSv1' | 'TLSv1_2016' | 'TLSv1.1_2016' | 'TLSv1.2_2018' | 'TLSv1.2_2019';
  ssl_support_method?: 'vip' | 'sni-only';
}

export function fieldsFromCloudfrontViewerCertificateParams(params: CloudfrontViewerCertificateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "cloudfront_default_certificate", params.cloudfront_default_certificate, TF.booleanValue);
  TF.addOptionalField(fields, "acm_certificate_arn", params.acm_certificate_arn, TF.resourceArnValue);
  TF.addOptionalField(fields, "minimum_protocol_version", params.minimum_protocol_version, TF.stringValue);
  TF.addOptionalField(fields, "ssl_support_method", params.ssl_support_method, TF.stringValue);
  return fields;
}

export interface ApiGatewayRestApiParams {
  name: string;
  description?: string;
}

export function fieldsFromApiGatewayRestApiParams(params: ApiGatewayRestApiParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface ApiGatewayResourceParams {
  rest_api_id: ApiGatewayRestApiId;
  parent_id: ApiGatewayRestApiId;
  path_part: string;
}

export function fieldsFromApiGatewayResourceParams(params: ApiGatewayResourceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "parent_id", params.parent_id, TF.resourceIdValue);
  TF.addField(fields, "path_part", params.path_part, TF.stringValue);
  return fields;
}

export interface ApiGatewayMethodParams {
  rest_api_id: ApiGatewayRestApiId;
  resource_id: ApiGatewayResourceId;
  http_method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'ANY';
  authorization: 'NONE' | 'CUSTOM' | 'AWS_IAM' | 'COGNITO_USER_POOLS';
}

export function fieldsFromApiGatewayMethodParams(params: ApiGatewayMethodParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "resource_id", params.resource_id, TF.resourceIdValue);
  TF.addField(fields, "http_method", params.http_method, TF.stringValue);
  TF.addField(fields, "authorization", params.authorization, TF.stringValue);
  return fields;
}

export interface ApiGatewayMethodResponseParams {
  rest_api_id: ApiGatewayRestApiId;
  resource_id: ApiGatewayResourceId;
  http_method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'ANY';
  status_code: string;
  response_models?: TF.TagsMap;
  response_parameters?: TF.TagsMap;
}

export function fieldsFromApiGatewayMethodResponseParams(params: ApiGatewayMethodResponseParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "resource_id", params.resource_id, TF.resourceIdValue);
  TF.addField(fields, "http_method", params.http_method, TF.stringValue);
  TF.addField(fields, "status_code", params.status_code, TF.stringValue);
  TF.addOptionalField(fields, "response_models", params.response_models, TF.tagsValue);
  TF.addOptionalField(fields, "response_parameters", params.response_parameters, TF.tagsValue);
  return fields;
}

export interface ApiGatewayIntegrationParams {
  rest_api_id: ApiGatewayRestApiId;
  resource_id: ApiGatewayResourceId;
  http_method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'ANY';
  integration_http_method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTION';
  uri?: string;
  request_templates?: TF.TagsMap;
  type: 'HTTP' | 'MOCK' | 'AWS' | 'AWS_PROXY' | 'HTTP_PROXY';
}

export function fieldsFromApiGatewayIntegrationParams(params: ApiGatewayIntegrationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "resource_id", params.resource_id, TF.resourceIdValue);
  TF.addField(fields, "http_method", params.http_method, TF.stringValue);
  TF.addOptionalField(fields, "integration_http_method", params.integration_http_method, TF.stringValue);
  TF.addOptionalField(fields, "uri", params.uri, TF.stringValue);
  TF.addOptionalField(fields, "request_templates", params.request_templates, TF.tagsValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface ApiGatewayIntegrationResponseParams {
  rest_api_id: ApiGatewayRestApiId;
  resource_id: ApiGatewayResourceId;
  http_method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'OPTIONS' | 'ANY';
  status_code: string;
  response_parameters?: TF.TagsMap;
}

export function fieldsFromApiGatewayIntegrationResponseParams(params: ApiGatewayIntegrationResponseParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "resource_id", params.resource_id, TF.resourceIdValue);
  TF.addField(fields, "http_method", params.http_method, TF.stringValue);
  TF.addField(fields, "status_code", params.status_code, TF.stringValue);
  TF.addOptionalField(fields, "response_parameters", params.response_parameters, TF.tagsValue);
  return fields;
}

export interface ApiGatewayDeploymentParams {
  rest_api_id: ApiGatewayRestApiId;
  stage_name: string;
  description?: string;
}

export function fieldsFromApiGatewayDeploymentParams(params: ApiGatewayDeploymentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "rest_api_id", params.rest_api_id, TF.resourceIdValue);
  TF.addField(fields, "stage_name", params.stage_name, TF.stringValue);
  TF.addOptionalField(fields, "description", params.description, TF.stringValue);
  return fields;
}

export interface ApiGatewayDomainNameParams {
  domain_name: string;
  certificate_arn?: AT.ArnT<"AcmCertificate">;
}

export function fieldsFromApiGatewayDomainNameParams(params: ApiGatewayDomainNameParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addOptionalField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  return fields;
}

export interface ApiGatewayBasePathMappingParams {
  domain_name: string;
  api_id: ApiGatewayRestApiId;
  stage_name?: string;
  base_path?: string;
}

export function fieldsFromApiGatewayBasePathMappingParams(params: ApiGatewayBasePathMappingParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain_name", params.domain_name, TF.stringValue);
  TF.addField(fields, "api_id", params.api_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "stage_name", params.stage_name, TF.stringValue);
  TF.addOptionalField(fields, "base_path", params.base_path, TF.stringValue);
  return fields;
}

export interface S3BucketNotificationQueueParams {
  id?: string;
  queue_arn: AT.ArnT<"SqsQueue">;
  events: (string)[];
  filter_prefix?: string;
  filter_suffix?: string;
}

export function fieldsFromS3BucketNotificationQueueParams(params: S3BucketNotificationQueueParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "id", params.id, TF.stringValue);
  TF.addField(fields, "queue_arn", params.queue_arn, TF.resourceArnValue);
  TF.addField(fields, "events", params.events, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "filter_prefix", params.filter_prefix, TF.stringValue);
  TF.addOptionalField(fields, "filter_suffix", params.filter_suffix, TF.stringValue);
  return fields;
}

export interface S3BucketNotificationLambdaParams {
  id?: string;
  lambda_function_arn: AT.ArnT<"LambdaFunction">;
  events: (string)[];
  filter_prefix?: string;
  filter_suffix?: string;
}

export function fieldsFromS3BucketNotificationLambdaParams(params: S3BucketNotificationLambdaParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "id", params.id, TF.stringValue);
  TF.addField(fields, "lambda_function_arn", params.lambda_function_arn, TF.resourceArnValue);
  TF.addField(fields, "events", params.events, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "filter_prefix", params.filter_prefix, TF.stringValue);
  TF.addOptionalField(fields, "filter_suffix", params.filter_suffix, TF.stringValue);
  return fields;
}

export interface S3BucketNotificationParams {
  bucket: string;
  queue?: S3BucketNotificationQueueParams;
  lambda_function?: S3BucketNotificationLambdaParams;
}

export function fieldsFromS3BucketNotificationParams(params: S3BucketNotificationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "bucket", params.bucket, TF.stringValue);
  TF.addOptionalField(fields, "queue", params.queue, (v) => TF.mapValue(fieldsFromS3BucketNotificationQueueParams(v)));
  TF.addOptionalField(fields, "lambda_function", params.lambda_function, (v) => TF.mapValue(fieldsFromS3BucketNotificationLambdaParams(v)));
  return fields;
}

export interface CognitoInviteMessageTemplateParams {
  email_message?: string;
  email_subject?: string;
  sms_message?: string;
}

export function fieldsFromCognitoInviteMessageTemplateParams(params: CognitoInviteMessageTemplateParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "email_message", params.email_message, TF.stringValue);
  TF.addOptionalField(fields, "email_subject", params.email_subject, TF.stringValue);
  TF.addOptionalField(fields, "sms_message", params.sms_message, TF.stringValue);
  return fields;
}

export interface CognitoAdminCreateUsersParams {
  allow_admin_create_user_only?: boolean;
  invite_message_template?: CognitoInviteMessageTemplateParams;
  unused_account_Validity_days?: number;
}

export function fieldsFromCognitoAdminCreateUsersParams(params: CognitoAdminCreateUsersParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "allow_admin_create_user_only", params.allow_admin_create_user_only, TF.booleanValue);
  TF.addOptionalField(fields, "invite_message_template", params.invite_message_template, (v) => TF.mapValue(fieldsFromCognitoInviteMessageTemplateParams(v)));
  TF.addOptionalField(fields, "unused_account_Validity_days", params.unused_account_Validity_days, TF.numberValue);
  return fields;
}

export interface CognitoSchemaAttributesParams {
  name: string;
  attribute_data_type: 'Boolean' | 'Number' | 'String' | 'DateTime';
  developer_only_attribute?: boolean;
  string_attribute_constraints?: CognitoSchemaStringAttributeConstraintsParams;
  number_attribute_constraints?: CognitoSchemaNumberAttributeConstraintsParams;
  mutable?: boolean;
  required?: boolean;
}

export function fieldsFromCognitoSchemaAttributesParams(params: CognitoSchemaAttributesParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "attribute_data_type", params.attribute_data_type, TF.stringValue);
  TF.addOptionalField(fields, "developer_only_attribute", params.developer_only_attribute, TF.booleanValue);
  TF.addOptionalField(fields, "string_attribute_constraints", params.string_attribute_constraints, (v) => TF.mapValue(fieldsFromCognitoSchemaStringAttributeConstraintsParams(v)));
  TF.addOptionalField(fields, "number_attribute_constraints", params.number_attribute_constraints, (v) => TF.mapValue(fieldsFromCognitoSchemaNumberAttributeConstraintsParams(v)));
  TF.addOptionalField(fields, "mutable", params.mutable, TF.booleanValue);
  TF.addOptionalField(fields, "required", params.required, TF.booleanValue);
  return fields;
}

export interface CognitoSchemaStringAttributeConstraintsParams {
  min_length?: number;
  max_length?: number;
}

export function fieldsFromCognitoSchemaStringAttributeConstraintsParams(params: CognitoSchemaStringAttributeConstraintsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "min_length", params.min_length, TF.numberValue);
  TF.addOptionalField(fields, "max_length", params.max_length, TF.numberValue);
  return fields;
}

export interface CognitoSchemaNumberAttributeConstraintsParams {
  min_value?: number;
  max_value?: number;
}

export function fieldsFromCognitoSchemaNumberAttributeConstraintsParams(params: CognitoSchemaNumberAttributeConstraintsParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "min_value", params.min_value, TF.numberValue);
  TF.addOptionalField(fields, "max_value", params.max_value, TF.numberValue);
  return fields;
}

export interface CognitoUserPoolParams {
  name: string;
  admin_create_user_config?: CognitoAdminCreateUsersParams;
  auto_verified_attributes?: ('email' | 'phone_number')[];
  schema?: (CognitoSchemaAttributesParams)[];
  username_attributes?: ('email' | 'phone_number')[];
  sms_authentication_message?: string;
  sms_verification_message?: string;
  tags?: TF.TagsMap;
}

export function fieldsFromCognitoUserPoolParams(params: CognitoUserPoolParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "admin_create_user_config", params.admin_create_user_config, (v) => TF.mapValue(fieldsFromCognitoAdminCreateUsersParams(v)));
  TF.addOptionalField(fields, "auto_verified_attributes", params.auto_verified_attributes, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "schema", params.schema, TF.listValue((v) => TF.mapValue(fieldsFromCognitoSchemaAttributesParams(v))));
  TF.addOptionalField(fields, "username_attributes", params.username_attributes, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "sms_authentication_message", params.sms_authentication_message, TF.stringValue);
  TF.addOptionalField(fields, "sms_verification_message", params.sms_verification_message, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface CognitoUserPoolClientParams {
  name: string;
  user_pool_id: CognitoUserPoolId;
  read_attributes?: (string)[];
  write_attributes?: (string)[];
  allowed_oauth_flows?: ('code' | 'implicit' | 'client_credentials')[];
  allowed_oauth_flows_user_pool_client?: boolean;
  allowed_oauth_scopes?: ('phone' | 'email' | 'openid' | 'profile' | 'aws.cognito.signin.user.admin')[];
  callback_urls?: (string)[];
  logout_urls?: (string)[];
  supported_identity_providers?: (string)[];
}

export function fieldsFromCognitoUserPoolClientParams(params: CognitoUserPoolClientParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "user_pool_id", params.user_pool_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "read_attributes", params.read_attributes, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "write_attributes", params.write_attributes, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "allowed_oauth_flows", params.allowed_oauth_flows, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "allowed_oauth_flows_user_pool_client", params.allowed_oauth_flows_user_pool_client, TF.booleanValue);
  TF.addOptionalField(fields, "allowed_oauth_scopes", params.allowed_oauth_scopes, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "callback_urls", params.callback_urls, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "logout_urls", params.logout_urls, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "supported_identity_providers", params.supported_identity_providers, TF.listValue(TF.stringValue));
  return fields;
}

export interface CognitoUserPoolDomainParams {
  domain: string;
  user_pool_id: CognitoUserPoolId;
  certificate_arn?: AT.ArnT<"AcmCertificate">;
}

export function fieldsFromCognitoUserPoolDomainParams(params: CognitoUserPoolDomainParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "domain", params.domain, TF.stringValue);
  TF.addField(fields, "user_pool_id", params.user_pool_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "certificate_arn", params.certificate_arn, TF.resourceArnValue);
  return fields;
}

export interface CognitoIdentityProviderParams {
  client_id?: CognitoUserPoolId;
  provider_name?: string;
  server_side_token_check?: boolean;
}

export function fieldsFromCognitoIdentityProviderParams(params: CognitoIdentityProviderParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "client_id", params.client_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "provider_name", params.provider_name, TF.stringValue);
  TF.addOptionalField(fields, "server_side_token_check", params.server_side_token_check, TF.booleanValue);
  return fields;
}

export interface CognitoIdentityPoolParams {
  identity_pool_name: string;
  allow_unauthenticated_identities: boolean;
  cognito_identity_providers?: (CognitoIdentityProviderParams)[];
}

export function fieldsFromCognitoIdentityPoolParams(params: CognitoIdentityPoolParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "identity_pool_name", params.identity_pool_name, TF.stringValue);
  TF.addField(fields, "allow_unauthenticated_identities", params.allow_unauthenticated_identities, TF.booleanValue);
  TF.addOptionalField(fields, "cognito_identity_providers", params.cognito_identity_providers, TF.listValue((v) => TF.mapValue(fieldsFromCognitoIdentityProviderParams(v))));
  return fields;
}

export interface CognitoIdentityPoolRolesAttachmentParams {
  identity_pool_id: CognitoIdentityPoolId;
  roles: CognitoIdentityPoolRolesAttachmentRolesParams;
}

export function fieldsFromCognitoIdentityPoolRolesAttachmentParams(params: CognitoIdentityPoolRolesAttachmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "identity_pool_id", params.identity_pool_id, TF.resourceIdValue);
  TF.addField(fields, "roles", params.roles, (v) => TF.mapValue(fieldsFromCognitoIdentityPoolRolesAttachmentRolesParams(v)));
  return fields;
}

export interface CognitoIdentityPoolRolesAttachmentRolesParams {
  authenticated?: AT.ArnT<"IamRole">;
  unauthenticated?: AT.ArnT<"IamRole">;
}

export function fieldsFromCognitoIdentityPoolRolesAttachmentRolesParams(params: CognitoIdentityPoolRolesAttachmentRolesParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "authenticated", params.authenticated, TF.resourceArnValue);
  TF.addOptionalField(fields, "unauthenticated", params.unauthenticated, TF.resourceArnValue);
  return fields;
}

export interface EksClusterParams {
  name: string;
  role_arn: AT.ArnT<"IamRole">;
  vpc_config: EksClusterVpcConfigParams;
  enabled_cluster_log_Types?: ('api' | 'audit' | 'authenticator' | 'controllerManager' | 'scheduler')[];
  version?: string;
}

export function fieldsFromEksClusterParams(params: EksClusterParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "role_arn", params.role_arn, TF.resourceArnValue);
  TF.addField(fields, "vpc_config", params.vpc_config, (v) => TF.mapValue(fieldsFromEksClusterVpcConfigParams(v)));
  TF.addOptionalField(fields, "enabled_cluster_log_Types", params.enabled_cluster_log_Types, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "version", params.version, TF.stringValue);
  return fields;
}

export interface EksClusterVpcConfigParams {
  endpoint_private_access?: boolean;
  endpoint_public_access?: boolean;
  security_group_ids?: (SecurityGroupId)[];
  subnet_ids: (SubnetId)[];
}

export function fieldsFromEksClusterVpcConfigParams(params: EksClusterVpcConfigParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "endpoint_private_access", params.endpoint_private_access, TF.booleanValue);
  TF.addOptionalField(fields, "endpoint_public_access", params.endpoint_public_access, TF.booleanValue);
  TF.addOptionalField(fields, "security_group_ids", params.security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addField(fields, "subnet_ids", params.subnet_ids, TF.listValue(TF.resourceIdValue));
  return fields;
}

export interface BatchComputeEnvironmentParams {
  compute_environment_name?: string;
  compute_environment_name_prefix?: string;
  compute_resources?: BatchComputeEnvironmentComputeResourceParams;
  service_role: AT.ArnT<"IamRole">;
  state?: 'ENABLED' | 'DISABLED';
  tags?: TF.TagsMap;
  type: 'MANAGED' | 'UNMANAGED';
}

export function fieldsFromBatchComputeEnvironmentParams(params: BatchComputeEnvironmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "compute_environment_name", params.compute_environment_name, TF.stringValue);
  TF.addOptionalField(fields, "compute_environment_name_prefix", params.compute_environment_name_prefix, TF.stringValue);
  TF.addOptionalField(fields, "compute_resources", params.compute_resources, (v) => TF.mapValue(fieldsFromBatchComputeEnvironmentComputeResourceParams(v)));
  TF.addField(fields, "service_role", params.service_role, TF.resourceArnValue);
  TF.addOptionalField(fields, "state", params.state, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface BatchComputeEnvironmentComputeResourceParams {
  allocation_strategy?: 'BEST_FIT_PROGRESSIVE' | 'SPOT_CAPACITY_OPTIMIZED' | 'BEST_FIT';
  bid_percentage?: number;
  desired_vcpus?: number;
  ec2_key_pair?: AT.KeyName;
  image_id?: AT.Ami;
  instance_role: AT.ArnT<"IamInstanceProfile">;
  instance_type: (string)[];
  max_vcpus: number;
  min_vcpus: number;
  security_group_ids: (SecurityGroupId)[];
  spot_iam_fleet_role?: AT.ArnT<"IamRole">;
  subnets: (SubnetId)[];
  tags?: TF.TagsMap;
  type: 'EC2' | 'SPOT';
}

export function fieldsFromBatchComputeEnvironmentComputeResourceParams(params: BatchComputeEnvironmentComputeResourceParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "allocation_strategy", params.allocation_strategy, TF.stringValue);
  TF.addOptionalField(fields, "bid_percentage", params.bid_percentage, TF.numberValue);
  TF.addOptionalField(fields, "desired_vcpus", params.desired_vcpus, TF.numberValue);
  TF.addOptionalField(fields, "ec2_key_pair", params.ec2_key_pair, TF.stringAliasValue);
  TF.addOptionalField(fields, "image_id", params.image_id, TF.stringAliasValue);
  TF.addField(fields, "instance_role", params.instance_role, TF.resourceArnValue);
  TF.addField(fields, "instance_type", params.instance_type, TF.listValue(TF.stringValue));
  TF.addField(fields, "max_vcpus", params.max_vcpus, TF.numberValue);
  TF.addField(fields, "min_vcpus", params.min_vcpus, TF.numberValue);
  TF.addField(fields, "security_group_ids", params.security_group_ids, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "spot_iam_fleet_role", params.spot_iam_fleet_role, TF.resourceArnValue);
  TF.addField(fields, "subnets", params.subnets, TF.listValue(TF.resourceIdValue));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface BatchJobDefinitionRetryStrategyParams {
  attempts?: number;
}

export function fieldsFromBatchJobDefinitionRetryStrategyParams(params: BatchJobDefinitionRetryStrategyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "attempts", params.attempts, TF.numberValue);
  return fields;
}

export interface BatchJobDefinitionTimeoutParams {
  /**
  The time duration in seconds after which AWS Batch terminates your jobs if they have not finished.
  The minimum value for the timeout is 60 seconds.
  */
  attempt_duration_seconds ?: number;
}

export function fieldsFromBatchJobDefinitionTimeoutParams(params: BatchJobDefinitionTimeoutParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addOptionalField(fields, "attempt_duration_seconds ", params.attempt_duration_seconds , TF.numberValue);
  return fields;
}

export interface BatchJobDefinitionParams {
  name: string;
  /**
  A valid container properties provided as a single valid JSON document.
  */
  container_properties?: string;
  parameters?: (string)[];
  retry_strategy?: BatchJobDefinitionRetryStrategyParams;
  tags?: TF.TagsMap;
  timeout?: BatchJobDefinitionTimeoutParams;
  type: 'container';
}

export function fieldsFromBatchJobDefinitionParams(params: BatchJobDefinitionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "container_properties", params.container_properties, TF.stringValue);
  TF.addOptionalField(fields, "parameters", params.parameters, TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "retry_strategy", params.retry_strategy, (v) => TF.mapValue(fieldsFromBatchJobDefinitionRetryStrategyParams(v)));
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  TF.addOptionalField(fields, "timeout", params.timeout, (v) => TF.mapValue(fieldsFromBatchJobDefinitionTimeoutParams(v)));
  TF.addField(fields, "type", params.type, TF.stringValue);
  return fields;
}

export interface BatchJobQueueParams {
  name: string;
  /**
  Specifies the set of compute environments mapped to a job queue and their order.
  The position of the compute environments in the list will dictate the order.
  You can associate up to 3 compute environments with a job queue.
  */
  compute_environments: (AT.ArnT<"BatchComputeEnvironment">)[];
  /**
  The priority of the job queue.
  Job queues with a higher priority are evaluated first when associated with the same compute environment.
  */
  priority: number;
  state: 'ENABLED' | 'DISABLED';
  tags?: TF.TagsMap;
}

export function fieldsFromBatchJobQueueParams(params: BatchJobQueueParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "compute_environments", params.compute_environments, TF.listValue(TF.resourceArnValue));
  TF.addField(fields, "priority", params.priority, TF.numberValue);
  TF.addField(fields, "state", params.state, TF.stringValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

export interface StepAdjustmentParams {
  /**
  The number of members by which to scale, when the adjustment bounds are breached.
  A positive value scales up. A negative value scales down.
  */
  scaling_adjustment : number;
  /**
  The lower bound for the difference between the alarm threshold and the CloudWatch metric.
  Without a value, AWS will treat this bound as infinity.
  */
  metric_interval_lower_bound?: number;
  /**
  The upper bound for the difference between the alarm threshold and the CloudWatch metric.
  Without a value, AWS will treat this bound as infinity. The upper bound must be greater than the lower bound.
  */
  metric_interval_upper_bound?: number;
}

export function fieldsFromStepAdjustmentParams(params: StepAdjustmentParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "scaling_adjustment ", params.scaling_adjustment , TF.numberValue);
  TF.addOptionalField(fields, "metric_interval_lower_bound", params.metric_interval_lower_bound, TF.numberValue);
  TF.addOptionalField(fields, "metric_interval_upper_bound", params.metric_interval_upper_bound, TF.numberValue);
  return fields;
}

export interface PredefinedMetricSpecificationParams {
  /**
  ASGAverageCPUUtilization : Average CPU utilization of the Auto Scaling group.
  ASGAverageNetworkIn : Average number of bytes received on all network interfaces by the Auto Scaling group.
  ASGAverageNetworkOut : Average number of bytes sent out on all network interfaces by the Auto Scaling group.
  ALBRequestCountPerTarget : Number of requests completed per target in an Application Load Balancer target group.
  */
  predefined_metric_type: 'ASGAverageCPUUtilization' | 'ASGAverageNetworkIn' | 'ASGAverageNetworkOut' | 'ALBRequestCountPerTarget';
  /**
  Identifies the resource associated with the metric type.
  */
  resource_label?: string;
}

export function fieldsFromPredefinedMetricSpecificationParams(params: PredefinedMetricSpecificationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "predefined_metric_type", params.predefined_metric_type, TF.stringValue);
  TF.addOptionalField(fields, "resource_label", params.resource_label, TF.stringValue);
  return fields;
}

export interface MetricDimensionParams {
  name: string;
  value: string;
}

export function fieldsFromMetricDimensionParams(params: MetricDimensionParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "value", params.value, TF.stringValue);
  return fields;
}

export interface CustomizedMetricSpecificationParams {
  metric_name: string;
  namespace: string;
  statistic: string;
  metric_dimension?: (MetricDimensionParams)[];
  unit?: string;
}

export function fieldsFromCustomizedMetricSpecificationParams(params: CustomizedMetricSpecificationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "metric_name", params.metric_name, TF.stringValue);
  TF.addField(fields, "namespace", params.namespace, TF.stringValue);
  TF.addField(fields, "statistic", params.statistic, TF.stringValue);
  TF.addOptionalField(fields, "metric_dimension", params.metric_dimension, TF.listValue((v) => TF.mapValue(fieldsFromMetricDimensionParams(v))));
  TF.addOptionalField(fields, "unit", params.unit, TF.stringValue);
  return fields;
}

export interface TargetTrackingConfigurationParams {
  target_value: number;
  predefined_metric_specification?: PredefinedMetricSpecificationParams;
  customized_metric_specification?: CustomizedMetricSpecificationParams;
  disable_scale_in?: boolean;
}

export function fieldsFromTargetTrackingConfigurationParams(params: TargetTrackingConfigurationParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "target_value", params.target_value, TF.numberValue);
  TF.addOptionalField(fields, "predefined_metric_specification", params.predefined_metric_specification, (v) => TF.mapValue(fieldsFromPredefinedMetricSpecificationParams(v)));
  TF.addOptionalField(fields, "customized_metric_specification", params.customized_metric_specification, (v) => TF.mapValue(fieldsFromCustomizedMetricSpecificationParams(v)));
  TF.addOptionalField(fields, "disable_scale_in", params.disable_scale_in, TF.booleanValue);
  return fields;
}

export interface SimpleScalingParams {
  policy_type: 'SimpleScaling';
  /**
  The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
  */
  cooldown?: number;
  /**
  The number of instances by which to scale.
  adjustment_type determines the interpretation of this number
  (e.g., as an absolute number or as a percentage of the existing Auto Scaling group size).
  A positive increment adds to the current capacity and a negative value removes from the current capacity.
  */
  scaling_adjustment: number;
}

export function fieldsFromSimpleScalingParams(params: SimpleScalingParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "policy_type", params.policy_type, TF.stringValue);
  TF.addOptionalField(fields, "cooldown", params.cooldown, TF.numberValue);
  TF.addField(fields, "scaling_adjustment", params.scaling_adjustment, TF.numberValue);
  return fields;
}

export interface StepScalingParams {
  policy_type: 'StepScaling';
  metric_aggregation_type: 'Minimum' | 'Maximum' | 'Average';
  step_adjustment: (StepAdjustmentParams)[];
  /**
  The estimated time, in seconds, until a newly launched instance will contribute CloudWatch metrics.
  Without a value, AWS will default to the group's specified cooldown period.
  */
  estimated_instance_warmup?: number;
}

export function fieldsFromStepScalingParams(params: StepScalingParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "policy_type", params.policy_type, TF.stringValue);
  TF.addField(fields, "metric_aggregation_type", params.metric_aggregation_type, TF.stringValue);
  TF.addField(fields, "step_adjustment", params.step_adjustment, TF.listValue((v) => TF.mapValue(fieldsFromStepAdjustmentParams(v))));
  TF.addOptionalField(fields, "estimated_instance_warmup", params.estimated_instance_warmup, TF.numberValue);
  return fields;
}

export interface TargetTrackingScalingParams {
  policy_type: 'TargetTrackingScaling';
  target_tracking_configuration: TargetTrackingConfigurationParams;
  /**
  The estimated time, in seconds, until a newly launched instance will contribute CloudWatch metrics.
  Without a value, AWS will default to the group's specified cooldown period.
  */
  estimated_instance_warmup?: number;
}

export function fieldsFromTargetTrackingScalingParams(params: TargetTrackingScalingParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "policy_type", params.policy_type, TF.stringValue);
  TF.addField(fields, "target_tracking_configuration", params.target_tracking_configuration, (v) => TF.mapValue(fieldsFromTargetTrackingConfigurationParams(v)));
  TF.addOptionalField(fields, "estimated_instance_warmup", params.estimated_instance_warmup, TF.numberValue);
  return fields;
}

/**
 *  Provides an AutoScaling Scaling Policy resource..
 *
 *  see https://www.terraform.io/docs/providers/aws/r/autoscaling_policy.html
 */
export function createAutoscalingPolicy(tfgen: TF.Generator, rname: string, params: AutoscalingPolicyParams): AutoscalingPolicy {
  const fields = fieldsFromAutoscalingPolicyParams(params);
  const resource = tfgen.createTypedResource('AutoscalingPolicy', 'aws_autoscaling_policy', rname, fields);
  const name: string =  '${' + TF.resourceName(resource) + '.name}';
  const autoscaling_group_name: string =  '${' + TF.resourceName(resource) + '.autoscaling_group_name}';
  const adjustment_type: string =  '${' + TF.resourceName(resource) + '.adjustment_type}';
  const policy_type: string =  '${' + TF.resourceName(resource) + '.policy_type}';
  const arn: AutoscalingPolicyArn = AT.arnT('${' + TF.resourceName(resource) + '.arn}', 'AutoscalingPolicy');

  return {
    ...resource,
    name,
    autoscaling_group_name,
    adjustment_type,
    policy_type,
    arn,
  };
}

export interface AutoscalingPolicy extends TF.ResourceT<'AutoscalingPolicy'> {
  name: string;
  autoscaling_group_name: string;
  adjustment_type: string;
  policy_type: string;
  arn: AutoscalingPolicyArn;
}

export type AutoscalingPolicyId = {type:'AutoscalingPolicyId',value:string};
export type AutoscalingPolicyArn = AT.ArnT<"AutoscalingPolicy">;

export type AutoscalingPolicyParamsSimpleScaling = {
  kind:"simple_scaling"
  policy_type: 'SimpleScaling';
  /**
  The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
  */
  cooldown?: number;
  /**
  The number of instances by which to scale.
  adjustment_type determines the interpretation of this number
  (e.g., as an absolute number or as a percentage of the existing Auto Scaling group size).
  A positive increment adds to the current capacity and a negative value removes from the current capacity.
  */
  scaling_adjustment: number;
};

export type AutoscalingPolicyParamsStepScaling = {
  kind:"step_scaling"
  policy_type: 'StepScaling';
  metric_aggregation_type: 'Minimum' | 'Maximum' | 'Average';
  step_adjustment: (StepAdjustmentParams)[];
  /**
  The estimated time, in seconds, until a newly launched instance will contribute CloudWatch metrics.
  Without a value, AWS will default to the group's specified cooldown period.
  */
  estimated_instance_warmup?: number;
};

export type AutoscalingPolicyParamsTargetTrackingScaling = {
  kind:"target_tracking_scaling"
  policy_type: 'TargetTrackingScaling';
  target_tracking_configuration: TargetTrackingConfigurationParams;
  /**
  The estimated time, in seconds, until a newly launched instance will contribute CloudWatch metrics.
  Without a value, AWS will default to the group's specified cooldown period.
  */
  estimated_instance_warmup?: number;
};

export type AutoscalingPolicyParams = {
  name: string;
  autoscaling_group_name: AutoscalingGroupId;
  adjustment_type?: 'ChangeInCapacity' | 'ExactCapacity' | 'PercentChangeInCapacity';
} & (AutoscalingPolicyParamsSimpleScaling|AutoscalingPolicyParamsStepScaling|AutoscalingPolicyParamsTargetTrackingScaling)

export function fieldsFromAutoscalingPolicyParams(params: AutoscalingPolicyParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addField(fields, "autoscaling_group_name", params.autoscaling_group_name, TF.resourceIdValue);
  TF.addOptionalField(fields, "adjustment_type", params.adjustment_type, TF.stringValue);
  switch(params.kind){
    case "simple_scaling": {
      TF.addField(fields, "policy_type", params.policy_type, TF.stringValue);
      TF.addOptionalField(fields, "cooldown", params.cooldown, TF.numberValue);
      TF.addField(fields, "scaling_adjustment", params.scaling_adjustment, TF.numberValue);
      break;
    }
    case "step_scaling": {
      TF.addField(fields, "policy_type", params.policy_type, TF.stringValue);
      TF.addField(fields, "metric_aggregation_type", params.metric_aggregation_type, TF.stringValue);
      TF.addField(fields, "step_adjustment", params.step_adjustment, TF.listValue((v) => TF.mapValue(fieldsFromStepAdjustmentParams(v))));
      TF.addOptionalField(fields, "estimated_instance_warmup", params.estimated_instance_warmup, TF.numberValue);
      break;
    }
    case "target_tracking_scaling": {
      TF.addField(fields, "policy_type", params.policy_type, TF.stringValue);
      TF.addField(fields, "target_tracking_configuration", params.target_tracking_configuration, (v) => TF.mapValue(fieldsFromTargetTrackingConfigurationParams(v)));
      TF.addOptionalField(fields, "estimated_instance_warmup", params.estimated_instance_warmup, TF.numberValue);
      break;
    }
  }
  return fields;
}

export interface FilterParams {
  name : string;
  values : (string)[];
}

export function fieldsFromFilterParams(params: FilterParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name ", params.name , TF.stringValue);
  TF.addField(fields, "values ", params.values , TF.listValue(TF.stringValue));
  return fields;
}

export interface AmiParams {
  /**
  List of AMI owners to limit search.
  At least 1 value must be specified.
  Valid values: an AWS account ID, self (the current account),
  or an AWS owner alias (e.g. amazon, aws-marketplace, microsoft).
  */
  owners : (string)[];
  /**
  If more than one result is returned, use the most recent AMI.
  */
  most_recent?: boolean;
  /**
  One or more name/value pairs to filter off of.
  There are several valid keys, for a full reference, check out describe-images in the AWS CLI reference
  */
  filter?: (FilterParams)[];
  /**
  A regex string to apply to the AMI list returned by AWS.
  This allows more advanced filtering not supported from the AWS API.
  This filtering is done locally on what AWS returns, and could have a performance impact if the result is large.
  It is recommended to combine this with other options to narrow down the list AWS returns.
  */
  name_regex?: string;
}

export function fieldsFromAmiParams(params: AmiParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "owners ", params.owners , TF.listValue(TF.stringValue));
  TF.addOptionalField(fields, "most_recent", params.most_recent, TF.booleanValue);
  TF.addOptionalField(fields, "filter", params.filter, TF.listValue((v) => TF.mapValue(fieldsFromFilterParams(v))));
  TF.addOptionalField(fields, "name_regex", params.name_regex, TF.stringValue);
  return fields;
}

/**
 *  Use this data source to get the ID of a registered AMI for use in other resources.
 *
 *  see https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ami
 */
export function getAmiData(tfgen: TF.Generator, dname: string, params: AmiParams): AmiData {
  const fields = fieldsFromAmiParams(params);
  const resource = tfgen.createTypedDataSource('Ami', 'aws_ami', dname, fields);
  const id: AT.Ami =  {type: 'Ami', value: '${' + TF.dataSourceName(resource) + '.id}'};
  const arn: AT.Arn =  {type: 'Arn', value: '${' + TF.dataSourceName(resource) + '.arn}'};
  const description: string = '${' + TF.dataSourceName(resource) + '.description}';
  const image_id: AT.Ami =  {type: 'Ami', value: '${' + TF.dataSourceName(resource) + '.image_id}'};
  const name: string = '${' + TF.dataSourceName(resource) + '.name}';
  const owner_id: string = '${' + TF.dataSourceName(resource) + '.owner_id}';
  const public_: string = '${' + TF.dataSourceName(resource) + '.public}';
  const root_device_name: string = '${' + TF.dataSourceName(resource) + '.root_device_name}';
  const root_device_type: string = '${' + TF.dataSourceName(resource) + '.root_device_type}';
  const virtualization_type: string = '${' + TF.dataSourceName(resource) + '.virtualization_type}';

  return {
    ...resource,
    id,
    arn,
    description,
    image_id,
    name,
    owner_id,
    "public": public_,
    root_device_name,
    root_device_type,
    virtualization_type,
  };
}

export interface AmiData extends TF.DataSourceT<'Ami'> {
  id: AT.Ami;
  arn: AT.Arn;
  description: string;
  image_id: AT.Ami;
  name: string;
  owner_id: string;
  "public": string;
  root_device_name: string;
  root_device_type: string;
  virtualization_type: string;
}

export interface Route53ZoneVpcParams {
  vpc_id: VpcId;
  vpc_region?: AT.Region;
}

export function fieldsFromRoute53ZoneVpcParams(params: Route53ZoneVpcParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "vpc_id", params.vpc_id, TF.resourceIdValue);
  TF.addOptionalField(fields, "vpc_region", params.vpc_region, TF.stringAliasValue);
  return fields;
}

export interface Route53ZoneParams {
  name: string;
  comment?: string;
  vpc?: Route53ZoneVpcParams;
  force_destroy?: boolean;
  tags?: TF.TagsMap;
}

export function fieldsFromRoute53ZoneParams(params: Route53ZoneParams) : TF.ResourceFieldMap {
  const fields: TF.ResourceFieldMap = [];
  TF.addField(fields, "name", params.name, TF.stringValue);
  TF.addOptionalField(fields, "comment", params.comment, TF.stringValue);
  TF.addOptionalField(fields, "vpc", params.vpc, (v) => TF.mapValue(fieldsFromRoute53ZoneVpcParams(v)));
  TF.addOptionalField(fields, "force_destroy", params.force_destroy, TF.booleanValue);
  TF.addOptionalField(fields, "tags", params.tags, TF.tagsValue);
  return fields;
}

/**
 *  Provides a Route53 Hosted Zone resource.
 *
 *  see https://www.terraform.io/docs/providers/aws/r/route53_zone.html
 */
export function createRoute53Zone(tfgen: TF.Generator, rname: string, params: Route53ZoneParams): Route53Zone {
  const fields = fieldsFromRoute53ZoneParams(params);
  const resource = tfgen.createTypedResource('Route53Zone', 'aws_route53_zone', rname, fields);
  const zone_id: AT.HostedZoneId =  {type: 'HostedZoneId', value: '${' + TF.resourceName(resource) + '.zone_id}'};
  const name: string =  '${' + TF.resourceName(resource) + '.name}';

  return {
    ...resource,
    zone_id,
    name,
  };
}

export interface Route53Zone extends TF.ResourceT<'Route53Zone'> {
  zone_id: AT.HostedZoneId;
  name: string;
}

export type Route53ZoneId = {type:'Route53ZoneId',value:string};
